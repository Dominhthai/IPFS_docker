29417,16705,31799,9606,289,122254,115975,8620,6133,255357,56908,14456,133464,43554,79224,11247,29630,160,12756,25464,65960,350428,62521,321796,100359,67358,35169,46172,113128,48988,88868,31094,33266,6847,60887,98188,49659,69117,92977,220228,13947,80181,35103,62170,97351,13475,2440,199768,19498,36597,46971,25234,67806,62881,84717,73648,181966,10488,94149,21550,26655,63436,48375,14405,165650,9621,24439,28043,42735,4490,29963,56674,45373,1934,262446,50855,67098,26898,5261,52696,40644,33900,9440,180286,87162,22940,19704,26936,69769,10254,101759,27406,12243,48e3,73926,113215,54935,5726,192787,4312,106216,9366,11550,52949,23457,212271,277152,133895,108374,6191,96477,29980,218916,58024,54696,40853,91124,65894,91170,65908,252552,6793,29212,15389,44516,122515,52617,35058,9017,103536,39510,49136,19242,130652,662077,74699,47024,31422,8517,73351,24399,13867,128360,4810,4434,61779,111983,61036,17798,110240,59722,102960,39688,10001,23803,23039,176498,56659,44814,134295,17188,77577,74466,226175,102472,154333,63900,111747,18062,41171,79669,32773,408933,42562,28931,30907,107388,43487,2946,240310,23938,24354,319,184983,7927,6488,1422,10790,68809,68209,64775,4361,202,17123,59634,51200,44391,18188,17843,2619,74278,3230,9540,47187,21702,36274,56894,43907,16310,34790,16866,6150,5561,13587,107545,108873,126867,86986,28640,33427,19017,5762,80637,17430,46903,2047,131055,25958,13558,5444,47152,13900,44563,122857,45348,70863,39593,54332,38068,33637,318,40310,143467,18502,24520,11377,62013,28942,27246,28269,83545,17999,59015,90707,30065,15161,34720,1263,37008,2012,6060,98575,92933,5721,299,199555,24578,29223,2985,743,115825,109523,136657,47454,26378,53586,3733,174945,93340,244456,5693,37386,28782,89767,27545,23573,18798,136425,34320,84778,20041,48453,38215,7477,71958,40621,8773,5874,187927,105965,51100,43533,18083,8443,10180,43597,2003,183999,69689,12216,129696,146188,62389,34044,68410,12765,43273,26949,266807,3345,34477,79197,5688,47539,213110,21634,22257,50092,32222,42346,39530,63668,98,134978,74022,5152,59088,174145,37220,9934,9545,118937,5724,87240,19875,15784,40143,23263,87513,181654,285152,37881,263241,4966,43934,10433,186657,6470,74416,225854,25908,142677,246262,32280,6192,75890,45546,143264,135305,29742,47013,77787,11732,126658,8763,37950,21806,57557,113464,89465,108995,164574,23894,22996,23169,15369,23117,17642,130607,40503,36239,280990,44666,9981,40427,147487,26869,168452,32886,32991,46798,240839,15111,70502,65697,88548,44145,28701,48767,31139,206777,35659,181164,166262,14554,171445,31786,66523,76607,17956,6507,31279,90476,116611,167918,6560,1243,115324,80128,41867,55897,187323,37069,32596,189444,145931,13390,105530,65709,26805,6999,55714,41300,22915,68951,22138,21120,22264,10058,19945,33635,56123,99085,10032,5818,6016,46649,57476,35264,94413,112522,262288,93686,83038,14341,23204,28807,66084,77987,6101,126673,7133,38126,5923,122091,170240,97772,46874,215746,43948,41622,3272,55596,8332,146411,251315,13533,8561,81521,115449,48616,175175,2063,186556,3036,134537,75772,29728,82360,22973,186559,86348,89100,38388,82297,45610,2613,87082,9986,177812,57884,23591,47485,42543,33582,44713,74439,257444,252451,31825,35631,38540,33066,5147,13973,4343,51830,70378,22827,26448,95560,36896,241741,48067,203953,298860,61620,20450,3220,67272,6586,107662,100160,108684,6929,57226,4762,7457,1320,40404,77204,99309,62750,208653,59977,44e3,74315,34332,5819,172217,64904,114077,18147,84012,1791,98456,90930,21446,116669,103938,7422,85140,59713,5768,326211,16239,75411,13229,29398,10758,236107,1539,112472,95979,152154,151294,306,21196,38146,10700,6891,84282,109646,56492,40539,6589,119491,51354,30685,140209,136906,29622,73617,49553,70525,51671,166869,139616,74395,37439,49595,45678,11959,33211,86560,52434,9282,62690,112155,130810,5243,108261,99970,265613,72551,80049,6391,33365,90721,66737,69872,87011,1860,9032,112544,60905,37371,89015,140351,19076,850,373531,2802,36725,218795,72062,28990,16550,24614,7815,6187,26336,33373,32162,42791,73555,32062,23386,10244,56392,49442,27076,136262,12412,14883,1134,33675,97153,199281,15608,100152,74072,47942,254301,36451,16026,10687,65067,56708,254030,30290,50490,13864,57941,259331,35588,23485,43486,24869,21620,92971,22072,88645,1048,182050,13343,32452,14825,19509,3325,216938,45740,99716,189082,53740,78245,25609,24311,176777,47340,308354,40669,66085,14102,125339,9225,128709,97207,1271,200933,78439,113451,88975,18324,46521,11819,18570,141756,72512,170020,52754,63550,118515,103073,93330,32736,50499,14722,31600,68452,398867,29316,172786,18417,104924,2606,5670,84818,16288,67106,59580,82929,607401,291,85829,359,15897,35830,50696,65630,52672,22115,356968,29895,40837,231192,34024,38957,26722,406,23335,124952,72068,68804,13268,147101,164740,276569,162596,66943,11569,26654,66358,4777,23229,102127,5848,978,2921,59666,5371,28212,90108,42938,39320,2499,4271,108792,33510,125072,71653,65239,38250,66357,38577,13964,86251,35708,50755,36010,29448,12209,3844,38222,206337,100876,67827,137088,14167,252225,84163,195270,1306,5703,54198,779,46802,22028,51124,86759,70560,113164,35685,162145,45471,34561,422,2611,6464,47486,19223,38246,9191,18331,89942,243642,212364,15893,17518,22617,6409,30046,126182,59716,36560,104428,18846,26592,19458,50793,147333,30826,1388,27647,10922,14495,33545,19269,135828,39727,41601,46931,233379,49169,131130,182112,16276,82381,118209,142445,128310,19672,28740,82907,33436,3118,102206,28723,24819,41937,38854,5157,3881,111491,1142,9776,421673,152241,29309,14961,87854,6054,15424,3796,82656,54996,2108,55367,239450,154525,9643,118103,106041,64601,68549,48707,30266,25772,18740,9462,229669,91798,112152,191327,14493,72828,8175,66636,236474,25817,87351,129027,76653,20422,22983,71240,27846,44661,12399,46158,77704,53101,35032,11072,17300,109294,33638,24408,1895,11241,760,17584,82479,125877,63150,141075,34259,23274,81698,15732,43577,48340,91584,14688,16379,24481,150280,96420,262050,48635,43727,61819,56268,72003,88178,17281,79912,13218,122519,125295,166396,11811,2171,118930,67746,17636,178278,174656,95661,173039,83845,79689,17473,98555,127696,203415,54730,22925,232239,9309,12136,175026,20740,180188,10747,39816,314017,266131,10040,175732,112550,220651,31974,37393,888,23008,86799,4303,64905,148467,75337,251,3284,370102,50264,9835,5438,23655,4481,29851,329,12855,7162,64931,78141,12804,42372,296771,83547,18624,34874,86271,3360,48665,77735,88767,11463,63527,28889,22258,29140,194315,113924,25499,6406,31334,1845,4802,49184,43455,35469,127594,92970,61038,115005,38840,87761,106838,8811,20572,55637,11162,96721,132425,108925,2948,125457,36356,3502,75270,27622,127192,2561,123095,49394,61155,16897,110064,9699,89448,53356,19628,220310,21622,83036,9885,112214,6087,26713,17901,161912,91492,3440,68594,9266,92238,8087,6866,150194,72175,80701,13459,31836,43243,239700,95846,44749,50647,21945,230538,120612,132371,244604,5193,105637,34661,41341,68775,85393,1874,8771,33718,49672,77403,595452,99507,6490,58895,128742,7704,39239,73217,43816,62824,37804,199976,22361,80005,87514,94832,14089,4574,139975,59142,75523,100268,43906,53442,15152,2547,186002,17011,19513,204282,3343,60568,128318,119250,4298,51871,41336,71759,21921,45074,98169,145889,99427,11350,1237,5520,28799,7803,53702,21026,136352,38293,128690,12158,90132,44600,10184,26957,39459,126025,78904,82999,59373,39301,150198,120529,153042,20177,50089,14764,271571,30530,123161,38975,101562,22941,5648,124654,109243,69817,71675,49162,106884,21241,107795,30258,16572,188262,141456,7688,60718,8271,11044,32440,104608,103419,236109,93156,43293,128929,42107,67180,25201,115254,185488,130954,72813,167547,20537,39969,38432,22582,184022,1139,27199,5655,17767,97412,122606,209377,27070,35871,326617,188954,42680,73512,80911,22629,3011,95021,315242,157737,383,41821,41808,19335,27950,15674,25677,110950,35375,76835,59108,57370,35262,16569,160415,37706,78086,32041,49691,137143,9782,172080,50148,77917,6323,10110,69172,17711,21795,59511,76184,135114,31046,132319,59105,157578,20549,80778,57649,158421,65143,4575,72235,21899,10797,92745,34035,106079,80159,4508,78304,25350,75457,46458,32937,25623,47,8531,104751,84953,8138,36508,187199,66310,115274,13253,32461,38536,1916,42007,187160,35055,26325,84394,35963,94216,45590,97782];class Nue{constructor(e){(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"peerRouting",void 0),(0,Yo.Z)(this,"routingTable",void 0),(0,Yo.Z)(this,"refreshInterval",void 0),(0,Yo.Z)(this,"refreshQueryTimeout",void 0),(0,Yo.Z)(this,"commonPrefixLengthRefreshedAt",void 0),(0,Yo.Z)(this,"refreshTimeoutId",void 0);const{peerRouting:t,routingTable:n,refreshInterval:r,refreshQueryTimeout:i,lan:o}=e;this.log=xse("libp2p:kad-dht:".concat(o?"lan":"wan",":routing-table:refresh")),this.peerRouting=t,this.routingTable=n,this.refreshInterval=null!==r&&void 0!==r?r:Hse,this.refreshQueryTimeout=null!==i&&void 0!==i?i:qse,this.commonPrefixLengthRefreshedAt=[],this.refreshTable=this.refreshTable.bind(this)}async start(){this.log("refreshing routing table every ".concat(this.refreshInterval,"ms")),this.refreshTable(!0)}async stop(){null!=this.refreshTimeoutId&&clearTimeout(this.refreshTimeoutId)}refreshTable(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.log("refreshing routing table");const t=this._maxCommonPrefix(),n=this._getTrackedCommonPrefixLengthsForRefresh(t);this.log("max common prefix length ".concat(t)),this.log("tracked CPLs [ ".concat(n.map((e=>e.toISOString())).join(", ")," ]")),Promise.all(n.map((async(r,i)=>{try{if(await this._refreshCommonPrefixLength(i,r,e),0===this._numPeersForCpl(t)){const t=Math.min(2*(i+1),n.length-1);for(let n=i+1;n<t+1;n++)try{await this._refreshCommonPrefixLength(n,r,e)}catch(o){this.log.error(o)}}}catch(o){this.log.error(o)}}))).catch((e=>{this.log.error(e)})).then((()=>{this.refreshTimeoutId=setTimeout(this.refreshTable,this.refreshInterval),null!=this.refreshTimeoutId.unref&&this.refreshTimeoutId.unref()})).catch((e=>{this.log.error(e)}))}async _refreshCommonPrefixLength(e,t,n){if(!n&&t.getTime()>Date.now()-this.refreshInterval)return void this.log("not running refresh for cpl %s as time since last refresh not above interval",e);const r=await this._generateRandomPeerId(e);this.log("starting refreshing cpl %s with key %p (routing table size was %s)",e,r,this.routingTable.size);const i=await _ue(this.peerRouting.getClosestPeers(r.toBytes(),{signal:AbortSignal.timeout(this.refreshQueryTimeout)}));this.log("found ".concat(i," peers that were close to imaginary peer %p"),r),this.log("finished refreshing cpl %s with key %p (routing table size is now %s)",e,r,this.routingTable.size)}_getTrackedCommonPrefixLengthsForRefresh(e){e>15&&(e=15);const t=[];for(let r=0;r<=e;r++){var n;t[r]=null!==(n=this.commonPrefixLengthRefreshedAt[r])&&void 0!==n?n:new Date}return t}async _generateRandomPeerId(e){if(null==this.routingTable.kb)throw new Error("Routing table not started");const t=Ule(2),n=(t[1]<<8)+t[0];return _ce(await this._makePeerId(this.routingTable.kb.localNodeId,n,e))}async _makePeerId(e,t,n){if(n>15)throw new Error("Cannot generate peer ID for common prefix length greater than ".concat(15));const r=new DataView(e.buffer,e.byteOffset,e.byteLength).getUint16(0,!1),i=65535<<16-(n+1),o=Oue[(r^32768>>n)&i|t&~i],s=new ArrayBuffer(34),a=new DataView(s,0,s.byteLength);return a.setUint8(0,$ae.code),a.setUint8(1,32),a.setUint32(2,o,!1),new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}_maxCommonPrefix(){let e=0;for(const t of this._prefixLengths())t>e&&(e=t);return e}_numPeersForCpl(e){let t=0;for(const n of this._prefixLengths())n===e&&t++;return t}*_prefixLengths(){if(null!=this.routingTable.kb)for(const{id:e}of this.routingTable.kb.toIterable()){const t=uue(this.routingTable.kb.localNodeId,e);let n=0;for(const e of t){if(0!==e)break;n++}yield n}}}const Bue=xse("libp2p:kad-dht:rpc:handlers:add-provider");class Lue{constructor(e){(0,Yo.Z)(this,"providers",void 0);const{providers:t}=e;this.providers=t}async handle(e,t){if(Bue("start"),null==t.key||0===t.key.length)throw new qoe("Missing key","ERR_MISSING_KEY");let n;try{n=ice.decode(t.key)}catch(r){throw new qoe("Invalid CID","ERR_INVALID_CID")}null!=t.providerPeers&&0!==t.providerPeers.length||Bue.error("no providers found in message"),await Promise.all(t.providerPeers.map((async t=>{t.id.equals(e)?t.multiaddrs.length<1?Bue("no valid addresses for provider %p. Ignore",e):(Bue("received provider %p for %s (addrs %s)",e,n,t.multiaddrs.map((e=>e.toString()))),await this.providers.addProvider(n,t.id)):Bue("invalid provider peer %p from %p",t.id,e)})))}}const Mue=xse("libp2p:kad-dht:rpc:handlers:find-node");class Uue{constructor(e,t){(0,Yo.Z)(this,"peerRouting",void 0),(0,Yo.Z)(this,"lan",void 0),(0,Yo.Z)(this,"components",void 0);const{peerRouting:n,lan:r}=t;this.components=e,this.peerRouting=n,this.lan=Boolean(r)}async handle(e,t){Mue("incoming request from %p for peers closer to %b",e,t.key);let n=[];n=(0,ed.fS)(this.components.peerId.toBytes(),t.key)?[{id:this.components.peerId,multiaddrs:this.components.addressManager.getAddresses().map((e=>e.decapsulateCode((0,og.a_)("p2p").code))),protocols:[]}]:await this.peerRouting.getCloserPeersOffline(t.key,e),n=n.map(this.lan?ele:$ce).filter((e=>{let{multiaddrs:t}=e;return t.length}));const r=new Nce(t.type,new Uint8Array(0),t.clusterLevel);return n.length>0?r.closerPeers=n:Mue("could not find any peers closer to %b than %p",t.key,e),r}}const Fue=xse("libp2p:kad-dht:rpc:handlers:get-providers");class Kue{constructor(e,t){(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"peerRouting",void 0),(0,Yo.Z)(this,"providers",void 0),(0,Yo.Z)(this,"lan",void 0);const{peerRouting:n,providers:r,lan:i}=t;this.components=e,this.peerRouting=n,this.providers=r,this.lan=Boolean(i)}async handle(e,t){let n;try{n=ice.decode(t.key)}catch(c){throw new qoe("Invalid CID","ERR_INVALID_CID")}Fue("%p asking for providers for %s",e,n);const[r,i]=await Promise.all([this.providers.getProviders(n),this.peerRouting.getCloserPeersOffline(t.key,e)]),o=await this._getPeers(r),s=await this._getPeers(i.map((e=>{let{id:t}=e;return t}))),a=new Nce(t.type,t.key,t.clusterLevel);return o.length>0&&(a.providerPeers=o),s.length>0&&(a.closerPeers=s),Fue("got %s providers %s closerPeers",o.length,s.length),a}async _getAddresses(e){return[]}async _getPeers(e){const t=[],n=this.lan?ele:$ce;for(const i of e)try{const e=await this.components.peerStore.get(i),r=n({id:i,multiaddrs:e.addresses.map((e=>{let{multiaddr:t}=e;return t})),protocols:e.protocols});r.multiaddrs.length>0&&t.push(r)}catch(r){if("ERR_NOT_FOUND"!==r.code)throw r}return t}}const jue=xse("libp2p:kad-dht:rpc:handlers:get-value");class Zue{constructor(e,t){(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"peerRouting",void 0);const{peerRouting:n}=t;this.components=e,this.peerRouting=n}async handle(e,t){const n=t.key;if(jue("%p asked for key %b",e,n),null==n||0===n.length)throw new qoe("Invalid key","ERR_INVALID_KEY");const r=new Nce(Pce.GET_VALUE,n,t.clusterLevel);if(function(e){return"/pk/"===(0,Su.B)(e.subarray(0,4))}(n)){jue("is public key");const e=function(e){return _ce(e.subarray(4))}(n);let t;try{const n=await this.components.peerStore.get(e);if(null==n.id.publicKey)throw new qoe("No public key found in key book","ERR_NOT_FOUND");t=n.id.publicKey}catch(s){if("ERR_NOT_FOUND"!==s.code)throw s}if(null!=t)return jue("returning found public key"),r.record=new xce(n,t,new Date),r}const[i,o]=await Promise.all([this._checkLocalDatastore(n),this.peerRouting.getCloserPeersOffline(t.key,e)]);return null!=i&&(jue("had record for %b in local datastore",n),r.record=i),o.length>0&&(jue("had %s closer peers in routing table",o.length),r.closerPeers=o),r}async _checkLocalDatastore(e){jue("checkLocalDatastore looking for %b",e);const t=rle(e);let n;try{n=await this.components.datastore.get(t)}catch(i){if("ERR_NOT_FOUND"===i.code)return;throw i}const r=xce.deserialize(n);if(null==r)throw new qoe("Invalid record","ERR_INVALID_RECORD");if(!(null==r.timeReceived||Date.now()-r.timeReceived.getTime()>1296e5))return r;await this.components.datastore.delete(t)}}const zue=xse("libp2p:kad-dht:rpc:handlers:ping");class Vue{async handle(e,t){return zue("ping from %p",e),t}}class Hue{constructor(e,t){(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"validators",void 0);const{validators:n}=t;this.components=e,this.log=xse("libp2p:kad-dht:rpc:handlers:put-value"),this.validators=n}async handle(e,t){const n=t.key;this.log("%p asked us to store value for key %b",e,n);const r=t.record;if(null==r){const t="Empty record from: ".concat(e.toString());throw this.log.error(t),new qoe(t,"ERR_EMPTY_RECORD")}try{await Hce(this.validators,r),r.timeReceived=new Date;const e=rle(r.key);await this.components.datastore.put(e,r.serialize().subarray()),this.log("put record for %b into datastore under key %k",n,e)}catch(i){this.log("did not put record for key %b into datastore %o",n,i)}return t}}class que{constructor(e,t){(0,Yo.Z)(this,"handlers",void 0),(0,Yo.Z)(this,"routingTable",void 0),(0,Yo.Z)(this,"log",void 0);const{providers:n,peerRouting:r,validators:i,lan:o}=t;this.log=xse("libp2p:kad-dht:rpc"),this.routingTable=t.routingTable,this.handlers={[Pce.GET_VALUE]:new Zue(e,{peerRouting:r}),[Pce.PUT_VALUE]:new Hue(e,{validators:i}),[Pce.FIND_NODE]:new Uue(e,{peerRouting:r,lan:o}),[Pce.ADD_PROVIDER]:new Lue({providers:n}),[Pce.GET_PROVIDERS]:new Kue(e,{peerRouting:r,providers:n,lan:o}),[Pce.PING]:new Vue}}async handleMessage(e,t){try{await this.routingTable.add(e)}catch(r){this.log.error("Failed to update the kbucket store",r)}const n=this.handlers[t.type];if(null!=n)return n.handle(e,t);this.log.error("no handler found for message type: ".concat(t.type))}onIncomingStream(e){Promise.resolve().then((async()=>{const{stream:t,connection:n}=e,r=n.remotePeer;try{await this.routingTable.add(r)}catch(o){this.log.error(o)}const i=this;await Yse(t,(e=>fle(e)),(async function*(e){for await(const t of e){const e=Nce.deserialize(t);i.log("incoming %s from %p",e.type,r);const n=await i.handleMessage(r,e);null!=n&&(yield n.serialize())}}),(e=>ule(e)),t)})).catch((e=>{this.log.error(e)}))}}class Gue extends Xoe{constructor(e,t){super(),(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"protocol",void 0),(0,Yo.Z)(this,"running",void 0),(0,Yo.Z)(this,"registrarId",void 0);const{protocol:n,lan:r}=t;this.components=e,this.log=xse("libp2p:kad-dht:topology-listener:".concat(r?"lan":"wan")),this.running=!1,this.protocol=n}isStarted(){return this.running}async start(){this.running||(this.running=!0,this.registrarId=await this.components.registrar.register(this.protocol,{onConnect:e=>{this.log("observed peer %p with protocol %s",e,this.protocol),this.dispatchEvent(new ese("peer",{detail:e}))}}))}async stop(){this.running=!1,null!=this.registrarId&&(this.components.registrar.unregister(this.registrarId),this.registrarId=void 0)}}class Wue extends Xoe{constructor(e,t){super(),(0,Yo.Z)(this,"protocol",void 0),(0,Yo.Z)(this,"routingTable",void 0),(0,Yo.Z)(this,"providers",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"peerRouting",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"running",void 0),(0,Yo.Z)(this,"kBucketSize",void 0),(0,Yo.Z)(this,"clientMode",void 0),(0,Yo.Z)(this,"lan",void 0),(0,Yo.Z)(this,"validators",void 0),(0,Yo.Z)(this,"selectors",void 0),(0,Yo.Z)(this,"queryManager",void 0),(0,Yo.Z)(this,"contentFetching",void 0),(0,Yo.Z)(this,"contentRouting",void 0),(0,Yo.Z)(this,"routingTableRefresh",void 0),(0,Yo.Z)(this,"rpc",void 0),(0,Yo.Z)(this,"topologyListener",void 0),(0,Yo.Z)(this,"querySelf",void 0),(0,Yo.Z)(this,"maxInboundStreams",void 0),(0,Yo.Z)(this,"maxOutboundStreams",void 0);const{kBucketSize:n,clientMode:r,validators:i,selectors:o,querySelfInterval:s,lan:a,protocolPrefix:c,pingTimeout:l,pingConcurrency:u,maxInboundStreams:h,maxOutboundStreams:d,providers:f}=t;this.running=!1,this.components=e,this.lan=Boolean(a),this.log=xse("libp2p:kad-dht:".concat(!0===a?"lan":"wan")),this.protocol="".concat(null!==c&&void 0!==c?c:"/ipfs").concat(!0===a?"/lan":"").concat("/kad/1.0.0"),this.kBucketSize=null!==n&&void 0!==n?n:20,this.clientMode=null===r||void 0===r||r,this.maxInboundStreams=null!==h&&void 0!==h?h:32,this.maxOutboundStreams=null!==d&&void 0!==d?d:64,this.routingTable=new Due(e,{kBucketSize:n,lan:this.lan,pingTimeout:l,pingConcurrency:u,protocol:this.protocol}),this.providers=new yue(e,null!==f&&void 0!==f?f:{}),this.validators={...qce,...i},this.selectors={...Vce,...o},this.network=new ple(e,{protocol:this.protocol,lan:this.lan});const p=Ws();!0===t.allowQueryWithZeroPeers&&p.resolve(),this.queryManager=new Sue(e,{disjointPaths:Math.ceil(this.kBucketSize/2),lan:a,initialQuerySelfHasRun:p,routingTable:this.routingTable}),this.peerRouting=new due(e,{routingTable:this.routingTable,network:this.network,validators:this.validators,queryManager:this.queryManager,lan:this.lan}),this.contentFetching=new ole(e,{validators:this.validators,selectors:this.selectors,peerRouting:this.peerRouting,queryManager:this.queryManager,network:this.network,lan:this.lan}),this.contentRouting=new sle(e,{network:this.network,peerRouting:this.peerRouting,queryManager:this.queryManager,routingTable:this.routingTable,providers:this.providers,lan:this.lan}),this.routingTableRefresh=new Nue({peerRouting:this.peerRouting,routingTable:this.routingTable,lan:this.lan}),this.rpc=new que(e,{routingTable:this.routingTable,providers:this.providers,peerRouting:this.peerRouting,validators:this.validators,lan:this.lan}),this.topologyListener=new Gue(e,{protocol:this.protocol,lan:this.lan}),this.querySelf=new kue(e,{peerRouting:this.peerRouting,interval:s,initialInterval:t.initialQuerySelfInterval,lan:this.lan,initialQuerySelfHasRun:p,routingTable:this.routingTable}),this.network.addEventListener("peer",(e=>{const t=e.detail;this.onPeerConnect(t).catch((e=>{this.log.error("could not add %p to routing table",t.id,e)})),this.dispatchEvent(new ese("peer",{detail:t}))})),this.topologyListener.addEventListener("peer",(e=>{const t=e.detail;Promise.resolve().then((async()=>{const e=await this.components.peerStore.get(t),n={id:t,multiaddrs:e.addresses.map((e=>{let{multiaddr:t}=e;return t})),protocols:e.protocols};await this.onPeerConnect(n)})).catch((e=>{this.log.error("could not add %p to routing table",t,e)}))}))}async onPeerConnect(e){if(this.log("peer %p connected with protocols",e.id,e.protocols),0!==(e=this.lan?ele(e):$ce(e)).multiaddrs.length)try{await this.routingTable.add(e.id)}catch(t){this.log.error("could not add %p to routing table",e.id,t)}else this.log("ignoring %p as they do not have any %s addresses in %s",e.id,this.lan?"private":"public",e.multiaddrs.map((e=>e.toString())))}isStarted(){return this.running}async getMode(){return this.clientMode?"client":"server"}async setMode(e){await this.components.registrar.unhandle(this.protocol),"client"===e?(this.log("enabling client mode"),this.clientMode=!0):(this.log("enabling server mode"),this.clientMode=!1,await this.components.registrar.handle(this.protocol,this.rpc.onIncomingStream.bind(this.rpc),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}))}async start(){this.running=!0,await this.setMode(this.clientMode?"client":"server"),await Promise.all([this.providers.start(),this.queryManager.start(),this.network.start(),this.routingTable.start(),this.topologyListener.start()]),this.querySelf.start(),await this.routingTableRefresh.start()}async stop(){this.running=!1,this.querySelf.stop(),await Promise.all([this.providers.stop(),this.queryManager.stop(),this.network.stop(),this.routingTable.stop(),this.routingTableRefresh.stop(),this.topologyListener.stop()])}put(e,t){try{var n=this;let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return async function*(){yield*n.contentFetching.put(e,t,r)}()}catch(r){return Promise.reject(r)}}get(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){yield*t.contentFetching.get(e,n)}()}catch(n){return Promise.reject(n)}}provide(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){yield*t.contentRouting.provide(e,t.components.addressManager.getAddresses(),n)}()}catch(n){return Promise.reject(n)}}findProviders(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){yield*t.contentRouting.findProviders(e,n)}()}catch(n){return Promise.reject(n)}}findPeer(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){yield*t.peerRouting.findPeer(e,n)}()}catch(n){return Promise.reject(n)}}getClosestPeers(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){yield*t.peerRouting.getClosestPeers(e,n)}()}catch(n){return Promise.reject(n)}}async refreshRoutingTable(){this.routingTableRefresh.refreshTable(!0)}}let Que;const Yue=xse("libp2p:kad-dht");class Jue{constructor(e){(0,Yo.Z)(this,"dht",void 0),this.dht=e}async provide(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await Pse(this.dht.provide(e,t))}findProviders(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of t.dht.findProviders(e,n))"PROVIDER"===r.name&&(yield*r.providers)}()}catch(n){return Promise.reject(n)}}async put(e,t,n){await Pse(this.dht.put(e,t,n))}async get(e,t){for await(const n of this.dht.get(e,t))if("VALUE"===n.name)return n.value;throw new qoe("Not found","ERR_NOT_FOUND")}}class Xue{constructor(e){(0,Yo.Z)(this,"dht",void 0),this.dht=e}async findPeer(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for await(const n of this.dht.findPeer(e,t))if("FINAL_PEER"===n.name)return n.peer;throw new qoe("Not found","ERR_NOT_FOUND")}getClosestPeers(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of t.dht.getClosestPeers(e,n))"FINAL_PEER"===r.name&&(yield r.peer)}()}catch(n){return Promise.reject(n)}}}Que=Symbol.toStringTag;class $ue extends Xoe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),(0,Yo.Z)(this,"wan",void 0),(0,Yo.Z)(this,"lan",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"contentRouting",void 0),(0,Yo.Z)(this,"peerRouting",void 0),(0,Yo.Z)(this,Que,"@libp2p/dual-kad-dht"),this.components=e,this.wan=new Wue(e,{protocolPrefix:"/ipfs",...t,lan:!1}),this.lan=new Wue(e,{protocolPrefix:"/ipfs",...t,clientMode:!1,lan:!0}),this.contentRouting=new Jue(this),this.peerRouting=new Xue(this),this.wan.addEventListener("peer",(e=>{this.dispatchEvent(new ese("peer",{detail:e.detail}))})),this.lan.addEventListener("peer",(e=>{this.dispatchEvent(new ese("peer",{detail:e.detail}))})),null==t.clientMode&&e.events.addEventListener("self:peer:update",(e=>{Yue("received update of self-peer info");const t=e.detail.peer.addresses.some((e=>{let{multiaddr:t}=e;return function(e){const t=e.stringTuples();for(const n of t)if(290===n[0])return!1;if(54===t[0][0]||55===t[0][0]||56===t[0][0])return!0;if(4===t[0][0]||41===t[0][0]){const e=SS("".concat(t[0][1]));return null==e||!e}return!1}(t)}));this.getMode().then((async e=>{t&&"client"===e?await this.setMode("server"):"server"!==e||t||await this.setMode("client")})).catch((e=>{Yue.error("error setting dht server mode",e)}))}))}get[Voe](){return this.contentRouting}get[rse](){return this.peerRouting}get[nse](){return this}isStarted(){return this.wan.isStarted()&&this.lan.isStarted()}async getMode(){return this.wan.getMode()}async setMode(e){await this.wan.setMode(e)}async start(){await Promise.all([this.lan.start(),this.wan.start()])}async stop(){await Promise.all([this.lan.stop(),this.wan.stop()])}put(e,t){try{var n=this;let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return async function*(){for await(const i of Mse(n.lan.put(e,t,r),n.wan.put(e,t,r)))yield i}()}catch(r){return Promise.reject(r)}}get(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){let r=!1,i=!1;for await(const o of Mse(t.lan.get(e,n),t.wan.get(e,n)))yield o,"DIAL_PEER"===o.name&&(r=!0),"VALUE"===o.name&&(r=!0,null!=o.value&&(i=!0)),"SEND_QUERY"===o.name&&(r=!0);if(!r)throw new qoe("No peers found in routing table!","ERR_NO_PEERS_IN_ROUTING_TABLE");i||(yield Kce({from:t.components.peerId,error:new qoe("Not found","ERR_NOT_FOUND")},n))}()}catch(n){return Promise.reject(n)}}provide(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){let r=0,i=0;const o=[],s=[t.lan];"server"===await t.wan.getMode()&&s.push(t.wan);for await(const t of Mse(...s.map((t=>t.provide(e,n)))))yield t,"SEND_QUERY"===t.name&&r++,"QUERY_ERROR"===t.name&&o.push(t.error),"PEER_RESPONSE"===t.name&&"ADD_PROVIDER"===t.messageName&&(Yue("sent provider record for %s to %p",e,t.from),i++);if(0===i){if(o.length>0)throw new qoe("Failed to provide to ".concat(o.length," of ").concat(r," peers"),"ERR_PROVIDES_FAILED",{errors:o});throw new qoe("Failed to provide - no peers found","ERR_PROVIDES_FAILED")}}()}catch(n){return Promise.reject(n)}}findProviders(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){yield*Mse(t.lan.findProviders(e,n),t.wan.findProviders(e,n))}()}catch(n){return Promise.reject(n)}}findPeer(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){let r=!1;for await(const i of Mse(t.lan.findPeer(e,n),t.wan.findPeer(e,n)))yield i,"SEND_QUERY"!==i.name&&"FINAL_PEER"!==i.name||(r=!0);if(!r)throw new qoe("Peer lookup failed","ERR_LOOKUP_FAILED")}()}catch(n){return Promise.reject(n)}}getClosestPeers(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){yield*Mse(t.lan.getClosestPeers(e,n),t.wan.getClosestPeers(e,n))}()}catch(n){return Promise.reject(n)}}async refreshRoutingTable(){await Promise.all([this.lan.refreshRoutingTable(),this.wan.refreshRoutingTable()])}}var ehe,the;function nhe(e){return t=>new $ue(t,e)}!function(e){e[e.SEND_QUERY=0]="SEND_QUERY",e[e.PEER_RESPONSE=1]="PEER_RESPONSE",e[e.FINAL_PEER=2]="FINAL_PEER",e[e.QUERY_ERROR=3]="QUERY_ERROR",e[e.PROVIDER=4]="PROVIDER",e[e.VALUE=5]="VALUE",e[e.ADD_PEER=6]="ADD_PEER",e[e.DIAL_PEER=7]="DIAL_PEER"}(ehe||(ehe={})),function(e){e[e.PUT_VALUE=0]="PUT_VALUE",e[e.GET_VALUE=1]="GET_VALUE",e[e.ADD_PROVIDER=2]="ADD_PROVIDER",e[e.GET_PROVIDERS=3]="GET_PROVIDERS",e[e.FIND_NODE=4]="FIND_NODE",e[e.PING=5]="PING"}(the||(the={}));class rhe extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"The operation was aborted"),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"type",void 0),this.code=rhe.code,this.type=rhe.type}}(0,Yo.Z)(rhe,"code","ABORT_ERR"),(0,Yo.Z)(rhe,"type","aborted");class ihe extends Error{constructor(e,t,n){var r;super(e),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"props",void 0),this.code=t,this.name=null!==(r=null===n||void 0===n?void 0:n.name)&&void 0!==r?r:"CodeError",this.props=null!==n&&void 0!==n?n:{}}}class ohe extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected Peer"),(0,Yo.Z)(this,"code",void 0),this.code=ohe.code}}(0,Yo.Z)(ohe,"code","ERR_UNEXPECTED_PEER");class she extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto exchange"),(0,Yo.Z)(this,"code",void 0),this.code=she.code}}(0,Yo.Z)(she,"code","ERR_INVALID_CRYPTO_EXCHANGE");class ahe extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto transmission"),(0,Yo.Z)(this,"code",void 0),this.code=ahe.code}}(0,Yo.Z)(ahe,"code","ERR_INVALID_CRYPTO_TRANSMISSION");var che=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=h,t++}if(" "!==e[t]){for(var f=o-i;f!==o&&0===s[f];)f++;for(var p=new Uint8Array(r+(o-f)),g=r;f!==o;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=0,o=t.length;i!==o&&0===t[i];)i++,n++;for(var s=(o-i)*u+1>>>0,l=new Uint8Array(s);i!==o;){for(var h=t[i],d=0,f=s-1;(0!==h||d<r)&&-1!==f;f--,d++)h+=256*l[f]>>>0,l[f]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");r=d,i++}for(var p=s-r;p!==s&&0===l[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:h,decode:function(e){var n=h(e);if(n)return n;throw new Error("Non-".concat(t," character"))}}};const lhe=che;new Uint8Array(0);class uhe{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return"".concat(this.prefix).concat(this.baseEncode(e));throw Error("Unknown type, must be binary type")}}class hhe{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"===typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error("Unable to decode multibase string ".concat(JSON.stringify(e),", ").concat(this.name," decoder only supports inputs prefixed with ").concat(this.prefix));return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return fhe(this,e)}}class dhe{constructor(e){this.decoders=e}or(e){return fhe(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e),", only inputs prefixed with ").concat(Object.keys(this.decoders)," are supported"))}}const fhe=(e,t)=>new dhe({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class phe{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new uhe(e,t,n),this.decoder=new hhe(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const ghe=e=>{let{name:t,prefix:n,encode:r,decode:i}=e;return new phe(t,n,r,i)},yhe=e=>{let{prefix:t,name:n,alphabet:r}=e;const{encode:i,decode:o}=lhe(r,n);return ghe({prefix:t,name:n,encode:i,decode:e=>(e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")})(o(e))})},mhe=e=>{let{name:t,prefix:n,bitsPerChar:r,alphabet:i}=e;return ghe({prefix:n,name:t,encode:e=>((e,t,n)=>{const r="="===t[t.length-1],i=(1<<n)-1;let o="",s=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],s+=8;s>n;)s-=n,o+=t[i&a>>s];if(s&&(o+=t[i&a<<n-s]),r)for(;o.length*n&7;)o+="=";return o})(e,i,r),decode:e=>((e,t,n,r)=>{const i={};for(let u=0;u<t.length;++u)i[t[u]]=u;let o=e.length;for(;"="===e[o-1];)--o;const s=new Uint8Array(o*n/8|0);let a=0,c=0,l=0;for(let u=0;u<o;++u){const t=i[e[u]];if(void 0===t)throw new SyntaxError("Non-".concat(r," character"));c=c<<n|t,a+=n,a>=8&&(a-=8,s[l++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,i,r,t)})},vhe=mhe({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),bhe=(mhe({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),mhe({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),mhe({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),mhe({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),mhe({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),mhe({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),mhe({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),mhe({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),yhe({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"})),whe=(yhe({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),mhe({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}));mhe({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),mhe({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),mhe({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});function Ehe(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return cf().enabled("".concat(e,":trace"))&&null!=cf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=cf()("".concat(e,":trace"))),Object.assign(cf()(e),{error:cf()("".concat(e,":error")),trace:t})}cf().formatters.b=e=>null==e?"undefined":bhe.baseEncode(e),cf().formatters.t=e=>null==e?"undefined":vhe.baseEncode(e),cf().formatters.m=e=>null==e?"undefined":whe.baseEncode(e),cf().formatters.p=e=>null==e?"undefined":e.toString(),cf().formatters.c=e=>null==e?"undefined":e.toString(),cf().formatters.k=e=>null==e?"undefined":e.toString(),cf().formatters.a=e=>null==e?"undefined":e.toString();var Ahe,She=n(79023);class _he{constructor(e){if((0,Yo.Z)(this,"buffer",void 0),(0,Yo.Z)(this,"mask",void 0),(0,Yo.Z)(this,"top",void 0),(0,Yo.Z)(this,"btm",void 0),(0,Yo.Z)(this,"next",void 0),!(e>0)||0!==(e-1&e))throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return void 0===this.buffer[this.top]&&(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(void 0!==e)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return void 0===this.buffer[this.btm]}}class Ihe{constructor(){var e;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"size",void 0),(0,Yo.Z)(this,"hwm",void 0),(0,Yo.Z)(this,"head",void 0),(0,Yo.Z)(this,"tail",void 0),this.hwm=null!==(e=t.splitLimit)&&void 0!==e?e:16,this.head=new _he(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return null!=(null===e||void 0===e?void 0:e.byteLength)?e.byteLength:1}push(e){if(null!=(null===e||void 0===e?void 0:e.value)&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new _he(2*this.head.buffer.length),this.head.push(e)}}shift(){var e;let t=this.tail.shift();if(void 0===t&&null!=this.tail.next){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return null!=(null===(e=t)||void 0===e?void 0:e.value)&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}class Che extends Error{constructor(e,t){super(null!==e&&void 0!==e?e:"The operation was aborted"),(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"code",void 0),this.type="aborted",this.code=null!==t&&void 0!==t?t:"ABORT_ERR"}}function The(e,t){var n;let r,i,o,s=(t=null!==(n=t)&&void 0!==n?n:{}).onEnd,a=new Ihe,c=Ws();const l=e=>null!=i?i(e):(a.push(e),r),u=e=>{var n;if(o)return r;if(!0!==(null===(n=t)||void 0===n?void 0:n.objectMode)&&null==(null===e||void 0===e?void 0:e.byteLength))throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:e})},h=e=>o?r:(o=!0,null!=e?(e=>(a=new Ihe,null!=i?i({error:e}):(a.push({error:e}),r)))(e):l({done:!0}));if(r={[Symbol.asyncIterator](){return this},next:async()=>{try{return a.isEmpty()?o?{done:!0}:await new Promise(((t,n)=>{i=o=>{i=null,a.push(o);try{t(e(a))}catch(s){n(s)}return r}})):e(a)}finally{a.isEmpty()&&queueMicrotask((()=>{c.resolve(),c=Ws()}))}},return:()=>(a=new Ihe,h(),{done:!0}),throw:e=>(h(e),{done:!0}),push:u,end:h,get readableLength(){return a.size},onEmpty:async e=>{const t=null===e||void 0===e?void 0:e.signal;if(null===t||void 0===t||t.throwIfAborted(),a.isEmpty())return;let n,r;null!=t&&(n=new Promise(((e,n)=>{r=()=>{n(new Che)},t.addEventListener("abort",r)})));try{await Promise.race([c.promise,n])}finally{null!=r&&null!=t&&(null===t||void 0===t||t.removeEventListener("abort",r))}}},null==s)return r;const d=r;return r={[Symbol.asyncIterator](){return this},next:()=>d.next(),throw:e=>(d.throw(e),null!=s&&(s(e),s=void 0),{done:!0}),return:()=>(d.return(),null!=s&&(s(),s=void 0),{done:!0}),push:u,end:e=>(d.end(e),null!=s&&(s(e),s=void 0),r),get readableLength(){return d.readableLength},onEmpty:e=>d.onEmpty(e)},r}!function(e){e[e.NEW_STREAM=0]="NEW_STREAM",e[e.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",e[e.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",e[e.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",e[e.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",e[e.RESET_RECEIVER=5]="RESET_RECEIVER",e[e.RESET_INITIATOR=6]="RESET_INITIATOR"}(Ahe||(Ahe={}));const khe=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),Rhe=Object.freeze({NEW_STREAM:Ahe.NEW_STREAM,MESSAGE:Ahe.MESSAGE_INITIATOR,CLOSE:Ahe.CLOSE_INITIATOR,RESET:Ahe.RESET_INITIATOR}),xhe=Object.freeze({MESSAGE:Ahe.MESSAGE_RECEIVER,CLOSE:Ahe.CLOSE_RECEIVER,RESET:Ahe.RESET_RECEIVER}),Phe=1<<20;class Dhe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Phe,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4194304;(0,Yo.Z)(this,"_buffer",void 0),(0,Yo.Z)(this,"_headerInfo",void 0),(0,Yo.Z)(this,"_maxMessageSize",void 0),(0,Yo.Z)(this,"_maxUnprocessedMessageQueueSize",void 0),this._buffer=new Zs,this._headerInfo=null,this._maxMessageSize=e,this._maxUnprocessedMessageQueueSize=t}write(e){if(null==e||0===e.length)return[];if(this._buffer.append(e),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw Object.assign(new Error("unprocessed message queue size too large!"),{code:"ERR_MSG_QUEUE_TOO_BIG"});const t=[];for(;0!==this._buffer.length;){if(null==this._headerInfo)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(n){if("ERR_MSG_TOO_BIG"===n.code)throw n;break}const{id:e,type:r,length:i,offset:o}=this._headerInfo;if(this._buffer.length-o<i)break;const s={id:e,type:r};r!==Ahe.NEW_STREAM&&r!==Ahe.MESSAGE_INITIATOR&&r!==Ahe.MESSAGE_RECEIVER||(s.data=this._buffer.sublist(o,o+i)),t.push(s),this._buffer.consume(o+i),this._headerInfo=null}return t}_decodeHeader(e){const{value:t,offset:n}=Bhe(e),{value:r,offset:i}=Bhe(e,n),o=7&t;if(null==khe[o])throw new Error("Invalid type received: ".concat(o));if(r>this._maxMessageSize)throw Object.assign(new Error("message size too large!"),{code:"ERR_MSG_TOO_BIG"});return{id:t>>3,type:o,offset:n+i,length:r}}}const Ohe=128,Nhe=127;function Bhe(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=0,i=0,o=n;const s=e.length;do{if(o>=s||i>49)throw n=0,new RangeError("Could not decode varint");t=e.get(o++),r+=i<28?(t&Nhe)<<i:(t&Nhe)*Math.pow(2,i),i+=7}while(t>=Ohe);return n=o-n,{value:r,offset:n}}const Lhe=1048576,Mhe=(e,t)=>{t.append(e)};const Uhe=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(n,r,i){let o=new Zs,s=!1,a=Ws(),c=Number(null!==(n=null===t||void 0===t?void 0:t.size)&&void 0!==n?n:Lhe);if((isNaN(c)||0===c||c<0)&&(c=Lhe),c!==Math.round(c))throw new Error("Batch size must be an integer");const l=null!==(r=null===t||void 0===t?void 0:t.yieldAfter)&&void 0!==r?r:0,u=null!==(i=null===t||void 0===t?void 0:t.serialize)&&void 0!==i?i:Mhe;for(Promise.resolve().then((async()=>{try{let t;for await(const n of e)u(n,o),o.byteLength>=c?(clearTimeout(t),a.resolve()):t=setTimeout((()=>{a.resolve()}),l);clearTimeout(t),a.resolve()}catch(t){a.reject(t)}finally{s=!0}}));!s;)if(await a.promise,a=Ws(),o.byteLength>0){const e=o;o=new Zs,yield e.subarray()}}():function*(n,r){const i=new Zs;let o=Number(null!==(n=null===t||void 0===t?void 0:t.size)&&void 0!==n?n:Lhe);if((isNaN(o)||0===o||o<0)&&(o=Lhe),o!==Math.round(o))throw new Error("Batch size must be an integer");const s=null!==(r=null===t||void 0===t?void 0:t.serialize)&&void 0!==r?r:Mhe;for(const t of e)s(t,i),i.byteLength>=o&&(yield i.subarray(0,o),i.consume(o));i.byteLength>0&&(yield i.subarray())}()};function Fhe(e){return new Uint8Array(e)}const Khe=10240;const jhe=new class{constructor(){(0,Yo.Z)(this,"_pool",void 0),(0,Yo.Z)(this,"_poolOffset",void 0),this._pool=Fhe(Khe),this._poolOffset=0}write(e,t){const n=this._pool;let r=this._poolOffset;Bs.cv(e.id<<3|e.type,n,r),r+=Bs.P$(e.id<<3|e.type),e.type!==Ahe.NEW_STREAM&&e.type!==Ahe.MESSAGE_INITIATOR&&e.type!==Ahe.MESSAGE_RECEIVER||null==e.data?(Bs.cv(0,n,r),r+=Bs.P$(0)):(Bs.cv(e.data.length,n,r),r+=Bs.P$(e.data.length));const i=n.subarray(this._poolOffset,r);Khe-r<100?(this._pool=Fhe(Khe),this._poolOffset=0):this._poolOffset=r,t.append(i),e.type!==Ahe.NEW_STREAM&&e.type!==Ahe.MESSAGE_INITIATOR&&e.type!==Ahe.MESSAGE_RECEIVER||null==e.data||t.append(e.data)}};function Zhe(e){return null!=e&&"function"===typeof e.then}class zhe{constructor(e){var t,n;(0,Yo.Z)(this,"id",void 0),(0,Yo.Z)(this,"direction",void 0),(0,Yo.Z)(this,"timeline",void 0),(0,Yo.Z)(this,"protocol",void 0),(0,Yo.Z)(this,"metadata",void 0),(0,Yo.Z)(this,"source",void 0),(0,Yo.Z)(this,"status",void 0),(0,Yo.Z)(this,"readStatus",void 0),(0,Yo.Z)(this,"writeStatus",void 0),(0,Yo.Z)(this,"sinkController",void 0),(0,Yo.Z)(this,"sinkEnd",void 0),(0,Yo.Z)(this,"endErr",void 0),(0,Yo.Z)(this,"streamSource",void 0),(0,Yo.Z)(this,"onEnd",void 0),(0,Yo.Z)(this,"onCloseRead",void 0),(0,Yo.Z)(this,"onCloseWrite",void 0),(0,Yo.Z)(this,"onReset",void 0),(0,Yo.Z)(this,"onAbort",void 0),(0,Yo.Z)(this,"sendCloseWriteTimeout",void 0),(0,Yo.Z)(this,"log",void 0),this.sinkController=new AbortController,this.sinkEnd=Ws(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=null!==(t=e.metadata)&&void 0!==t?t:{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=null!==(n=e.sendCloseWriteTimeout)&&void 0!==n?n:5e3,this.onEnd=e.onEnd,this.onCloseRead=null===e||void 0===e?void 0:e.onCloseRead,this.onCloseWrite=null===e||void 0===e?void 0:e.onCloseWrite,this.onReset=null===e||void 0===e?void 0:e.onReset,this.onAbort=null===e||void 0===e?void 0:e.onAbort,this.source=this.streamSource=function(){return The((e=>{const t=e.shift();if(null==t)return{done:!0};if(null!=t.error)throw t.error;return{done:!0===t.done,value:t.value}}),arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}({onEnd:e=>{null!=e?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(e){if("ready"!==this.writeStatus)throw new ihe('writable end state is "'.concat(this.writeStatus,'" not "ready"'),"ERR_SINK_INVALID_STATE");try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if("outbound"===this.direction){const e=this.sendNewStream(t);Zhe(e)&&await e}e=PF(e,this.sinkController.signal,{returnOnAbort:!0}),this.log.trace("sink reading from source");for await(let n of e){n=n instanceof Uint8Array?new Zs(n):n;const e=this.sendData(n,t);Zhe(e)&&await e}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),"writing"===this.writeStatus&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){var t;null==this.timeline.closeRead&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),null===(t=this.onCloseRead)||void 0===t||t.call(this),null!=this.timeline.closeWrite?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr)):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){var t;null==this.timeline.closeWrite&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),null===(t=this.onCloseWrite)||void 0===t||t.call(this),null!=this.timeline.closeRead?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr)):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.log.trace("closing gracefully"),this.status="closing",await Promise.all([this.closeRead(e),this.closeWrite(e)]),this.status="closed",this.log.trace("closed gracefully")}async closeRead(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("closing"===this.readStatus||"closed"===this.readStatus)return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing","reset"!==this.status&&"aborted"!==this.status&&null==this.timeline.closeRead&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),"ready"===t&&(this.log.trace("ending internal source queue"),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};"closing"!==this.writeStatus&&"closed"!==this.writeStatus&&(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),"ready"===this.writeStatus&&(this.log.trace("sink was never sunk, sink an empty array"),await Ys(this.sink([]),e.signal)),"writing"===this.writeStatus&&await new Promise(((t,n)=>{queueMicrotask((()=>{this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),Ys(this.sinkEnd.promise,e.signal).then(t,n)}))})),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){var t;if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;this.log("abort with error",e),this.log("try to send reset to remote");const n=this.sendReset();Zhe(n)&&n.catch((e=>{this.log.error("error sending reset message",e)})),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),null===(t=this.onAbort)||void 0===t||t.call(this,e)}reset(){var e;if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;const t=new ihe("stream reset","ERR_STREAM_RESET");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(t),null===(e=this.onReset)||void 0===e||e.call(this)}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){"writing"===this.writeStatus&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){"closing"!==this.readStatus&&"closed"!==this.readStatus&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){"closing"!==this.readStatus&&"closed"!==this.readStatus?(this.log.trace("remote close write"),this._closeSource()):this.log("received remote close write but local source is already closed")}remoteCloseRead(){"closing"!==this.writeStatus&&"closed"!==this.writeStatus?(this.log.trace("remote close read"),this._closeSink()):this.log("received remote close read but local sink is already closed")}destroy(){"closed"!==this.status&&"aborted"!==this.status&&"reset"!==this.status?(this.log.trace("stream destroyed"),this._closeSinkAndSource()):this.log("received destroy but we are already closed")}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}class Vhe extends zhe{constructor(e){super(e),(0,Yo.Z)(this,"name",void 0),(0,Yo.Z)(this,"streamId",void 0),(0,Yo.Z)(this,"send",void 0),(0,Yo.Z)(this,"types",void 0),(0,Yo.Z)(this,"maxDataSize",void 0),this.types="outbound"===e.direction?Rhe:xhe,this.send=e.send,this.name=e.name,this.streamId=e.streamId,this.maxDataSize=e.maxDataSize}async sendNewStream(){await this.send({id:this.streamId,type:Rhe.NEW_STREAM,data:new Zs((0,mu.m)(this.name))})}async sendData(e){for(e=e.sublist();e.byteLength>0;){const t=Math.min(e.byteLength,this.maxDataSize);await this.send({id:this.streamId,type:this.types.MESSAGE,data:e.sublist(0,t)}),e.consume(t)}}async sendReset(){await this.send({id:this.streamId,type:this.types.RESET})}async sendCloseWrite(){await this.send({id:this.streamId,type:this.types.CLOSE})}async sendCloseRead(){}}const Hhe=Ehe("libp2p:mplex");function qhe(e){const t={...e,type:"".concat(khe[e.type]," (").concat(e.type,")")};return e.type===Ahe.NEW_STREAM&&(t.data=(0,ed.BB)(e.data instanceof Uint8Array?e.data:e.data.subarray())),e.type!==Ahe.MESSAGE_INITIATOR&&e.type!==Ahe.MESSAGE_RECEIVER||(t.data=(0,ed.BB)(e.data instanceof Uint8Array?e.data:e.data.subarray(),"base16")),t}class Ghe{constructor(e){var t,n,r;(0,Yo.Z)(this,"protocol","/mplex/6.7.0"),(0,Yo.Z)(this,"sink",void 0),(0,Yo.Z)(this,"source",void 0),(0,Yo.Z)(this,"_streamId",void 0),(0,Yo.Z)(this,"_streams",void 0),(0,Yo.Z)(this,"_init",void 0),(0,Yo.Z)(this,"_source",void 0),(0,Yo.Z)(this,"closeController",void 0),(0,Yo.Z)(this,"rateLimiter",void 0),(0,Yo.Z)(this,"closeTimeout",void 0),e=null!==(t=e)&&void 0!==t?t:{},this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=e,this.closeTimeout=null!==(n=e.closeTimeout)&&void 0!==n?n:500,this.sink=this._createSink(),this._source=function(){return The((e=>{let t;const n=[];for(;!e.isEmpty()&&(t=e.shift(),null!=t);){if(null!=t.error)throw t.error;!1===t.done&&n.push(t.value)}return null==t?{done:!0}:{done:!0===t.done,value:n}}),arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}({objectMode:!0,onEnd:()=>{for(const e of this._streams.initiators.values())e.destroy();for(const e of this._streams.receivers.values())e.destroy()}}),this.source=(0,She.pipe)(this._source,(e=>function(e){try{let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return async function*(){if(null!=t&&0!==t)yield*Uhe(e,{size:t,serialize:(e,t)=>{for(const n of e)jhe.write(n,t)}});else for await(const t of e){const e=new Zs;for(const n of t)jhe.write(n,e);yield e.subarray()}}()}catch(t){return Promise.reject(t)}}(e,this._init.minSendBytes))),this.closeController=new AbortController,this.rateLimiter=new j5.RateLimiterMemory({points:null!==(r=e.disconnectThreshold)&&void 0!==r?r:5,duration:1})}get streams(){const e=[];for(const t of this._streams.initiators.values())e.push(t);for(const t of this._streams.receivers.values())e.push(t);return e}newStream(e){if(this.closeController.signal.aborted)throw new Error("Muxer already closed");const t=this._streamId++;e=null==e?t.toString():e.toString();const n=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:n})}async close(e){var t;if(this.closeController.signal.aborted)return;const n=null!==(t=null===e||void 0===e?void 0:e.signal)&&void 0!==t?t:AbortSignal.timeout(this.closeTimeout);try{await Promise.all(this.streams.map((async e=>e.close({signal:n})))),this._source.end(),await this._source.onEmpty({signal:n}),this.closeController.abort()}catch(r){this.abort(r)}}abort(e){this.closeController.signal.aborted||(this.streams.forEach((t=>{t.abort(e)})),this.closeController.abort(e))}_newReceiverStream(e){const{id:t,name:n}=e,r=this._streams.receivers;return this._newStream({id:t,name:n,type:"receiver",registry:r})}_newStream(e){var t;const{id:n,name:r,type:i,registry:o}=e;if(Hhe("new %s stream %s",i,n),"initiator"===i&&this._streams.initiators.size===(null!==(t=this._init.maxOutboundStreams)&&void 0!==t?t:1024))throw new ihe("Too many outbound streams open","ERR_TOO_MANY_OUTBOUND_STREAMS");if(o.has(n))throw new Error("".concat(i," stream ").concat(n," already exists!"));const s=function(e){const{id:t,name:n,send:r,onEnd:i,type:o="initiator",maxMsgSize:s=Phe}=e;return new Vhe({id:"initiator"===o?"i".concat(t):"r".concat(t),streamId:t,name:"".concat(null==n?t:n),direction:"initiator"===o?"outbound":"inbound",maxDataSize:s,onEnd:i,send:r,log:Ehe("libp2p:mplex:stream:".concat(o,":").concat(t))})}({id:n,name:r,send:async e=>{Hhe.enabled&&Hhe.trace("%s stream %s send",i,n,qhe(e)),this._source.push(e)},type:i,onEnd:()=>{Hhe("%s stream with id %s and protocol %s ended",i,n,s.protocol),o.delete(n),null!=this._init.onStreamEnd&&this._init.onStreamEnd(s)},maxMsgSize:this._init.maxMsgSize});return o.set(n,s),s}_createSink(){return async e=>{try{e=PF(e,this.closeController.signal,{returnOnAbort:!0});const t=new Dhe(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const n of e)for(const e of t.write(n))await this._handleIncoming(e);this._source.end()}catch(t){Hhe("error in sink",t),this._source.end(t)}}}async _handleIncoming(e){var t;const{id:n,type:r}=e;if(Hhe.enabled&&Hhe.trace("incoming message",qhe(e)),e.type===Ahe.NEW_STREAM){var i;if(this._streams.receivers.size===(null!==(i=this._init.maxInboundStreams)&&void 0!==i?i:1024)){Hhe("too many inbound streams open"),this._source.push({id:n,type:Ahe.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{return Hhe("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),void this.abort(new Error("Too many open streams"))}return}const t=this._newReceiverStream({id:n,name:(0,ed.BB)(e.data instanceof Uint8Array?e.data:e.data.subarray())});return void(null!=this._init.onIncomingStream&&this._init.onIncomingStream(t))}const o=(1===(1&r)?this._streams.initiators:this._streams.receivers).get(n);if(null==o){Hhe("missing stream %s for message type %s",n,khe[r]);try{await this.rateLimiter.consume("missing-stream",1)}catch{return Hhe("rate limit hit when receiving messages for streams that do not exist - closing remote connection"),void this.abort(new Error("Too many messages for missing streams"))}return}const s=null!==(t=this._init.maxStreamBufferSize)&&void 0!==t?t:4194304;try{switch(r){case Ahe.MESSAGE_INITIATOR:case Ahe.MESSAGE_RECEIVER:if(o.sourceReadableLength()>s)throw this._source.push({id:e.id,type:r===Ahe.MESSAGE_INITIATOR?Ahe.RESET_RECEIVER:Ahe.RESET_INITIATOR}),new ihe("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers","ERR_STREAM_INPUT_BUFFER_FULL");o.sourcePush(e.data);break;case Ahe.CLOSE_INITIATOR:case Ahe.CLOSE_RECEIVER:o.remoteCloseWrite();break;case Ahe.RESET_INITIATOR:case Ahe.RESET_RECEIVER:o.reset();break;default:Hhe("unknown message type %s",r)}}catch(a){Hhe.error("error while processing message",a),o.abort(a)}}}class Whe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"protocol","/mplex/6.7.0"),(0,Yo.Z)(this,"_init",void 0),this._init=e}createStreamMuxer(){return new Ghe({...arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},...this._init})}}function Qhe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return()=>new Whe(e)}var Yhe;!function(e){e.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",e.ERR_DATA_CHANNEL="ERR_DATA_CHANNEL",e.ERR_CONNECTION_CLOSED="ERR_CONNECTION_CLOSED",e.ERR_HASH_NOT_SUPPORTED="ERR_HASH_NOT_SUPPORTED",e.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",e.ERR_INVALID_FINGERPRINT="ERR_INVALID_FINGERPRINT",e.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",e.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",e.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",e.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"}(Yhe||(Yhe={}));class Jhe extends Pq{constructor(e,t){super("WebRTC transport error: ".concat(e),null!==t&&void 0!==t?t:""),this.name="WebRTCTransportError"}}class Xhe extends Jhe{constructor(e,t){super("[stream: ".concat(e,"] data channel error: ").concat(t),Yhe.ERR_DATA_CHANNEL),this.name="WebRTC/DataChannelError"}}function $he(e,t){return new Xhe(e,t)}class ede extends Jhe{constructor(e){super("There was a problem with the Multiaddr which was passed in: ".concat(e),Yhe.ERR_INVALID_MULTIADDR),this.name="WebRTC/InappropriateMultiaddrError"}}function tde(e){return new ede(e)}class nde extends Jhe{constructor(e){super("There was a problem with a provided argument: ".concat(e),Yhe.ERR_INVALID_PARAMETERS),this.name="WebRTC/InvalidArgumentError"}}function rde(e){return new nde(e)}class ide extends Jhe{constructor(e,t){super('Invalid fingerprint "'.concat(e,'" within ').concat(t),Yhe.ERR_INVALID_FINGERPRINT),this.name="WebRTC/InvalidFingerprintError"}}function ode(e,t){return new ide(e,t)}class sde extends Jhe{constructor(e){super("A method (".concat(e,") was called though it has been intentionally left unimplemented."),Yhe.ERR_NOT_IMPLEMENTED),this.name="WebRTC/UnimplementedError"}}class ade extends Jhe{constructor(e){super("unsupported hash algorithm: ".concat(e),Yhe.ERR_HASH_NOT_SUPPORTED),this.name="WebRTC/UnsupportedHashAlgorithmError"}}const cde=xH("libp2p:webrtc:utils"),lde=iL(),ude=null!=lde&&"firefox"===lde.name,hde=async function*(){},dde=async e=>{},fde=3e4;const pde=xH("libp2p:webrtc:maconn");class gde{constructor(e){(0,Yo.Z)(this,"peerConnection",void 0),(0,Yo.Z)(this,"remoteAddr",void 0),(0,Yo.Z)(this,"timeline",void 0),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,"source",hde()),(0,Yo.Z)(this,"sink",dde),this.remoteAddr=e.remoteAddr,this.timeline=e.timeline,this.peerConnection=e.peerConnection;const t=this.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{pde.trace("peer connection state change",this.peerConnection.connectionState,"initial state",t),"disconnected"!==this.peerConnection.connectionState&&"failed"!==this.peerConnection.connectionState&&"closed"!==this.peerConnection.connectionState||(this.timeline.close=Date.now())}}async close(e){var t;pde.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),null===(t=this.metrics)||void 0===t||t.increment({close:!0})}abort(e){var t;pde.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),null===(t=this.metrics)||void 0===t||t.increment({abort:!0})}}const yde=e=>{const t=e.on||e.addListener||e.addEventListener,n=e.off||e.removeListener||e.removeEventListener;if(!t||!n)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(e),removeListener:n.bind(e)}};function mde(e,t,n){"function"===typeof n&&(n={filter:n});const r=function(e,t,n){let r;const i=new Promise(((i,o)=>{var s;if(!((n={rejectionEvents:["error"],multiArgs:!1,resolveImmediately:!1,...n}).count>=0)||n.count!==Number.POSITIVE_INFINITY&&!Number.isInteger(n.count))throw new TypeError("The `count` option should be at least 0 or more");null===(s=n.signal)||void 0===s||s.throwIfAborted();const a=[t].flat(),c=[],{addListener:l,removeListener:u}=yde(e),h=function(){for(var e=arguments.length,t=new Array(e),o=0;o<e;o++)t[o]=arguments[o];const s=n.multiArgs?t:t[0];n.filter&&!n.filter(s)||(c.push(s),n.count===c.length&&(r(),i(c)))},d=e=>{r(),o(e)};r=()=>{for(const e of a)u(e,h);for(const e of n.rejectionEvents)u(e,d)};for(const e of a)l(e,h);for(const e of n.rejectionEvents)l(e,d);n.signal&&n.signal.addEventListener("abort",(()=>{d(n.signal.reason)}),{once:!0}),n.resolveImmediately&&i(c)}));if(i.cancel=r,"number"===typeof n.timeout){const e=hL(i,{milliseconds:n.timeout});return e.cancel=r,e}return i}(e,t,n={...n,count:1,resolveImmediately:!1}),i=r.then((e=>e[0]));return i.cancel=r.cancel,i}var vde;!function(e){let t,n,r;!function(e){e.FIN="FIN",e.STOP_SENDING="STOP_SENDING",e.RESET="RESET",e.FIN_ACK="FIN_ACK"}(t=e.Flag||(e.Flag={})),function(e){e[e.FIN=0]="FIN",e[e.STOP_SENDING=1]="STOP_SENDING",e[e.RESET=2]="RESET",e[e.FIN_ACK=3]="FIN_ACK"}(n||(n={})),function(e){e.codec=()=>bs(n)}(t=e.Flag||(e.Flag={})),e.codec=()=>(null==r&&(r=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.flag&&(n.uint32(8),e.Flag.codec().encode(t.flag,n)),null!=t.message&&(n.uint32(18),n.bytes(t.message)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.flag=e.Flag.codec().decode(t);break;case 2:r.message=t.bytes();break;default:t.skipType(7&n)}}return r}))),r),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(vde||(vde={}));class bde extends kre{constructor(e){var t,n,r,i;const o=e.onEnd;switch(e.onEnd=e=>{this.log.trace("readable and writeable ends closed",this.status),Promise.resolve((async()=>{if(null==this.timeline.abort&&null===this.timeline.reset)try{await hL(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(e){this.log.error("error receiving FIN_ACK",e)}})).then((()=>{this.incomingData.end(),null===o||void 0===o||o(e)})).catch((e=>{this.log.error("error ending stream",e)}))},super(e),(0,Yo.Z)(this,"channel",void 0),(0,Yo.Z)(this,"incomingData",void 0),(0,Yo.Z)(this,"messageQueue",void 0),(0,Yo.Z)(this,"maxBufferedAmount",void 0),(0,Yo.Z)(this,"bufferedAmountLowEventTimeout",void 0),(0,Yo.Z)(this,"maxMessageSize",void 0),(0,Yo.Z)(this,"receiveFinAck",void 0),(0,Yo.Z)(this,"finAckTimeout",void 0),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=EG(),this.messageQueue=new Zs,this.bufferedAmountLowEventTimeout=null!==(t=e.bufferedAmountLowEventTimeout)&&void 0!==t?t:3e4,this.maxBufferedAmount=null!==(n=e.maxBufferedAmount)&&void 0!==n?n:16777216,this.maxMessageSize=(null!==(r=e.maxMessageSize)&&void 0!==r?r:16384)-5-2,this.receiveFinAck=Ws(),this.finAckTimeout=null!==(i=e.closeTimeout)&&void 0!==i?i:5e3,this.channel.readyState){case"open":case"connecting":break;case"closed":case"closing":void 0!==this.timeline.close&&0!==this.timeline.close||(this.timeline.close=Date.now());break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Pq("Unknown datachannel state","ERR_INVALID_STATE")}this.channel.onopen=e=>{this.timeline.open=(new Date).getTime(),null!=this.messageQueue&&this.messageQueue.byteLength>0&&(this.log.trace("dataChannel opened, sending queued messages",this.messageQueue.byteLength,this.channel.readyState),this._sendMessage(this.messageQueue).catch((e=>{this.log.error("error sending queued messages",e),this.abort(e)}))),this.messageQueue=void 0},this.channel.onclose=e=>{this.receiveFinAck.resolve(),this.close().catch((e=>{this.log.error("error closing stream after channel closed",e)}))},this.channel.onerror=e=>{const t=e.error;this.abort(t)},this.channel.onmessage=async e=>{const{data:t}=e;null!==t&&0!==t.byteLength&&this.incomingData.push(new Uint8Array(t,0,t.byteLength))};const s=this;Promise.resolve().then((async()=>{for await(const e of yG(this.incomingData)){const t=s.processIncomingProtobuf(e);null!=t&&s.sourcePush(new Zs(t))}})).catch((e=>{this.log.error("error processing incoming data channel messages",e)}))}sendNewStream(){}async _sendMessage(e){if((!(arguments.length>1&&void 0!==arguments[1])||arguments[1])&&this.channel.bufferedAmount>this.maxBufferedAmount)try{await mde(this.channel,"bufferedamountlow",{timeout:this.bufferedAmountLowEventTimeout})}catch(t){if(t instanceof aL)throw new Pq("Timed out waiting for DataChannel buffer to clear after ".concat(this.bufferedAmountLowEventTimeout,"ms"),"ERR_BUFFER_CLEAR_TIMEOUT");throw t}if("closed"===this.channel.readyState||"closing"===this.channel.readyState)throw new Pq("Invalid datachannel state - ".concat(this.channel.readyState),"ERR_INVALID_STATE");if("open"===this.channel.readyState)for(const n of e)this.channel.send(n);else{if("connecting"!==this.channel.readyState)throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Pq("Unknown datachannel state","ERR_INVALID_STATE");null==this.messageQueue&&(this.messageQueue=new Zs),this.messageQueue.append(e)}}async sendData(e){for(e=e.sublist();e.byteLength>0;){const t=Math.min(e.byteLength,this.maxMessageSize),n=e.subarray(0,t),r=vde.encode({message:n}),i=fG.single(r);await this._sendMessage(i),e.consume(t)}}async sendReset(){await this._sendFlag(vde.Flag.RESET)}async sendCloseWrite(e){if(await this._sendFlag(vde.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await Ys(this.receiveFinAck.promise,null===e||void 0===e?void 0:e.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorCode:"ERR_FIN_ACK_NOT_RECEIVED"})}catch(t){this.log.error("failed to await FIN_ACK",t)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){await this._sendFlag(vde.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=vde.decode(e);if(void 0!==t.flag&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===vde.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(vde.Flag.FIN_ACK).catch((e=>{this.log.error("error sending FIN_ACK immediately",e)}))),t.flag===vde.Flag.RESET&&this.reset(),t.flag===vde.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===vde.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),"ready"===this.readStatus)return t.message}async _sendFlag(e){if("open"!==this.channel.readyState)return this.log.trace("not sending flag %s because channel is not open",e.toString()),!1;this.log.trace("sending flag %s",e.toString());const t=vde.encode({flag:e}),n=fG.single(t);try{return await this._sendMessage(n,!1),!0}catch(r){this.log.error("could not send flag %s",e.toString(),r)}return!1}}function wde(e){const{channel:t,direction:n}=e;return new bde({id:"inbound"===n?"i".concat(t.id):"r".concat(t.id),log:xH("libp2p:webrtc:stream:".concat(n,":").concat(t.id)),...e})}const Ede=xH("libp2p:webrtc:muxer"),Ade="/webrtc";class Sde{constructor(e){var t,n;(0,Yo.Z)(this,"protocol",void 0),(0,Yo.Z)(this,"peerConnection",void 0),(0,Yo.Z)(this,"bufferedStreams",[]),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,"dataChannelOptions",void 0),this.peerConnection=e.peerConnection,this.metrics=e.metrics,this.protocol=null!==(t=e.protocol)&&void 0!==t?t:Ade,this.dataChannelOptions=null!==(n=e.dataChannelOptions)&&void 0!==n?n:{},this.peerConnection.ondatachannel=e=>{let{channel:t}=e;const n={},r=wde({channel:t,direction:"inbound",onEnd:e=>{n.onEnd(e)},...this.dataChannelOptions});n.stream=r,n.channel=t,n.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter((e=>e.stream.id!==r.id))},this.bufferedStreams.push(n)}}createStreamMuxer(e){return new Ide({...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}var _de=new WeakSet;class Ide{constructor(e){var t,n;Jd(this,_de),(0,Yo.Z)(this,"init",void 0),(0,Yo.Z)(this,"streams",void 0),(0,Yo.Z)(this,"protocol",void 0),(0,Yo.Z)(this,"peerConnection",void 0),(0,Yo.Z)(this,"dataChannelOptions",void 0),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,"source",hde()),(0,Yo.Z)(this,"sink",dde),this.init=e,this.streams=e.streams.map((e=>e.stream)),this.peerConnection=e.peerConnection,this.protocol=null!==(t=e.protocol)&&void 0!==t?t:Ade,this.metrics=e.metrics,this.dataChannelOptions=null!==(n=e.dataChannelOptions)&&void 0!==n?n:{},this.peerConnection.ondatachannel=t=>{var n,r;let{channel:i}=t;const o=wde({channel:i,direction:"inbound",onEnd:()=>{Xd(this,_de,Cde).call(this,o,i)},...this.dataChannelOptions});this.streams.push(o),null===(n=this.metrics)||void 0===n||n.increment({incoming_stream:!0}),null===e||void 0===e||null===(r=e.onIncomingStream)||void 0===r||r.call(e,o)},this.init.streams.length>0&&queueMicrotask((()=>{this.init.streams.forEach((e=>{var t,n,r;e.onEnd=()=>{Xd(this,_de,Cde).call(this,e.stream,e.channel)},null===(t=this.metrics)||void 0===t||t.increment({incoming_stream:!0}),null===(n=this.init)||void 0===n||null===(r=n.onIncomingStream)||void 0===r||r.call(n,e.stream)}))}))}async close(e){try{await Promise.all(this.streams.map((async t=>t.close(e))))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}newStream(){var e;const t=this.peerConnection.createDataChannel(""),n=wde({channel:t,direction:"outbound",onEnd:()=>{Xd(this,_de,Cde).call(this,n,t)},...this.dataChannelOptions});return this.streams.push(n),null===(e=this.metrics)||void 0===e||e.increment({outgoing_stream:!0}),n}}function Cde(e,t){var n,r,i;Ede.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:fde;"open"===e.readyState&&Promise.resolve().then((async()=>{if(e.bufferedAmount>0){cde("%s drain channel with %d buffered bytes",t,e.bufferedAmount);const r=Ws();let i=!1;e.bufferedAmountLowThreshold=0;const o=()=>{i||(cde("%s drain channel closed before drain",t),r.resolve())};e.addEventListener("close",o,{once:!0}),e.addEventListener("bufferedamountlow",(()=>{i=!0,e.removeEventListener("close",o),r.resolve()})),await hL(r.promise,{milliseconds:n})}})).then((async()=>{"open"===e.readyState&&e.close()})).catch((e=>{cde.error("error closing outbound stream",e)}))}(t,"".concat(e.direction," ").concat(e.id," ").concat(e.protocol),this.dataChannelOptions.drainTimeout),this.streams=this.streams.filter((t=>t.id!==e.id)),null===(n=this.metrics)||void 0===n||n.increment({stream_end:!0}),null===(r=this.init)||void 0===r||null===(i=r.onStreamEnd)||void 0===i||i.call(r,e)}const Tde=globalThis.RTCPeerConnection,kde=globalThis.RTCSessionDescription,Rde=globalThis.RTCIceCandidate;var xde;!function(e){let t,n,r;!function(e){e.SDP_OFFER="SDP_OFFER",e.SDP_ANSWER="SDP_ANSWER",e.ICE_CANDIDATE="ICE_CANDIDATE"}(t=e.Type||(e.Type={})),function(e){e[e.SDP_OFFER=0]="SDP_OFFER",e[e.SDP_ANSWER=1]="SDP_ANSWER",e[e.ICE_CANDIDATE=2]="ICE_CANDIDATE"}(n||(n={})),function(e){e.codec=()=>bs(n)}(t=e.Type||(e.Type={})),e.codec=()=>(null==r&&(r=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.type&&(n.uint32(8),e.Type.codec().encode(t.type,n)),null!=t.data&&(n.uint32(18),n.string(t.data)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.type=e.Type.codec().decode(t);break;case 2:r.data=t.string();break;default:t.skipType(7&n)}}return r}))),r),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(xde||(xde={}));const Pde=xH("libp2p:webrtc:peer:util"),Dde=async(e,t,n,r)=>{var i;const o=new AbortController;e.promise.then((()=>{o.abort()}),(()=>{o.abort()}));const s=GH([o.signal,r.signal]),a=PF(n.unwrap().unwrap().source,s,{returnOnAbort:!0});try{for await(const e of yG(a)){var c;const n=xde.decode(e);if(n.type!==xde.Type.ICE_CANDIDATE)throw new Pq("ICE candidate message expected","ERR_NOT_ICE_CANDIDATE");let i=JSON.parse(null!==(c=n.data)&&void 0!==c?c:"null");""===i&&(Pde.trace("end-of-candidates for this generation received"),i={candidate:"",sdpMid:"0",sdpMLineIndex:0}),null===i&&(Pde.trace("end-of-candidates received"),i={candidate:null,sdpMid:"0",sdpMLineIndex:0});const o=new Rde(i);Pde.trace("%s received new ICE candidate",r.direction,o);try{await t.addIceCandidate(o)}catch(l){Pde.error("%s bad candidate received",r.direction,l)}}}catch(l){Pde.error("%s error parsing ICE candidate",r.direction,l)}finally{s.clear()}if(!0===(null===(i=r.signal)||void 0===i?void 0:i.aborted))throw new Qs("Aborted while reading ICE candidates","ERR_ICE_CANDIDATES_READ_ABORTED");await Ys(e.promise,r.signal,{errorMessage:"Aborted before connected",errorCode:"ERR_ABORTED_BEFORE_CONNECTED"})};function Ode(e,t){e[ude?"oniceconnectionstatechange":"onconnectionstatechange"]=n=>{switch(Pde.trace("receiver peerConnectionState state change: %s",e.connectionState),ude?e.iceConnectionState:e.connectionState){case"connected":t.resolve();break;case"failed":case"disconnected":case"closed":t.reject(new Pq("RTCPeerConnection was closed","ERR_CONNECTION_CLOSED_BEFORE_CONNECTED"))}}}const Nde=xH("libp2p:webrtc:initiate-connection");async function Bde(e){let{peerConnection:t,signal:n,metrics:r,multiaddr:i,connectionManager:o,transportManager:s}=e;const{baseAddr:a}=function(e){const t=e.toString().split(Kde+"/");if(2!==t.length)throw new Pq("webrtc protocol was not present in multiaddr",Yhe.ERR_INVALID_MULTIADDR);if(!t[0].includes(jde))throw new Pq("p2p-circuit protocol was not present in multiaddr",Yhe.ERR_INVALID_MULTIADDR);let n=(0,og.HM)(t[0]);const r=(0,og.HM)("/"+t[1]).getPeerId();if(null==r)throw new Pq("destination peer id was missing",Yhe.ERR_INVALID_MULTIADDR);const i=n.protos().pop();if(void 0===i)throw new Pq("invalid multiaddr",Yhe.ERR_INVALID_MULTIADDR);"p2p"!==i.name&&(n=n.encapsulate("/p2p/".concat(r)));return{baseAddr:n,peerId:R1(r)}}(i);null===r||void 0===r||r.dialerEvents.increment({open:!0}),Nde.trace("dialing base address: %a",a);const c=a.getPeerId();if(null==c)throw new Pq("Relay peer was missing","ERR_INVALID_ADDRESS");const l=o.getConnections(R1(c));let u,h=!1;0===l.length?(u=await s.dial(a,{signal:n}),h=!0):u=l[0];try{const e=await u.newStream(Zde,{signal:n,runOnTransientConnection:!0}),r=hk(e).pb(xde),o=Ws(),s=()=>{o.reject(new Pq("SDP handshake aborted","ERR_SDP_HANDSHAKE_ABORTED"))};try{Ode(t,o),null===n||void 0===n||n.addEventListener("abort",s);const e=t.createDataChannel("init");t.onicecandidate=e=>{var t;let{candidate:i}=e;const o=JSON.stringify(null!==(t=null===i||void 0===i?void 0:i.toJSON())&&void 0!==t?t:null);Nde.trace("initiator sending ICE candidate %s",o),r.write({type:xde.Type.ICE_CANDIDATE,data:o},{signal:n}).catch((e=>{Nde.error("error sending ICE candidate",e)}))},t.onicecandidateerror=e=>{Nde("initiator ICE candidate error",e)};const a=await t.createOffer();Nde.trace("initiator send SDP offer %s",a.sdp),await r.write({type:xde.Type.SDP_OFFER,data:a.sdp},{signal:n}),await t.setLocalDescription(a).catch((e=>{throw Nde.error("could not execute setLocalDescription",e),new Pq("Failed to set localDescription","ERR_SDP_HANDSHAKE_FAILED")}));const c=await r.read({signal:n});if(c.type!==xde.Type.SDP_ANSWER)throw new Pq("remote should send an SDP answer","ERR_SDP_HANDSHAKE_FAILED");Nde.trace("initiator receive SDP answer %s",c.data);const l=new kde({type:"answer",sdp:c.data});return await t.setRemoteDescription(l).catch((e=>{throw Nde.error("could not execute setRemoteDescription",e),new Pq("Failed to set remoteDescription","ERR_SDP_HANDSHAKE_FAILED")})),Nde.trace("initiator read candidates until connected"),await Dde(o,t,r,{direction:"initiator",signal:n}),Nde.trace("initiator connected, closing init channel"),e.close(),Nde.trace("initiator closing signalling stream"),await r.unwrap().unwrap().close({signal:n}),Nde.trace("initiator connected to remote address %s",i),{remoteAddress:i}}catch(d){throw t.close(),e.abort(d),d}finally{null===n||void 0===n||n.removeEventListener("abort",s),t.onicecandidate=null,t.onicecandidateerror=null}}finally{if(h)try{await u.close({signal:n})}catch(d){u.abort(d)}}}class Lde extends MJ{constructor(e,t){super(),(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"transportManager",void 0),(0,Yo.Z)(this,"shutdownController",void 0),this.peerId=e.peerId,this.transportManager=e.transportManager,this.shutdownController=t.shutdownController}async listen(){this.safeDispatchEvent("listening",{})}getAddrs(){return this.transportManager.getListeners().filter((e=>e!==this)).map((e=>e.getAddrs().filter((e=>aP.matches(e))).map((e=>e.encapsulate("/webrtc/p2p/".concat(this.peerId)))))).flat()}async close(){this.shutdownController.abort(),this.safeDispatchEvent("close",{})}}const Mde=xH("libp2p:webrtc:signaling-stream-handler");let Ude;const Fde=xH("libp2p:webrtc:peer"),Kde="/webrtc",jde="/p2p-circuit",Zde="/webrtc-signaling/0.0.1";Ude=Symbol.toStringTag;class zde{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"init",void 0),(0,Yo.Z)(this,"_started",!1),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,"shutdownController",void 0),(0,Yo.Z)(this,Ude,"@libp2p/webrtc"),(0,Yo.Z)(this,_5,!0),this.components=e,this.init=t,this.shutdownController=new AbortController,null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(Zde,(e=>{this._onProtocol(e).catch((t=>{Fde.error("failed to handle incoming connect from %p",e.connection.remotePeer,t)}))}),{runOnTransientConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(Zde),this._started=!1}createListener(e){return new Lde(this.components,{shutdownController:this.shutdownController})}filter(e){return e.filter(gO.uF.exactMatch)}async dial(e,t){var n;Fde.trace("dialing address: %a",e);const r=new Tde(this.init.rtcConfiguration),i=new Sde({peerConnection:r,dataChannelOptions:this.init.dataChannel}),{remoteAddress:o}=await Bde({peerConnection:r,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager}),s=new gde({peerConnection:r,timeline:{open:Date.now()},remoteAddr:o,metrics:null===(n=this.metrics)||void 0===n?void 0:n.dialerEvents}),a=await t.upgrader.upgradeOutbound(s,{skipProtection:!0,skipEncryption:!0,muxerFactory:i});return this._closeOnShutdown(r,s),a}async _onProtocol(e){var t;let{connection:n,stream:r}=e;const i=AbortSignal.timeout(null!==(t=this.init.inboundConnectionTimeout)&&void 0!==t?t:3e4),o=new Tde(this.init.rtcConfiguration),s=new Sde({peerConnection:o,dataChannelOptions:this.init.dataChannel});try{var a;const{remoteAddress:e}=await async function(e){let{peerConnection:t,stream:n,signal:r,connection:i}=e;Mde.trace("new inbound signaling stream");const o=hk(n).pb(xde);try{const e=Ws(),n=Ws();r.onabort=()=>{e.reject(new Pq("Timed out while trying to connect","ERR_TIMEOUT"))},t.onicecandidate=t=>{let{candidate:i}=t;n.promise.then((async()=>{var e;const t=JSON.stringify(null!==(e=null===i||void 0===i?void 0:i.toJSON())&&void 0!==e?e:null);Mde.trace("recipient sending ICE candidate %s",t),await o.write({type:xde.Type.ICE_CANDIDATE,data:t},{signal:r})}),(t=>{Mde.error("cannot set candidate since sending answer failed",t),e.reject(t)}))},Ode(t,e);const i=await o.read({signal:r});var s;if(i.type!==xde.Type.SDP_OFFER)throw new Pq("expected message type SDP_OFFER, received: ".concat(null!==(s=i.type)&&void 0!==s?s:"undefined"," "),"ERR_SDP_HANDSHAKE_FAILED");Mde.trace("recipient receive SDP offer %s",i.data);const a=new kde({type:"offer",sdp:i.data});await t.setRemoteDescription(a).catch((e=>{throw Mde.error("could not execute setRemoteDescription",e),new Pq("Failed to set remoteDescription","ERR_SDP_HANDSHAKE_FAILED")}));const c=await t.createAnswer().catch((e=>{throw Mde.error("could not execute createAnswer",e),n.reject(e),new Pq("Failed to create answer","ERR_SDP_HANDSHAKE_FAILED")}));Mde.trace("recipient send SDP answer %s",c.sdp),await o.write({type:xde.Type.SDP_ANSWER,data:c.sdp},{signal:r}),await t.setLocalDescription(c).catch((e=>{throw Mde.error("could not execute setLocalDescription",e),n.reject(e),new Pq("Failed to set localDescription","ERR_SDP_HANDSHAKE_FAILED")})),n.resolve(),Mde.trace("recipient read candidates until connected"),await Dde(e,t,o,{direction:"recipient",signal:r}),Mde.trace("recipient connected, closing signaling stream"),await o.unwrap().unwrap().close({signal:r})}catch(c){if("connected"!==t.connectionState)throw Mde.error("error while handling signaling stream from peer %a",i.remoteAddr,c),t.close(),c;Mde("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",i.remoteAddr,c)}const a=(0,og.HM)("/webrtc/p2p/".concat(i.remoteAddr.getPeerId()));return Mde.trace("recipient connected to remote address %s",a),{remoteAddress:a}}({peerConnection:o,connection:n,stream:r,signal:i}),t=new gde({peerConnection:o,timeline:{open:(new Date).getTime()},remoteAddr:e,metrics:null===(a=this.metrics)||void 0===a?void 0:a.listenerEvents});this._closeOnShutdown(o,t),await this.components.upgrader.upgradeInbound(t,{skipEncryption:!0,skipProtection:!0,muxerFactory:s}),await r.close({signal:i})}catch(c){throw r.abort(c),c}}_closeOnShutdown(e,t){const n=()=>{t.close().catch((e=>{Fde.error("could not close WebRTCMultiaddrConnection",e)}))};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",(()=>{this.shutdownController.signal.removeEventListener("abort",n)}))}}const Vde=xH("libp2p:webrtc:sdp"),Hde=Object.values(v1).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)));function qde(e){var t;const n=null===(t=e.getConfiguration().certificates)||void 0===t?void 0:t.at(0);if(null==n||null==n.getFingerprints){Vde.trace("fetching fingerprint from local SDP");const t=e.localDescription;if(null==t)return;return function(e){var t;const n=e.match(Gde);return null===n||void 0===n||null===(t=n.groups)||void 0===t?void 0:t.fingerprint}(t.sdp)}if(Vde.trace("fetching fingerprint from local certificate"),0===n.getFingerprints().length)return;const r=n.getFingerprints()[0].value;if(null==r)throw ode("","no fingerprint on local certificate");return r}const Gde=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function Wde(e){const t=e.stringTuples().filter((e=>e[0]===tfe)).map((e=>e[1]))[0];if(void 0===t||""===t)throw tde("Couldn't find a certhash component of multiaddr: ".concat(e.toString()));return t}function Qde(e){const t=Hde.decode(e);return KU.decode(t)}function Yde(e){switch(e){case"sha1":return"sha-1";case"sha2-256":return"sha-256";case"sha2-512":return"sha-512";default:throw new ade(e)}}function Jde(e,t){const{host:n,port:r}=e.toOptions(),i=function(e){for(const t of e.protoNames())if(t.startsWith("ip"))return t.toUpperCase();return Vde("Warning: multiaddr does not appear to contain IP4 or IP6, defaulting to IP6",e),"IP6"}(e),[o]=function(e){const t=Qde(Wde(e)),n=Yde(t.name),r=t.digest.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),""),i=r.match(/.{1,2}/g);if(null==i)throw ode(r,e.toString());return["".concat(n.toUpperCase()," ").concat(i.join(":").toUpperCase()),r]}(e);return"v=0\no=- 0 0 IN ".concat(i," ").concat(n,"\ns=-\nc=IN ").concat(i," ").concat(n,"\nt=0 0\na=ice-lite\nm=application ").concat(r," UDP/DTLS/SCTP webrtc-datachannel\na=mid:0\na=setup:passive\na=ice-ufrag:").concat(t,"\na=ice-pwd:").concat(t,"\na=fingerprint:").concat(o,"\na=sctp-port:5000\na=max-message-size:16384\na=candidate:1467250027 1 UDP 1467250027 ").concat(n," ").concat(r," typ host\r\n")}const Xde=Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");let $de;const efe=xH("libp2p:webrtc:transport"),tfe=((0,og.a_)("webrtc-direct").code,(0,og.a_)("certhash").code);$de=Symbol.toStringTag;class nfe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"init",void 0),(0,Yo.Z)(this,$de,"@libp2p/webrtc-direct"),(0,Yo.Z)(this,_5,!0),this.components=e,this.init=t,null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total",{label:"event",help:"Total count of WebRTC-direct dial events by type"})})}async dial(e,t){const n=await this._connect(e,t);return efe("dialing address: %a",e),n}createListener(e){throw new sde("WebRTCTransport.createListener")}filter(e){return e.filter(gO.Ih.exactMatch)}async _connect(e,t){const n=new AbortController,r=n.signal,i=e.getPeerId();if(null===i)throw tde("we need to have the remote's PeerId");const o=R1(i),s=Qde(Wde(e)),a=await Tde.generateCertificate({name:"ECDSA",namedCurve:"P-256",hash:Yde(s.name)}),c=new Tde({certificates:[a]});try{var l,u,h,d;const i=new Promise(((e,t)=>{const n=c.createDataChannel("",{negotiated:!0,id:0}),r=setTimeout((()=>{var e;const r="Data channel was never opened: state: ".concat(n.readyState);efe.error(r),null===(e=this.metrics)||void 0===e||e.dialerEvents.increment({open_error:!0}),t($he("data",r))}),1e4);n.onopen=t=>{clearTimeout(r),e(n)},n.onerror=e=>{var n,i,o;clearTimeout(r);const s=null!==(n=null===(i=e.target)||void 0===i?void 0:i.toString())&&void 0!==n?n:"not specified",a="Error opening a data channel for handshaking: ".concat(s);efe.error(a),null===(o=this.metrics)||void 0===o||o.dialerEvents.increment({unknown_error:!0}),t($he("data",a))}})),a="libp2p+webrtc+v1/"+[...Array(32)].map((()=>Xde.at(Math.floor(Math.random()*Xde.length)))).join(""),f=function(e,t){if(void 0===e.sdp)throw rde("Can't munge a missing SDP");return e.sdp=e.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,"\na=ice-ufrag:"+t+"\n").replace(/\na=ice-pwd:[^\n]*\n/,"\na=ice-pwd:"+t+"\n"),e}(await c.createOffer(),a);await c.setLocalDescription(f);const p=function(e,t){return{type:"answer",sdp:Jde(e,t)}}(e,a);await c.setRemoteDescription(p);const g=await i,y=this.components.peerId,m=are({prologueBytes:this.generateNoisePrologue(c,s.code,e)})(),v=wde({channel:g,direction:"inbound",...null!==(l=this.init.dataChannel)&&void 0!==l?l:{}}),b={...v,sink:v.sink.bind(v),source:async function*(){for await(const e of v.source)for(const t of e)yield t}()},w=new gde({peerConnection:c,remoteAddr:e,timeline:{open:Date.now()},metrics:null===(u=this.metrics)||void 0===u?void 0:u.dialerEvents}),E=ude?"iceconnectionstatechange":"connectionstatechange";c.addEventListener(E,(()=>{switch(c.connectionState){case"failed":case"disconnected":case"closed":w.close().catch((e=>{efe.error("error closing connection",e)})).finally((()=>{n.abort()}))}}),{signal:r}),null===(h=this.metrics)||void 0===h||h.dialerEvents.increment({peer_connection:!0});const A=new Sde({peerConnection:c,metrics:null===(d=this.metrics)||void 0===d?void 0:d.dialerEvents,dataChannelOptions:this.init.dataChannel});return await m.secureInbound(y,b,o),await t.upgrader.upgradeOutbound(w,{skipProtection:!0,skipEncryption:!0,muxerFactory:A})}catch(f){throw c.close(),f}}generateNoisePrologue(e,t,n){var r;if(0===(null===(r=e.getConfiguration().certificates)||void 0===r?void 0:r.length))throw rde("no local certificate");const i=qde(e);if(null==i)throw rde("no local fingerprint found");const o=i.trim().toLowerCase().replaceAll(":",""),s=(0,mu.m)(o,"hex"),a=KU.encode(s,t),c=Hde.decode(Wde(n)),l=(0,mu.m)("libp2p-webrtc-noise:");return(0,Ls.z)([l,a,c])}}function rfe(e){return t=>new nfe(t,e)}const ife=xH("libp2p:webtransport:stream");async function ofe(e,t,n,r,i){const o=e.writable.getWriter(),s=e.readable.getReader();function a(){const e=r.findIndex((e=>e===h));-1!==e&&(r.splice(e,1),h.timeline.close=Date.now(),null===i||void 0===i||i(h))}await o.ready;let c=!1,l=!1;(async function(){const e=await o.closed.catch((e=>e));if(null!=e){const n=e.message;n.includes("aborted by the remote server")||n.includes("STOP_SENDING")||ife.error("WebTransport writer closed unexpectedly: streamId=".concat(t," err=").concat(e.message))}c=!0,c&&l&&a()})().catch((()=>{ife.error("WebTransport failed to cleanup closed stream")})),async function(){const e=await s.closed.catch((e=>e));null!=e&&ife.error("WebTransport reader closed unexpectedly: streamId=".concat(t," err=").concat(e.message)),l=!0,c&&l&&a()}().catch((()=>{ife.error("WebTransport failed to cleanup closed stream")}));let u=!1;const h={id:t,status:"open",writeStatus:"ready",readStatus:"ready",abort(e){c||(o.abort(e).catch((e=>{ife.error("could not abort stream",e)})),c=!0),l=!0,this.status="aborted",this.writeStatus="closed",this.readStatus="closed",this.timeline.reset=this.timeline.close=this.timeline.closeRead=this.timeline.closeWrite=Date.now(),a()},async close(e){this.status="closing",await Promise.all([h.closeRead(e),h.closeWrite(e)]),a(),this.status="closed",this.timeline.close=Date.now()},async closeRead(e){if(!l){this.readStatus="closing";try{await s.cancel()}catch(t){!0===t.toString().includes("RESET_STREAM")&&(c=!0)}this.timeline.closeRead=Date.now(),this.readStatus="closed",l=!0}c&&a()},async closeWrite(e){if(!c){c=!0,this.writeStatus="closing";try{await o.close()}catch(t){!0===t.toString().includes("RESET_STREAM")&&(l=!0)}this.timeline.closeWrite=Date.now(),this.writeStatus="closed"}l&&a()},direction:n,timeline:{open:Date.now()},metadata:{},source:async function*(){for(;;){const e=await s.read();if(e.done)return l=!0,void(c&&a());yield new Zs(e.value)}}(),sink:async function(e){if(u)throw new Error("sink already called on stream");u=!0;try{this.writeStatus="writing";for await(const t of e)if(t instanceof Uint8Array)await o.write(t);else for(const e of t)await o.write(e);this.writeStatus="done"}finally{this.timeline.closeWrite=Date.now(),this.writeStatus="closed",await h.closeWrite()}}};return h}function sfe(){return{source:{[Symbol.asyncIterator]:()=>({next:async()=>new Promise((()=>{}))})},sink:async e=>new Promise((()=>{}))}}const afe=Object.values(v1).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)));function cfe(e){var t;if(!gO.Mk.matches(e))throw new Pq("Invalid multiaddr, was not a WebTransport address","ERR_INVALID_MULTIADDR");const n=e.stringTuples(),r=n.filter((e=>{let[t,n]=e;return t===(0,og.a_)("certhash").code})).map((e=>{let[t,n]=e;return r=null!==n&&void 0!==n?n:"",gq(afe.decode(r));var r})),i=n.filter((e=>{let[t,n]=e;return t===(0,og.a_)("p2p").code})).map((e=>{let[t,n]=e;return R1(null!==n&&void 0!==n?n:"")}))[0],o=e.toOptions();let s=o.host;return 6===o.family&&null!==(t=s)&&void 0!==t&&t.includes(":")&&(s="[".concat(s,"]")),{url:"https://".concat(s,":").concat(o.port),certhashes:r,remotePeer:i}}let lfe;const ufe=xH("libp2p:webtransport");lfe=Symbol.toStringTag;class hfe{constructor(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"config",void 0),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,lfe,"@libp2p/webtransport"),(0,Yo.Z)(this,_5,!0),this.components=e,this.config={maxInboundStreams:null!==(t=n.maxInboundStreams)&&void 0!==t?t:1e3},null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webtransport_dialer_events_total",{label:"event",help:"Total count of WebTransport dialer events by type"})})}async dial(e,t){var n,r,i;null===(n=t)||void 0===n||null===(r=n.signal)||void 0===r||r.throwIfAborted(),ufe("dialing %s",e);const o=this.components.peerId;if(void 0===o)throw new Error("Need a local peerid");t=null!==(i=t)&&void 0!==i?i:{};const{url:s,certhashes:a,remotePeer:c}=cfe(e);if(null==c)throw new Error("Need a target peerid");if(0===a.length)throw new Error("Expected multiaddr to contain certhashes");let l,u,h=()=>{},d=!1,f=!1,p=!1;try{var g,y,m,v;null===(g=this.metrics)||void 0===g||g.dialerEvents.increment({pending:!0});const n=new WebTransport("".concat(s,"/.well-known/libp2p-webtransport?type=noise"),{serverCertificateHashes:a.map((e=>({algorithm:"sha-256",value:e.digest})))});if(h=e=>{if(!d)try{var t;null===(t=this.metrics)||void 0===t||t.dialerEvents.increment({[e]:!0}),n.close()}catch(r){ufe.error("error closing wt session",r)}finally{null!=u&&(u.timeline.close=Date.now()),d=!0}},l=()=>{h(f?"noise_timeout":"ready_timeout")},null===(y=t.signal)||void 0===y||y.addEventListener("abort",l,{once:!0}),await Promise.race([n.closed,n.ready]),f=!0,null===(m=this.metrics)||void 0===m||m.dialerEvents.increment({ready:!0}),n.closed.catch((e=>{ufe.error("error on remote wt session close",e)})).finally((()=>{h("remote_close")})),!await this.authenticateWebTransport(n,o,c,a))throw new Error("Failed to authenticate webtransport");return null===(v=this.metrics)||void 0===v||v.dialerEvents.increment({open:!0}),u={close:async()=>{ufe("Closing webtransport"),h("close")},abort:e=>{ufe("aborting webtransport due to passed err",e),h("abort")},remoteAddr:e,timeline:{open:Date.now()},...sfe()},p=!0,await t.upgrader.upgradeOutbound(u,{skipEncryption:!0,muxerFactory:this.webtransportMuxer(n),skipProtection:!0})}catch(w){throw ufe.error("caught wt session err",w),h(p?"upgrade_error":f?"noise_error":"ready_error"),w}finally{var b;if(null!=l)null===(b=t.signal)||void 0===b||b.removeEventListener("abort",l)}}async authenticateWebTransport(e,t,n,r){var i;const o=await e.createBidirectionalStream(),s=o.writable.getWriter(),a=o.readable.getReader();await s.ready;const c={source:async function*(){for(;;){const e=await a.read();if(null!=e.value&&(yield e.value),e.done)break}}(),sink:async function(e){for await(const t of e)await s.write(t)}},l=are()(),{remoteExtensions:u}=await l.secureOutbound(t,c,n);if(s.close().catch((e=>{ufe.error("Failed to close authentication stream writer: ".concat(e.message))})),a.cancel().catch((e=>{ufe.error("Failed to close authentication stream reader: ".concat(e.message))})),h=null!==(i=null===u||void 0===u?void 0:u.webtransportCerthashes)&&void 0!==i?i:[],(d=r.map((e=>e.bytes))).filter((e=>Boolean(h.find((t=>(0,Ms.f)(e,t)))))).length!==d.length)throw new Error("Our certhashes are not a subset of the remote's reported certhashes");var h,d;return!0}webtransportMuxer(e){let t=0;const n=this.config;return{protocol:"webtransport",createStreamMuxer:r=>{"function"===typeof r&&(r={onIncomingStream:r});const i=[];(async function(){const o=e.incomingBidirectionalStreams.getReader();for(;;){const{done:e,value:u}=await o.read();if(e)break;if(i.length>=n.maxInboundStreams)u.writable.close().catch((e=>{ufe.error("Failed to close inbound stream that crossed our maxInboundStream limit: ".concat(e.message))})),u.readable.cancel().catch((e=>{ufe.error("Failed to close inbound stream that crossed our maxInboundStream limit: ".concat(e.message))}));else{var s,a,c,l;const e=await ofe(u,String(t++),"inbound",i,null===(s=r)||void 0===s?void 0:s.onStreamEnd);i.push(e),null===(a=r)||void 0===a||null===(c=(l=a).onIncomingStream)||void 0===c||c.call(l,e)}}})().catch((()=>{ufe.error("WebTransport failed to receive incoming stream")}));return{protocol:"webtransport",streams:i,newStream:async n=>{var o,s,a;const c=await e.createBidirectionalStream(),l=await ofe(c,String(t++),null!==(o=null===(s=r)||void 0===s?void 0:s.direction)&&void 0!==o?o:"outbound",i,null===(a=r)||void 0===a?void 0:a.onStreamEnd);return i.push(l),l},close:async e=>{ufe("Closing webtransport muxer"),await Promise.all(i.map((async t=>t.close(e))))},abort:e=>{ufe("Aborting webtransport muxer with err:",e);for(const t of i)t.abort(e)},...sfe()}}}}createListener(e){throw new Error("Webtransport servers are not supported in Node or the browser")}filter(e){return e.filter(gO.Mk.exactMatch)}}function dfe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new hfe(t,e)}const ffe="ERR_UNRECOGNIZED_VALIDITY",pfe="ERR_SIGNATURE_VERIFICATION",gfe="ERR_UNRECOGNIZED_FORMAT",yfe="ERR_UNDEFINED_PARAMETER",mfe="ERR_RECORD_TOO_LARGE";var vfe;!function(e){let t,n,r;!function(e){e.EOL="EOL"}(t=e.ValidityType||(e.ValidityType={})),function(e){e[e.EOL=0]="EOL"}(n||(n={})),function(e){e.codec=()=>bs(n)}(t=e.ValidityType||(e.ValidityType={})),e.codec=()=>(null==r&&(r=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.value&&(n.uint32(10),n.bytes(t.value)),null!=t.signatureV1&&(n.uint32(18),n.bytes(t.signatureV1)),null!=t.validityType&&(n.uint32(24),e.ValidityType.codec().encode(t.validityType,n)),null!=t.validity&&(n.uint32(34),n.bytes(t.validity)),null!=t.sequence&&(n.uint32(40),n.uint64(t.sequence)),null!=t.ttl&&(n.uint32(48),n.uint64(t.ttl)),null!=t.pubKey&&(n.uint32(58),n.bytes(t.pubKey)),null!=t.signatureV2&&(n.uint32(66),n.bytes(t.signatureV2)),null!=t.data&&(n.uint32(74),n.bytes(t.data)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.value=t.bytes();break;case 2:r.signatureV1=t.bytes();break;case 3:r.validityType=e.ValidityType.codec().decode(t);break;case 4:r.validity=t.bytes();break;case 5:r.sequence=t.uint64();break;case 6:r.ttl=t.uint64();break;case 7:r.pubKey=t.bytes();break;case 8:r.signatureV2=t.bytes();break;case 9:r.data=t.bytes();break;default:t.skipType(7&n)}}return r}))),r),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(vfe||(vfe={}));const bfe=xH("ipns:utils"),wfe=(0,mu.m)("/ipns/");const Efe=async(e,t)=>{if(null==t||null==e){const e=new Error("one or more of the provided parameters are not defined");throw bfe.error(e),Xo()(e,yfe)}let n;if(null!=t.pubKey){try{n=DJ(t.pubKey)}catch(r){throw bfe.error(r),r}if(!(await P1(t.pubKey)).equals(e))throw Xo()(new Error("Embedded public key did not match PeerID"),"ERR_INVALID_EMBEDDED_KEY")}else null!=e.publicKey&&(n=DJ(e.publicKey));if(null!=n)return n;throw Xo()(new Error("no public key is available"),yfe)};function Afe(e){const t=vfe.decode(e);if(null!=t.sequence&&(t.sequence=BigInt(t.sequence)),null!=t.ttl&&(t.ttl=BigInt(t.ttl)),null==t.signatureV2||null==t.data)throw Xo()(new Error("missing data or signatureV2"),pfe);const n=_fe(t.data),r=Ife(n.Value);let i;try{i=ny().fromDate(function(e){const t=new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),n=String(e).trim().match(t);if(null==n)throw new Error("Invalid format");const r=parseInt(n[1],10),i=parseInt(n[2],10)-1,o=parseInt(n[3],10),s=parseInt(n[4],10),a=parseInt(n[5],10),c=parseInt(n[6],10),l=parseInt(n[7].padEnd(6,"0").slice(0,3),10);return new Date(Date.UTC(r,i,o,s,a,c,l))}((0,Su.B)(n.Validity)))}catch(o){throw bfe.error("unrecognized validity format (not an rfc3339 format)"),Xo()(new Error("unrecognized validity format (not an rfc3339 format)"),gfe)}if(null!=t.value&&null!=t.signatureV1)return Cfe(t),{value:r,validityType:vfe.ValidityType.EOL,validity:i,sequence:n.Sequence,ttl:n.TTL,pubKey:t.pubKey,signatureV1:t.signatureV1,signatureV2:t.signatureV2,data:t.data};if(null!=t.signatureV2)return{value:r,validityType:vfe.ValidityType.EOL,validity:i,sequence:n.Sequence,ttl:n.TTL,pubKey:t.pubKey,signatureV2:t.signatureV2,data:t.data};throw new Error("invalid record: does not include signatureV1 or signatureV2")}const Sfe=e=>x1(e.slice(wfe.length)),_fe=e=>{const t=FQ(e);if(0!==t.ValidityType)throw Xo()(new Error("Unknown validity type"),ffe);return t.ValidityType=vfe.ValidityType.EOL,Number.isInteger(t.Sequence)&&(t.Sequence=BigInt(t.Sequence)),Number.isInteger(t.TTL)&&(t.TTL=BigInt(t.TTL)),t},Ife=e=>{if(null!=e){if(a1(e))return"/ipns/".concat(e.toCID().toString(KQ));if(e instanceof Uint8Array){const t=(0,Su.B)(e);t.startsWith("/")&&(e=t)}const t=e.toString().trim();if(t.startsWith("/")&&t.length>1)return t;const n=wq.asCID(e);if(null!=n)return 114===n.code?"/ipns/".concat(n.toString(KQ)):"/ipfs/".concat(n.toV1().toString());try{return e instanceof Uint8Array?"/ipfs/".concat(wq.decode(e).toV1().toString()):"/ipfs/".concat(wq.parse(t).toV1().toString())}catch{}}throw Xo()(new Error("Value must be a valid content path starting with /"),"ERR_INVALID_VALUE")},Cfe=e=>{var t,n;if(null==e.data)throw Xo()(new Error("Record data is missing"),"ERR_INVALID_RECORD_DATA");const r=_fe(e.data);if(!(0,Ms.f)(r.Value,null!==(t=e.value)&&void 0!==t?t:new Uint8Array(0)))throw Xo()(new Error('Field "value" did not match between protobuf and CBOR'),pfe);if(!(0,Ms.f)(r.Validity,null!==(n=e.validity)&&void 0!==n?n:new Uint8Array(0)))throw Xo()(new Error('Field "validity" did not match between protobuf and CBOR'),pfe);if(r.ValidityType!==e.validityType)throw Xo()(new Error('Field "validityType" did not match between protobuf and CBOR'),pfe);if(r.Sequence!==e.sequence)throw Xo()(new Error('Field "sequence" did not match between protobuf and CBOR'),pfe);if(r.TTL!==e.ttl)throw Xo()(new Error('Field "ttl" did not match between protobuf and CBOR'),pfe)};function Tfe(e,t){const n=t.map(((e,t)=>({record:Afe(e),index:t})));return n.sort(((e,t)=>{const n=e.record.sequence,r=t.record.sequence;if(n>r)return-1;if(n<r)return 1;const i=e.record.validity.toDate(),o=t.record.validity.toDate();return i.getTime()>o.getTime()?-1:i.getTime()<o.getTime()?1:0})),n[0].index}const kfe=xH("ipns:validator"),Rfe=10240,xfe=async(e,t)=>{const n=Afe(t);let r;try{const t=(e=>{const t=(0,mu.m)("ipns-signature:");return(0,Ls.z)([t,e])})(n.data);r=await e.verify(t,n.signatureV2)}catch(i){r=!1}if(!r)throw kfe.error("record signature verification failed"),Xo()(new Error("record signature verification failed"),pfe);if(n.validityType===vfe.ValidityType.EOL){if(n.validity.toDate().getTime()<Date.now())throw kfe.error("record has expired"),Xo()(new Error("record has expired"),"ERR_IPNS_EXPIRED_RECORD")}else if(null!=n.validityType)throw kfe.error("unrecognized validity type"),Xo()(new Error("unrecognized validity type"),ffe);kfe("ipns record for %b is valid",n.value)};async function Pfe(e,t){if(t.byteLength>Rfe)throw Xo()(new Error("record too large"),mfe);const n=Sfe(e),r=Afe(t),i=await Efe(n,r);await xfe(i,t)}var Dfe;!function(e){let t,n,r,i,o,s,a,c;!function(e){e.DIAL="DIAL",e.DIAL_RESPONSE="DIAL_RESPONSE"}(t=e.MessageType||(e.MessageType={})),function(e){e[e.DIAL=0]="DIAL",e[e.DIAL_RESPONSE=1]="DIAL_RESPONSE"}(n||(n={})),function(e){e.codec=()=>bs(n)}(t=e.MessageType||(e.MessageType={})),function(e){e.OK="OK",e.E_DIAL_ERROR="E_DIAL_ERROR",e.E_DIAL_REFUSED="E_DIAL_REFUSED",e.E_BAD_REQUEST="E_BAD_REQUEST",e.E_INTERNAL_ERROR="E_INTERNAL_ERROR"}(r=e.ResponseStatus||(e.ResponseStatus={})),function(e){e[e.OK=0]="OK",e[e.E_DIAL_ERROR=100]="E_DIAL_ERROR",e[e.E_DIAL_REFUSED=101]="E_DIAL_REFUSED",e[e.E_BAD_REQUEST=200]="E_BAD_REQUEST",e[e.E_INTERNAL_ERROR=300]="E_INTERNAL_ERROR"}(i||(i={})),function(e){e.codec=()=>bs(i)}(r=e.ResponseStatus||(e.ResponseStatus={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==n.lengthDelimited&&t.fork(),null!=e.id&&(t.uint32(10),t.bytes(e.id)),null!=e.addrs)for(const r of e.addrs)t.uint32(18),t.bytes(r);!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={addrs:[]},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.id=e.bytes();break;case 2:n.addrs.push(e.bytes());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(o=e.PeerInfo||(e.PeerInfo={})),function(t){let n;t.codec=()=>(null==n&&(n=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.peer&&(n.uint32(10),e.PeerInfo.codec().encode(t.peer,n)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();if(n>>>3===1)r.peer=e.PeerInfo.codec().decode(t,t.uint32());else t.skipType(7&n)}return r}))),n),t.encode=e=>fs(e,t.codec()),t.decode=e=>ds(e,t.codec())}(s=e.Dial||(e.Dial={})),function(t){let n;t.codec=()=>(null==n&&(n=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.status&&(n.uint32(8),e.ResponseStatus.codec().encode(t.status,n)),null!=t.statusText&&(n.uint32(18),n.string(t.statusText)),null!=t.addr&&(n.uint32(26),n.bytes(t.addr)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.status=e.ResponseStatus.codec().decode(t);break;case 2:r.statusText=t.string();break;case 3:r.addr=t.bytes();break;default:t.skipType(7&n)}}return r}))),n),t.encode=e=>fs(e,t.codec()),t.decode=e=>ds(e,t.codec())}(a=e.DialResponse||(e.DialResponse={})),e.codec=()=>(null==c&&(c=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.type&&(n.uint32(8),e.MessageType.codec().encode(t.type,n)),null!=t.dial&&(n.uint32(18),e.Dial.codec().encode(t.dial,n)),null!=t.dialResponse&&(n.uint32(26),e.DialResponse.codec().encode(t.dialResponse,n)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.type=e.MessageType.codec().decode(t);break;case 2:r.dial=e.Dial.codec().decode(t,t.uint32());break;case 3:r.dialResponse=e.DialResponse.codec().decode(t,t.uint32());break;default:t.skipType(7&n)}}return r}))),c),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Dfe||(Dfe={}));const Ofe=xH("libp2p:autonat");class Nfe{constructor(e,t){var n,r,i,o,s,a;(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"startupDelay",void 0),(0,Yo.Z)(this,"refreshInterval",void 0),(0,Yo.Z)(this,"protocol",void 0),(0,Yo.Z)(this,"timeout",void 0),(0,Yo.Z)(this,"maxInboundStreams",void 0),(0,Yo.Z)(this,"maxOutboundStreams",void 0),(0,Yo.Z)(this,"verifyAddressTimeout",void 0),(0,Yo.Z)(this,"started",void 0),this.components=e,this.started=!1,this.protocol="/".concat(null!==(n=t.protocolPrefix)&&void 0!==n?n:"libp2p","/").concat("autonat","/").concat("1.0.0"),this.timeout=null!==(r=t.timeout)&&void 0!==r?r:3e4,this.maxInboundStreams=null!==(i=t.maxInboundStreams)&&void 0!==i?i:1,this.maxOutboundStreams=null!==(o=t.maxOutboundStreams)&&void 0!==o?o:1,this.startupDelay=null!==(s=t.startupDelay)&&void 0!==s?s:5e3,this.refreshInterval=null!==(a=t.refreshInterval)&&void 0!==a?a:6e4,this._verifyExternalAddresses=this._verifyExternalAddresses.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.registrar.handle(this.protocol,(e=>{this.handleIncomingAutonatStream(e).catch((e=>{Ofe.error("error handling incoming autonat stream",e)}))}),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this.verifyAddressTimeout=setTimeout(this._verifyExternalAddresses,this.startupDelay),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),clearTimeout(this.verifyAddressTimeout),this.started=!1}async handleIncomingAutonatStream(e){const t=AbortSignal.timeout(this.timeout),n=()=>{e.stream.abort(new Pq("handleIncomingAutonatStream timeout",F5.ERR_TIMEOUT))};t.addEventListener("abort",n,{once:!0}),KJ(1/0,t);const r=this.components.addressManager.getAddresses().map((e=>e.toOptions().host));try{const n=this;await _G(e.stream,(e=>yG(e)),(async function*(i){const o=await v4(i);if(null==o)return Ofe("no message received"),void(yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.E_BAD_REQUEST,statusText:"No message was sent"}}));let s;try{s=Dfe.decode(o)}catch(f){return Ofe.error("could not decode message",f),void(yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.E_BAD_REQUEST,statusText:"Could not decode message"}}))}const a=s.dial;if(null==a)return Ofe.error("dial was missing from message"),void(yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.E_BAD_REQUEST,statusText:"No Dial message found in message"}}));let c;const l=a.peer;if(null==l||null==l.id)return Ofe.error("PeerId missing from message"),void(yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.E_BAD_REQUEST,statusText:"missing peer info"}}));try{c=x1(l.id)}catch(f){return Ofe.error("invalid PeerId",f),void(yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.E_BAD_REQUEST,statusText:"bad peer id"}}))}if(Ofe("incoming request from %p",c),!e.connection.remotePeer.equals(c))return Ofe("target peer %p did not equal sending peer %p",c,e.connection.remotePeer),void(yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.E_BAD_REQUEST,statusText:"peer id mismatch"}}));const u=l.addrs.map((e=>(0,og.HM)(e))).filter((t=>{const n=t.toOptions().host===e.connection.remoteAddr.toOptions().host;return Ofe.trace("request to dial %a was sent from %a is same host %s",t,e.connection.remoteAddr,n),n})).filter((e=>{var t;const n=e.toOptions().host,r=!(null!==(t=SS(n))&&void 0!==t&&t);return Ofe.trace("host %s was public %s",n,r),r})).filter((e=>{const t=e.toOptions().host,n=!r.includes(t);return Ofe.trace("host %s was not our host %s",t,n),n})).filter((e=>{const t=Boolean(n.components.transportManager.transportForMultiaddr(e));return Ofe.trace("transport for %a is supported %s",e,t),t})).map((e=>(null==e.getPeerId()&&(e=e.encapsulate("/p2p/".concat(c.toString()))),e)));if(0===u.length)return Ofe("no valid multiaddrs for %p in message",c),void(yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.E_DIAL_REFUSED,statusText:"no dialable addresses"}}));Ofe("dial multiaddrs %s for peer %p",u.map((e=>e.toString())).join(", "),c);let h="",d=u[0];for await(const e of u){let r;d=e;try{if(r=await n.components.connectionManager.openConnection(e,{signal:t}),!r.remoteAddr.equals(e))throw Ofe.error("tried to dial %a but dialed %a",e,r.remoteAddr),new Error("Unexpected remote address");return Ofe("Success %p",c),void(yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.OK,addr:r.remoteAddr.decapsulateCode((0,og.a_)("p2p").code).bytes}}))}catch(f){Ofe("could not dial %p",c,f),h=f.message}finally{null!=r&&await r.close()}}yield Dfe.encode({type:Dfe.MessageType.DIAL_RESPONSE,dialResponse:{status:Dfe.ResponseStatus.E_DIAL_ERROR,statusText:h,addr:d.bytes}})}),(e=>fG(e)),e.stream)}catch(i){Ofe.error("error handling incoming autonat stream",i)}finally{t.removeEventListener("abort",n)}}_verifyExternalAddresses(){this.verifyExternalAddresses().catch((e=>{Ofe.error("error verifying external address",e)}))}async verifyExternalAddresses(){if(clearTimeout(this.verifyAddressTimeout),!this.isStarted())return;const e=this.components.addressManager,t=e.getObservedAddrs().filter((e=>{var t;const n=e.toOptions();return!(null!==(t=SS(n.host))&&void 0!==t&&t)}));if(0===t.length)return Ofe("no public addresses found, not requesting verification"),void(this.verifyAddressTimeout=setTimeout(this._verifyExternalAddresses,this.refreshInterval));const n=AbortSignal.timeout(this.timeout);KJ(1/0,n);const r=this;try{Ofe("verify multiaddrs %s",t.map((e=>e.toString())).join(", "));const o=Dfe.encode({type:Dfe.MessageType.DIAL,dial:{peer:{id:this.components.peerId.toBytes(),addrs:t.map((e=>e.bytes))}}}),s=(await OA()).toBytes(),a={},c=[],l=async e=>{let t=()=>{};try{Ofe("asking %p to verify multiaddr",e.id);const i=await r.components.connectionManager.openConnection(e.id,{signal:n}),s=await i.newStream(this.protocol,{signal:n});t=()=>{s.abort(new Pq("verifyAddress timeout",F5.ERR_TIMEOUT))},n.addEventListener("abort",t,{once:!0});const a=await _G([o],(e=>fG(e)),s,(e=>yG(e)),(async e=>v4(e)));if(null==a)return void Ofe("no response received from %p",i.remotePeer);const l=Dfe.decode(a);if(l.type!==Dfe.MessageType.DIAL_RESPONSE||null==l.dialResponse)return void Ofe("invalid autonat response from %p",i.remotePeer);if(l.dialResponse.status===Dfe.ResponseStatus.OK){const e=i.remoteAddr.toOptions();let t;if(4===e.family){t=e.host.split(".")[0]}else{if(6!==e.family)return void Ofe('remote address "%s" was not IP4 or IP6?',e.host);t=e.host.split(":")[0]}if(c.includes(t))return void Ofe("already have response from network segment %d - %s",t,e.host);c.push(t)}return l.dialResponse}catch(i){Ofe.error("error asking remote to verify multiaddr",i)}finally{n.removeEventListener("abort",t)}};for await(const r of qA(mG(this.components.peerRouting.getClosestPeers(s,{signal:n}),(e=>async()=>l(e))),{concurrency:4}))try{if(null==r)continue;const n=null==r.addr?t[0]:(0,og.HM)(r.addr);if(Ofe("autonat response for %a is %s",n,r.status),r.status===Dfe.ResponseStatus.E_BAD_REQUEST)continue;if(r.status===Dfe.ResponseStatus.E_DIAL_REFUSED)continue;if(null==r.addr&&t.length>1)continue;if(!t.some((e=>e.equals(n)))){Ofe("peer reported %a as %s but it was not in our observed address list",n,r.status);continue}const i=n.toString();if(null==a[i]&&(a[i]={success:0,failure:0}),r.status===Dfe.ResponseStatus.OK?a[i].success++:r.status===Dfe.ResponseStatus.E_DIAL_ERROR&&a[i].failure++,4===a[i].success)return Ofe("%a is externally dialable",n),void e.confirmObservedAddr(n);if(4===a[i].failure)return Ofe("%a is not externally dialable",n),void e.removeObservedAddr(n)}catch(i){Ofe.error("could not verify external address",i)}}finally{this.verifyAddressTimeout=setTimeout(this._verifyExternalAddresses,this.refreshInterval)}}}function Bfe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new Nfe(t,e)}BigInt(1<<17);const Lfe="/libp2p/circuit/relay/0.2.0/hop",Mfe="/libp2p/circuit/relay/0.2.0/stop";var Ufe,Ffe,Kfe,jfe,Zfe,zfe,Vfe,Hfe;!function(e){let t,n,r;!function(e){e.RESERVE="RESERVE",e.CONNECT="CONNECT",e.STATUS="STATUS"}(t=e.Type||(e.Type={})),function(e){e[e.RESERVE=0]="RESERVE",e[e.CONNECT=1]="CONNECT",e[e.STATUS=2]="STATUS"}(n||(n={})),function(e){e.codec=()=>bs(n)}(t=e.Type||(e.Type={})),e.codec=()=>(null==r&&(r=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.type&&(n.uint32(8),e.Type.codec().encode(t.type,n)),null!=t.peer&&(n.uint32(18),Kfe.codec().encode(t.peer,n)),null!=t.reservation&&(n.uint32(26),jfe.codec().encode(t.reservation,n)),null!=t.limit&&(n.uint32(34),Zfe.codec().encode(t.limit,n)),null!=t.status&&(n.uint32(40),zfe.codec().encode(t.status,n)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.type=e.Type.codec().decode(t);break;case 2:r.peer=Kfe.codec().decode(t,t.uint32());break;case 3:r.reservation=jfe.codec().decode(t,t.uint32());break;case 4:r.limit=Zfe.codec().decode(t,t.uint32());break;case 5:r.status=zfe.codec().decode(t);break;default:t.skipType(7&n)}}return r}))),r),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Ufe||(Ufe={})),function(e){let t,n,r;!function(e){e.CONNECT="CONNECT",e.STATUS="STATUS"}(t=e.Type||(e.Type={})),function(e){e[e.CONNECT=0]="CONNECT",e[e.STATUS=1]="STATUS"}(n||(n={})),function(e){e.codec=()=>bs(n)}(t=e.Type||(e.Type={})),e.codec=()=>(null==r&&(r=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.type&&(n.uint32(8),e.Type.codec().encode(t.type,n)),null!=t.peer&&(n.uint32(18),Kfe.codec().encode(t.peer,n)),null!=t.limit&&(n.uint32(26),Zfe.codec().encode(t.limit,n)),null!=t.status&&(n.uint32(32),zfe.codec().encode(t.status,n)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.type=e.Type.codec().decode(t);break;case 2:r.peer=Kfe.codec().decode(t,t.uint32());break;case 3:r.limit=Zfe.codec().decode(t,t.uint32());break;case 4:r.status=zfe.codec().decode(t);break;default:t.skipType(7&n)}}return r}))),r),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Ffe||(Ffe={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==n.lengthDelimited&&t.fork(),null!=e.id&&e.id.byteLength>0&&(t.uint32(10),t.bytes(e.id)),null!=e.addrs)for(const r of e.addrs)t.uint32(18),t.bytes(r);!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={id:new Uint8Array(0),addrs:[]},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.id=e.bytes();break;case 2:n.addrs.push(e.bytes());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Kfe||(Kfe={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==n.lengthDelimited&&t.fork(),null!=e.expire&&0n!==e.expire&&(t.uint32(8),t.uint64(e.expire)),null!=e.addrs)for(const r of e.addrs)t.uint32(18),t.bytes(r);null!=e.voucher&&(t.uint32(26),t.bytes(e.voucher)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={expire:0n,addrs:[]},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.expire=e.uint64();break;case 2:n.addrs.push(e.bytes());break;case 3:n.voucher=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(jfe||(jfe={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.duration&&(t.uint32(8),t.uint32(e.duration)),null!=e.data&&(t.uint32(16),t.uint64(e.data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.duration=e.uint32();break;case 2:n.data=e.uint64();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Zfe||(Zfe={})),function(e){e.UNUSED="UNUSED",e.OK="OK",e.RESERVATION_REFUSED="RESERVATION_REFUSED",e.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",e.PERMISSION_DENIED="PERMISSION_DENIED",e.CONNECTION_FAILED="CONNECTION_FAILED",e.NO_RESERVATION="NO_RESERVATION",e.MALFORMED_MESSAGE="MALFORMED_MESSAGE",e.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"}(zfe||(zfe={})),function(e){e[e.UNUSED=0]="UNUSED",e[e.OK=100]="OK",e[e.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",e[e.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",e[e.PERMISSION_DENIED=202]="PERMISSION_DENIED",e[e.CONNECTION_FAILED=203]="CONNECTION_FAILED",e[e.NO_RESERVATION=204]="NO_RESERVATION",e[e.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",e[e.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"}(Vfe||(Vfe={})),function(e){e.codec=()=>bs(Vfe)}(zfe||(zfe={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.relay&&e.relay.byteLength>0&&(t.uint32(10),t.bytes(e.relay)),null!=e.peer&&e.peer.byteLength>0&&(t.uint32(18),t.bytes(e.peer)),null!=e.expiration&&0n!==e.expiration&&(t.uint32(24),t.uint64(e.expiration)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={relay:new Uint8Array(0),peer:new Uint8Array(0),expiration:0n},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.relay=e.bytes();break;case 2:n.peer=e.bytes();break;case 3:n.expiration=e.uint64();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Hfe||(Hfe={}));xH("libp2p:circuit-relay:utils");function qfe(e){const t=e*BigInt(1e3),n=(new Date).getTime();return Number(t-BigInt(n))}xH("libp2p:circuit-relay:advert-service");xH("libp2p:circuit-relay:server");const Gfe=xH("libp2p:stream:converter");function Wfe(e){const{stream:t,remoteAddr:n}=e,{sink:r,source:i}=t,o={async sink(e){try{await r(e),s()}catch(t){"aborted"!==t.type&&Gfe(t)}},source:async function*(){for await(const e of i)e instanceof Uint8Array?yield e:yield*e}(),remoteAddr:n,timeline:{open:Date.now(),close:void 0},async close(e){s(),await t.close(e)},abort(e){s(),t.abort(e)}};function s(){null==o.timeline.close&&(o.timeline.close=Date.now())}return o}const Qfe=xH("libp2p:circuit-relay:discover-relays");class Yfe extends MJ{constructor(e){super(),(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"contentRouting",void 0),(0,Yo.Z)(this,"registrar",void 0),(0,Yo.Z)(this,"started",void 0),(0,Yo.Z)(this,"topologyId",void 0),this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.contentRouting=e.contentRouting,this.registrar=e.registrar}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(Lfe,{notifyOnTransient:!0,onConnect:e=>{this.safeDispatchEvent("relay:discover",{detail:e})}}),this.discover().catch((e=>{Qfe.error("error listening on relays",e)})),this.started=!0}stop(){null!=this.topologyId&&this.registrar.unregister(this.topologyId),this.started=!1}async discover(){Qfe("searching peer store for relays");const e=await this.peerStore.all({filters:[e=>e.protocols.includes(Lfe)],orders:[()=>Math.random()<.5?1:-1]});for(const n of e)Qfe("found relay peer %p in content peer store",n.id),this.safeDispatchEvent("relay:discover",{detail:n.id});Qfe("found %d relay peers in peer store",e.length);try{Qfe("searching content routing for relays");const e=await async function(e){const t=(new TextEncoder).encode(e),n=await Uq.digest(t);return wq.createV0(n)}("/libp2p/relay");let t=0;for await(const n of this.contentRouting.findProviders(e))if(n.multiaddrs.length>0&&!n.id.equals(this.peerId)){const e=n.id;t++,await this.peerStore.merge(e,{multiaddrs:n.multiaddrs}),Qfe("found relay peer %p in content routing",e),this.safeDispatchEvent("relay:discover",{detail:e})}Qfe("found %d relay peers in content routing",t)}catch(t){Qfe.error("failed when finding relays on the network",t)}}}const Jfe=xH("libp2p:circuit-relay:transport:listener");var Xfe=new WeakSet;class $fe extends MJ{constructor(e){super(),Jd(this,Xfe),(0,Yo.Z)(this,"connectionManager",void 0),(0,Yo.Z)(this,"relayStore",void 0),(0,Yo.Z)(this,"listeningAddrs",void 0),(0,Yo.Z)(this,"_onRemoveRelayPeer",(e=>{Xd(this,Xfe,epe).call(this,e.detail)})),this.connectionManager=e.connectionManager,this.relayStore=e.relayStore,this.listeningAddrs=new Ex,this.relayStore.addEventListener("relay:removed",this._onRemoveRelayPeer)}async listen(e){Jfe("listen on %a",e);const t=e.decapsulate("/p2p-circuit"),n=await this.connectionManager.openConnection(t);if(!this.relayStore.hasReservation(n.remotePeer))return void await this.relayStore.addRelay(n.remotePeer,"configured");const r=this.relayStore.getReservation(n.remotePeer);if(null==r)throw new Pq("Did not have reservation after making reservation","ERR_NO_RESERVATION");this.listeningAddrs.has(n.remotePeer)?Jfe("already listening on relay %p",n.remotePeer):(this.listeningAddrs.set(n.remotePeer,r.addrs.map((e=>(0,og.HM)(e).encapsulate("/p2p-circuit")))),this.safeDispatchEvent("listening",{}))}getAddrs(){return[...this.listeningAddrs.values()].flat()}async close(){}}function epe(e){const t=this.listeningAddrs.has(e);Jfe("relay peer removed %p - had reservation",e,t),this.listeningAddrs.delete(e),t&&(Jfe.trace("removing relay event listener for peer %p",e),this.relayStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),this.safeDispatchEvent("close",{}))}const tpe=xH("libp2p:circuit-relay:transport:reservation-store");var npe=new WeakSet,rpe=new WeakSet;class ipe extends MJ{constructor(e,t){var n,r,i,o;super(),Jd(this,rpe),Jd(this,npe),(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"connectionManager",void 0),(0,Yo.Z)(this,"transportManager",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"events",void 0),(0,Yo.Z)(this,"reserveQueue",void 0),(0,Yo.Z)(this,"reservations",void 0),(0,Yo.Z)(this,"maxDiscoveredRelays",void 0),(0,Yo.Z)(this,"maxReservationQueueLength",void 0),(0,Yo.Z)(this,"reservationCompletionTimeout",void 0),(0,Yo.Z)(this,"started",void 0),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Ex,this.maxDiscoveredRelays=null!==(n=null===t||void 0===t?void 0:t.discoverRelays)&&void 0!==n?n:0,this.maxReservationQueueLength=null!==(r=null===t||void 0===t?void 0:t.maxReservationQueueLength)&&void 0!==r?r:100,this.reservationCompletionTimeout=null!==(i=null===t||void 0===t?void 0:t.reservationCompletionTimeout)&&void 0!==i?i:1e4,this.started=!1,this.reserveQueue=new q5({concurrency:null!==(o=null===t||void 0===t?void 0:t.reservationConcurrency)&&void 0!==o?o:1}),this.events.addEventListener("peer:disconnect",(e=>{Xd(this,rpe,spe).call(this,e.detail)}))}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.reserveQueue.clear(),this.reservations.forEach((e=>{let{timeout:t}=e;clearTimeout(t)})),this.reservations.clear(),this.started=!1}async addRelay(e,t){this.peerId.equals(e)?tpe("not trying to use self as relay"):this.reserveQueue.size>this.maxReservationQueueLength?tpe("not adding relay as the queue is full"):this.reserveQueue.hasJob(e)?tpe("relay peer is already in the reservation queue"):(tpe("add relay %p",e),await this.reserveQueue.add((async()=>{try{const n=this.reservations.get(e);if(null!=n){if(qfe(n.reservation.expire)>6e5)return void tpe("already have reservation on relay peer %p and it expires in more than 10 minutes",e);clearTimeout(n.timeout),this.reservations.delete(e)}if("discovered"===t&&[...this.reservations.values()].reduce(((e,t)=>("discovered"===t.type&&e++,e)),0)>=this.maxDiscoveredRelays)return void tpe("already have enough discovered relays");const r=AbortSignal.timeout(this.reservationCompletionTimeout),i=await this.connectionManager.openConnection(e,{signal:r});if(i.remoteAddr.protoNames().includes("p2p-circuit"))return void tpe("not creating reservation over relayed connection");const o=await Xd(this,npe,ope).call(this,i,{signal:r});tpe("created reservation on relay peer %p",e);const s=qfe(o.expire),a=Math.min(Math.max(s-3e5,3e4),Math.pow(2,31)-1),c=setTimeout((()=>{this.addRelay(e,t).catch((t=>{tpe.error("could not refresh reservation to relay %p",e,t)}))}),a);this.reservations.set(e,{timeout:c,reservation:o,type:t}),await this.peerStore.merge(e,{tags:{"circuit-relay-relay":{value:1,ttl:s}}}),await this.transportManager.listen([(0,og.HM)("/p2p/".concat(e.toString(),"/p2p-circuit"))])}catch(n){tpe.error("could not reserve slot on %p",e,n);const t=this.reservations.get(e);null!=t&&clearTimeout(t.timeout),this.reservations.delete(e)}}),{peerId:e}))}hasReservation(e){return this.reservations.has(e)}getReservation(e){var t;return null===(t=this.reservations.get(e))||void 0===t?void 0:t.reservation}}async function ope(e,t){var n,r;null===(n=t.signal)||void 0===n||n.throwIfAborted(),tpe("requesting reservation from %p",e.remotePeer);const i=await e.newStream(Lfe,t),o=hk(i).pb(Ufe);let s;await o.write({type:Ufe.Type.RESERVE},t);try{s=await o.read(t)}catch(c){throw tpe.error("error parsing reserve message response from %p because",e.remotePeer,c),c}finally{await i.close()}if(s.status===zfe.OK&&null!=s.reservation)return s.reservation;const a="reservation failed with status ".concat(null!==(r=s.status)&&void 0!==r?r:"undefined");throw tpe.error(a),new Error(a)}function spe(e){const t=this.reservations.get(e);null!=t&&(tpe("connection to relay %p closed, removing reservation from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),this.safeDispatchEvent("relay:removed",{detail:e}),this.reservations.size<this.maxDiscoveredRelays&&(tpe("not enough relays %d/%d",this.reservations.size,this.maxDiscoveredRelays),this.safeDispatchEvent("relay:not-enough-relays",{})))}let ape;const cpe=xH("libp2p:circuit-relay:transport"),lpe=G5,upe=G5,hpe=3e4;ape=Symbol.toStringTag;class dpe{constructor(e,t){var n,r,i;(0,Yo.Z)(this,"discovery",void 0),(0,Yo.Z)(this,"registrar",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"connectionManager",void 0),(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"upgrader",void 0),(0,Yo.Z)(this,"addressManager",void 0),(0,Yo.Z)(this,"connectionGater",void 0),(0,Yo.Z)(this,"reservationStore",void 0),(0,Yo.Z)(this,"maxInboundStopStreams",void 0),(0,Yo.Z)(this,"maxOutboundStopStreams",void 0),(0,Yo.Z)(this,"stopTimeout",void 0),(0,Yo.Z)(this,"started",void 0),(0,Yo.Z)(this,_5,!0),(0,Yo.Z)(this,ape,"libp2p/circuit-relay-v2"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=null!==(n=t.maxInboundStopStreams)&&void 0!==n?n:lpe,this.maxOutboundStopStreams=null!==(r=t.maxOutboundStopStreams)&&void 0!==r?r:upe,this.stopTimeout=null!==(i=t.stopTimeout)&&void 0!==i?i:hpe,null!=t.discoverRelays&&t.discoverRelays>0&&(this.discovery=new Yfe(e),this.discovery.addEventListener("relay:discover",(e=>{this.reservationStore.addRelay(e.detail,"discovered").catch((t=>{cpe.error("could not add discovered relay %p",e.detail,t)}))}))),this.reservationStore=new ipe(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",(()=>{var e;null===(e=this.discovery)||void 0===e||e.discover().catch((e=>{cpe.error("could not discover relays",e)}))})),this.started=!1}isStarted(){return this.started}async start(){var e;await this.reservationStore.start(),await(null===(e=this.discovery)||void 0===e?void 0:e.start()),await this.registrar.handle(Mfe,(e=>{this.onStop(e).catch((t=>{cpe.error("error while handling STOP protocol",t),e.stream.abort(t)}))}),{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnTransientConnection:!0}),this.started=!0}async stop(){var e;null===(e=this.discovery)||void 0===e||e.stop(),await this.reservationStore.stop(),await this.registrar.unhandle(Mfe),this.started=!1}async dial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(1!==e.protoCodes().filter((e=>290===e)).length){const t="Invalid circuit relay address";throw cpe.error(t,e),new Pq(t,F5.ERR_RELAYED_DIAL)}const n=e.toString().split("/p2p-circuit"),r=(0,og.HM)(n[0]),i=(0,og.HM)(n[n.length-1]),o=r.getPeerId(),s=i.getPeerId();if(null==o||null==s){const t="Circuit relay dial to ".concat(e.toString()," failed as address did not have peer ids");throw cpe.error(t),new Pq(t,F5.ERR_RELAYED_DIAL)}const a=R1(o),c=R1(s);let l=!1;let u,h=this.connectionManager.getConnections(a)[0];null==h&&(await this.peerStore.merge(a,{multiaddrs:[r]}),h=await this.connectionManager.openConnection(a,t),l=!0);try{return u=await h.newStream([Lfe]),await this.connectV2({stream:u,connection:h,destinationPeer:c,destinationAddr:i,relayAddr:r,ma:e,disconnectOnFailure:l})}catch(d){throw cpe.error("circuit relay dial to destination %p via relay %p failed",c,a,d),null!=u&&u.abort(d),l&&await h.close(),d}}async connectV2(e){let{stream:t,connection:n,destinationPeer:r,destinationAddr:i,relayAddr:o,ma:s,disconnectOnFailure:a}=e;try{const e=hk(t),n=e.pb(Ufe);await n.write({type:Ufe.Type.CONNECT,peer:{id:r.toBytes(),addrs:[(0,og.HM)(i).bytes]}});const a=await n.read();var c,l;if(a.status!==zfe.OK)throw new Pq("failed to connect via relay with status ".concat(null!==(c=null===a||void 0===a||null===(l=a.status)||void 0===l?void 0:l.toString())&&void 0!==c?c:"undefined"),F5.ERR_HOP_REQUEST_FAILED);const u=Wfe({stream:e.unwrap(),remoteAddr:s,localAddr:o.encapsulate("/p2p-circuit/p2p/".concat(this.peerId.toString()))});return cpe("new outbound transient connection %a",u.remoteAddr),await this.upgrader.upgradeOutbound(u,{transient:!0})}catch(u){throw cpe.error("Circuit relay dial to destination ".concat(r.toString()," via relay ").concat(n.remotePeer.toString()," failed"),u),a&&await n.close(),u}}createListener(e){return function(e){return new $fe(e)}({connectionManager:this.connectionManager,relayStore:this.reservationStore})}filter(e){return(e=Array.isArray(e)?e:[e]).filter((e=>aP.matches(e)))}async onStop(e){var t,n;let{connection:r,stream:i}=e;const o=AbortSignal.timeout(this.stopTimeout),s=hk(i).pb(Ffe),a=await s.read({signal:o});if(cpe("new circuit relay v2 stop stream from %p with type %s",r.remotePeer,a.type),void 0===(null===a||void 0===a?void 0:a.type))return cpe.error("type was missing from circuit v2 stop protocol request from %s",r.remotePeer),await s.write({type:Ffe.Type.STATUS,status:zfe.MALFORMED_MESSAGE},{signal:o}),void await i.close();if(a.type!==Ffe.Type.CONNECT)return cpe.error("invalid stop connect request via peer %p",r.remotePeer),await s.write({type:Ffe.Type.STATUS,status:zfe.UNEXPECTED_MESSAGE},{signal:o}),void await i.close();if(!(e=>{if(null==e.peer)return!1;try{e.peer.addrs.forEach(og.HM)}catch{return!1}return!0})(a))return cpe.error("invalid stop connect request via peer %p",r.remotePeer),await s.write({type:Ffe.Type.STATUS,status:zfe.MALFORMED_MESSAGE},{signal:o}),void await i.close();const c=x1(a.peer.id);if(!0===await(null===(t=(n=this.connectionGater).denyInboundRelayedConnection)||void 0===t?void 0:t.call(n,r.remotePeer,c)))return cpe.error("connection gater denied inbound relayed connection from %p",r.remotePeer),await s.write({type:Ffe.Type.STATUS,status:zfe.PERMISSION_DENIED},{signal:o}),void await i.close();cpe.trace("sending success response to %p",r.remotePeer),await s.write({type:Ffe.Type.STATUS,status:zfe.OK},{signal:o});const l=r.remoteAddr.encapsulate("/p2p-circuit/p2p/".concat(c.toString())),u=this.addressManager.getAddresses()[0],h=Wfe({stream:s.unwrap().unwrap(),remoteAddr:l,localAddr:u});cpe("new inbound transient connection %a",h.remoteAddr),await this.upgrader.upgradeInbound(h,{transient:!0}),cpe("%s connection %a upgraded","inbound",h.remoteAddr)}}function fpe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new dpe(t,e)}const ppe=()=>{const e=new Error("Delay aborted");return e.name="AbortError",e},gpe=new WeakMap;const ype=function(){let{clearTimeout:e,setTimeout:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return function(n){let r,i,o,{value:s,signal:a}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null!==a&&void 0!==a&&a.aborted)return Promise.reject(ppe());const c=null!==e&&void 0!==e?e:clearTimeout,l=()=>{c(r),o(ppe())},u=new Promise(((e,c)=>{i=()=>{a&&a.removeEventListener("abort",l),e(s)},o=c,r=(null!==t&&void 0!==t?t:setTimeout)(i,n)}));return a&&a.addEventListener("abort",l,{once:!0}),gpe.set(u,(()=>{c(r),r=null,i()})),u}}(),mpe=ype;var vpe;function bpe(e,t){if(gO.dx.matches(e))return!1;return null!=t.transportForMultiaddr(e)&&(!!gO.Rk.matches(e)||!!gO.IP.matches(e)&&!1===SS(e.toOptions().host))}!function(e){let t,n,r;!function(e){e.UNUSED="UNUSED",e.CONNECT="CONNECT",e.SYNC="SYNC"}(t=e.Type||(e.Type={})),function(e){e[e.UNUSED=0]="UNUSED",e[e.CONNECT=100]="CONNECT",e[e.SYNC=300]="SYNC"}(n||(n={})),function(e){e.codec=()=>bs(n)}(t=e.Type||(e.Type={})),e.codec=()=>(null==r&&(r=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==r.lengthDelimited&&n.fork(),null!=t.type&&(n.uint32(8),e.Type.codec().encode(t.type,n)),null!=t.observedAddresses)for(const e of t.observedAddresses)n.uint32(18),n.bytes(e);!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={observedAddresses:[]},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.type=e.Type.codec().decode(t);break;case 2:r.observedAddresses.push(t.bytes());break;default:t.skipType(7&n)}}return r}))),r),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(vpe||(vpe={}));const wpe=xH("libp2p:dcutr"),Epe=5e3,Ape=3,Spe=1,_pe=1;class Ipe{constructor(e,t){var n,r,i,o;(0,Yo.Z)(this,"started",void 0),(0,Yo.Z)(this,"timeout",void 0),(0,Yo.Z)(this,"retries",void 0),(0,Yo.Z)(this,"maxInboundStreams",void 0),(0,Yo.Z)(this,"maxOutboundStreams",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"registrar",void 0),(0,Yo.Z)(this,"connectionManager",void 0),(0,Yo.Z)(this,"addressManager",void 0),(0,Yo.Z)(this,"transportManager",void 0),(0,Yo.Z)(this,"topologyId",void 0),this.started=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.timeout=null!==(n=t.timeout)&&void 0!==n?n:Epe,this.retries=null!==(r=t.retries)&&void 0!==r?r:Ape,this.maxInboundStreams=null!==(i=t.maxInboundStreams)&&void 0!==i?i:Spe,this.maxOutboundStreams=null!==(o=t.maxOutboundStreams)&&void 0!==o?o:_pe}isStarted(){return this.started}async start(){this.started||(this.topologyId=await this.registrar.register(Cpe,{notifyOnTransient:!0,onConnect:(e,t)=>{t.transient&&"inbound"===t.direction&&this.upgradeInbound(t).catch((e=>{wpe.error("error during outgoing DCUtR attempt",e)}))}}),await this.registrar.handle(Cpe,(e=>{this.handleIncomingUpgrade(e.stream,e.connection).catch((t=>{wpe.error("error during incoming DCUtR attempt",t),e.stream.abort(t)}))}),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnTransientConnection:!0}),this.started=!0)}async stop(){await this.registrar.unhandle(Cpe),null!=this.topologyId&&this.registrar.unregister(this.topologyId),this.started=!1}async upgradeInbound(e){if(await this.attemptUnilateralConnectionUpgrade(e))return;let t;for(let i=0;i<this.retries;i++){const o={signal:AbortSignal.timeout(this.timeout)};try{t=await e.newStream([Cpe],{signal:o.signal,runOnTransientConnection:!0});const n=hk(t,{maxDataLength:4096}).pb(vpe);wpe("B sending connect to %p",e.remotePeer);const r=Date.now();await n.write({type:vpe.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map((e=>e.bytes))},o),wpe("B receiving connect from %p",e.remotePeer);const i=await n.read(o);if(i.type!==vpe.Type.CONNECT)throw wpe("A sent wrong message type"),new Pq("DCUtR message type was incorrect",F5.ERR_INVALID_MESSAGE);const s=this.getDialableMultiaddrs(i.observedAddresses);if(0===s.length)throw wpe("A did not have any dialable multiaddrs"),new Pq("DCUtR connect message had no multiaddrs",F5.ERR_INVALID_MESSAGE);const a=Date.now()-r;wpe("A sending sync, rtt %dms",a),await n.write({type:vpe.Type.SYNC,observedAddresses:[]},o),wpe("A waiting for half RTT"),await mpe(a/2),wpe("B dialing",s);const c=await this.connectionManager.openConnection(s,{signal:o.signal,priority:100});wpe("DCUtR to %p succeeded to address %a, closing relayed connection",e.remotePeer,c.remoteAddr),await e.close(o);break}catch(r){var n;if(wpe.error("error while attempting DCUtR on attempt %d of %d",i+1,this.retries,r),null===(n=t)||void 0===n||n.abort(r),i===this.retries)throw r}finally{null!=t&&await t.close(o)}}}async attemptUnilateralConnectionUpgrade(e){const t=(await this.peerStore.get(e.remotePeer)).addresses.map((t=>{const n=t.multiaddr;return null==n.getPeerId()?n.encapsulate("/p2p/".concat(e.remotePeer)):n})).filter((e=>bpe(e,this.transportManager)));if(t.length>0){const r=AbortSignal.timeout(this.timeout);try{wpe("attempting unilateral connection upgrade to %a",t);const n=await this.connectionManager.openConnection(t,{signal:r,force:!0});if(n.transient)throw new Error("Could not open a new, non-transient, connection");return wpe("unilateral connection upgrade to %p succeeded via %a, closing relayed connection",e.remotePeer,n.remoteAddr),await e.close({signal:r}),!0}catch(n){wpe.error("unilateral connection upgrade to %p on addresses %a failed",e.remotePeer,t,n)}}else wpe("peer %p has no public addresses, not attempting unilateral connection upgrade",e.remotePeer);return!1}async handleIncomingUpgrade(e,t){const n={signal:AbortSignal.timeout(this.timeout)};try{const r=hk(e,{maxDataLength:4096}).pb(vpe);wpe("A receiving connect");const i=await r.read(n);if(i.type!==vpe.Type.CONNECT)throw wpe("B sent wrong message type"),new Pq("DCUtR message type was incorrect",F5.ERR_INVALID_MESSAGE);if(0===i.observedAddresses.length)throw wpe("B sent no multiaddrs"),new Pq("DCUtR connect message had no multiaddrs",F5.ERR_INVALID_MESSAGE);const o=this.getDialableMultiaddrs(i.observedAddresses);if(0===o.length)throw wpe("B had no dialable multiaddrs"),new Pq("DCUtR connect message had no dialable multiaddrs",F5.ERR_INVALID_MESSAGE);wpe("A sending connect"),await r.write({type:vpe.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map((e=>e.bytes))}),wpe("A receiving sync");if((await r.read(n)).type!==vpe.Type.SYNC)throw new Pq("DCUtR message type was incorrect",F5.ERR_INVALID_MESSAGE);wpe("A dialing",o);const s=await this.connectionManager.openConnection(o,{signal:n.signal,priority:100,force:!0});wpe("DCUtR to %p succeeded via %a, closing relayed connection",t.remotePeer,s.remoteAddr),await t.close(n)}catch(r){wpe.error("incoming DCUtR from %p failed",t.remotePeer,r),e.abort(r)}finally{await e.close(n)}}getDialableMultiaddrs(e){const t=[];for(const n of e)if(null!=n&&0!==n.length)try{const e=(0,og.HM)(n);if(!bpe(e,this.transportManager))continue;t.push(e)}catch{}return t}}const Cpe="/libp2p/dcutr";function Tpe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new Ipe(t,e)}const kpe="js-libp2p/".concat("0.46.21");var Rpe;!function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==n.lengthDelimited&&t.fork(),null!=e.protocolVersion&&(t.uint32(42),t.string(e.protocolVersion)),null!=e.agentVersion&&(t.uint32(50),t.string(e.agentVersion)),null!=e.publicKey&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.listenAddrs)for(const r of e.listenAddrs)t.uint32(18),t.bytes(r);if(null!=e.observedAddr&&(t.uint32(34),t.bytes(e.observedAddr)),null!=e.protocols)for(const r of e.protocols)t.uint32(26),t.string(r);null!=e.signedPeerRecord&&(t.uint32(66),t.bytes(e.signedPeerRecord)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={listenAddrs:[],protocols:[]},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 5:n.protocolVersion=e.string();break;case 6:n.agentVersion=e.string();break;case 1:n.publicKey=e.bytes();break;case 2:n.listenAddrs.push(e.bytes());break;case 4:n.observedAddr=e.bytes();break;case 3:n.protocols.push(e.string());break;case 8:n.signedPeerRecord=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Rpe||(Rpe={}));const xpe=8192,Ppe={protocolPrefix:"ipfs",agentVersion:kpe,timeout:6e4,maxInboundStreams:1,maxOutboundStreams:1,maxPushIncomingStreams:1,maxPushOutgoingStreams:1,maxObservedAddresses:10,maxIdentifyMessageSize:8192,runOnConnectionOpen:!0,runOnTransientConnection:!0};var Dpe=new WeakMap,Ope=new WeakSet;class Npe{constructor(e,t){var n,r,i,o,s,a,c,l,u,h,d,f,p;Jd(this,Ope),(0,Yo.Z)(this,"identifyProtocolStr",void 0),(0,Yo.Z)(this,"identifyPushProtocolStr",void 0),(0,Yo.Z)(this,"host",void 0),(0,Yo.Z)(this,"started",void 0),(0,Yo.Z)(this,"timeout",void 0),(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"registrar",void 0),(0,Yo.Z)(this,"connectionManager",void 0),(0,Yo.Z)(this,"addressManager",void 0),(0,Yo.Z)(this,"maxInboundStreams",void 0),(0,Yo.Z)(this,"maxOutboundStreams",void 0),(0,Yo.Z)(this,"maxPushIncomingStreams",void 0),(0,Yo.Z)(this,"maxPushOutgoingStreams",void 0),(0,Yo.Z)(this,"maxIdentifyMessageSize",void 0),(0,Yo.Z)(this,"maxObservedAddresses",void 0),(0,Yo.Z)(this,"events",void 0),(0,Yo.Z)(this,"runOnTransientConnection",void 0),(0,_x.Z)(this,Dpe,{writable:!0,value:void 0}),this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.connectionManager=e.connectionManager,this.events=e.events,eW(this,Dpe,e.logger.forComponent("libp2p:identify")),this.identifyProtocolStr="/".concat(null!==(n=t.protocolPrefix)&&void 0!==n?n:Ppe.protocolPrefix,"/").concat("id","/").concat("1.0.0"),this.identifyPushProtocolStr="/".concat(null!==(r=t.protocolPrefix)&&void 0!==r?r:Ppe.protocolPrefix,"/").concat("id/push","/").concat("1.0.0"),this.timeout=null!==(i=t.timeout)&&void 0!==i?i:Ppe.timeout,this.maxInboundStreams=null!==(o=t.maxInboundStreams)&&void 0!==o?o:Ppe.maxInboundStreams,this.maxOutboundStreams=null!==(s=t.maxOutboundStreams)&&void 0!==s?s:Ppe.maxOutboundStreams,this.maxPushIncomingStreams=null!==(a=t.maxPushIncomingStreams)&&void 0!==a?a:Ppe.maxPushIncomingStreams,this.maxPushOutgoingStreams=null!==(c=t.maxPushOutgoingStreams)&&void 0!==c?c:Ppe.maxPushOutgoingStreams,this.maxIdentifyMessageSize=null!==(l=t.maxIdentifyMessageSize)&&void 0!==l?l:Ppe.maxIdentifyMessageSize,this.maxObservedAddresses=null!==(u=t.maxObservedAddresses)&&void 0!==u?u:Ppe.maxObservedAddresses,this.runOnTransientConnection=null!==(h=t.runOnTransientConnection)&&void 0!==h?h:Ppe.runOnTransientConnection,this.host={protocolVersion:"".concat(null!==(d=t.protocolPrefix)&&void 0!==d?d:Ppe.protocolPrefix,"/").concat("0.1.0"),agentVersion:null!==(f=t.agentVersion)&&void 0!==f?f:Ppe.agentVersion},(null!==(p=t.runOnConnectionOpen)&&void 0!==p?p:Ppe.runOnConnectionOpen)&&e.events.addEventListener("connection:open",(e=>{const t=e.detail;this.identify(t).catch((e=>{(0,Ix.Z)(this,Dpe).error("error during identify trigged by connection:open",e)}))})),e.events.addEventListener("self:peer:update",(e=>{this.push().catch((e=>{(0,Ix.Z)(this,Dpe).error(e)}))})),this.host.agentVersion===kpe&&(SO||EO?this.host.agentVersion+=" UserAgent=".concat(globalThis.process.version):(wO||_O||AO||IO)&&(this.host.agentVersion+=" UserAgent=".concat(globalThis.navigator.userAgent)))}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:(0,mu.m)(this.host.agentVersion),ProtocolVersion:(0,mu.m)(this.host.protocolVersion)}}),await this.registrar.handle(this.identifyProtocolStr,(e=>{this._handleIdentify(e).catch((e=>{(0,Ix.Z)(this,Dpe).error(e)}))}),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnTransientConnection:this.runOnTransientConnection}),await this.registrar.handle(this.identifyPushProtocolStr,(e=>{this._handlePush(e).catch((e=>{(0,Ix.Z)(this,Dpe).error(e)}))}),{maxInboundStreams:this.maxPushIncomingStreams,maxOutboundStreams:this.maxPushOutgoingStreams,runOnTransientConnection:this.runOnTransientConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.identifyProtocolStr),await this.registrar.unhandle(this.identifyPushProtocolStr),this.started=!1}async pushToConnections(e){var t,n;const r=this.addressManager.getAddresses().map((e=>e.decapsulateCode((0,og.a_)("p2p").code))),i=new uk({peerId:this.peerId,multiaddrs:r}),o=await sk.seal(i,this.peerId),s=this.registrar.getProtocols(),a=await this.peerStore.get(this.peerId),c=(0,Su.B)(null!==(t=a.metadata.get("AgentVersion"))&&void 0!==t?t:(0,mu.m)(this.host.agentVersion)),l=(0,Su.B)(null!==(n=a.metadata.get("ProtocolVersion"))&&void 0!==n?n:(0,mu.m)(this.host.protocolVersion)),u=e.map((async e=>{let t;const n=AbortSignal.timeout(this.timeout);KJ(1/0,n);try{var i;t=await e.newStream([this.identifyPushProtocolStr],{signal:n,runOnTransientConnection:this.runOnTransientConnection});const a=hk(t,{maxDataLength:null!==(i=this.maxIdentifyMessageSize)&&void 0!==i?i:xpe}).pb(Rpe);await a.write({listenAddrs:r.map((e=>e.bytes)),signedPeerRecord:o.marshal(),protocols:s,agentVersion:c,protocolVersion:l},{signal:n}),await t.close({signal:n})}catch(u){var a;(0,Ix.Z)(this,Dpe).error("could not push identify update to peer",u),null===(a=t)||void 0===a||a.abort(u)}}));await Promise.all(u)}async push(){if(!this.isStarted())return;const e=[];await Promise.all(this.connectionManager.getConnections().map((async t=>{try{if(!(await this.peerStore.get(t.remotePeer)).protocols.includes(this.identifyPushProtocolStr))return;e.push(t)}catch(n){if(n.code!==F5.ERR_NOT_FOUND)throw n}}))),await this.pushToConnections(e)}async _identify(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null==n.signal){const e=AbortSignal.timeout(this.timeout);KJ(1/0,e),n={...n,signal:e}}try{var r;t=await e.newStream([this.identifyProtocolStr],{...n,runOnTransientConnection:this.runOnTransientConnection});const i=hk(t,{maxDataLength:null!==(r=this.maxIdentifyMessageSize)&&void 0!==r?r:xpe}).pb(Rpe),o=await i.read(n);return await t.close(n),o}catch(o){var i;throw(0,Ix.Z)(this,Dpe).error("error while reading identify message",o),null===(i=t)||void 0===i||i.abort(o),o}}async identify(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=await this._identify(e,n),{publicKey:i,protocols:o,observedAddr:s}=r;if(null==i)throw new Pq("public key was missing from identify message",F5.ERR_MISSING_PUBLIC_KEY);const a=await P1(i);if(!e.remotePeer.equals(a))throw new Pq("identified peer does not match the expected peer",F5.ERR_INVALID_PEER);if(this.peerId.equals(a))throw new Pq("identified peer is our own peer id?",F5.ERR_INVALID_PEER);const c=function(e){if(null!=e&&e.length>0)try{return(0,og.HM)(e)}catch{}}(s);return(0,Ix.Z)(this,Dpe).call(this,"identify completed for peer %p and protocols %o",a,o),(0,Ix.Z)(this,Dpe).call(this,"our observed address is %a",c),null!=c&&this.addressManager.getObservedAddrs().length<(null!==(t=this.maxObservedAddresses)&&void 0!==t?t:1/0)&&((0,Ix.Z)(this,Dpe).call(this,"storing our observed address %a",c),this.addressManager.addObservedAddr(c)),Xd(this,Ope,Bpe).call(this,e,r)}async _handleIdentify(e){const{connection:t,stream:n}=e,r=AbortSignal.timeout(this.timeout);KJ(1/0,r);try{var i;const e=null!==(i=this.peerId.publicKey)&&void 0!==i?i:new Uint8Array(0),o=await this.peerStore.get(this.peerId),s=this.addressManager.getAddresses().map((e=>e.decapsulateCode((0,og.a_)("p2p").code)));let a=o.peerRecordEnvelope;if(s.length>0&&null==a){const e=new uk({peerId:this.peerId,multiaddrs:s});a=(await sk.seal(e,this.peerId)).marshal().subarray()}let c=t.remoteAddr.bytes;gO.Iq.matches(t.remoteAddr)||(c=void 0);const l=hk(n).pb(Rpe);await l.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:e,listenAddrs:s.map((e=>e.bytes)),signedPeerRecord:a,observedAddr:c,protocols:o.protocols},{signal:r}),await n.close({signal:r})}catch(o){(0,Ix.Z)(this,Dpe).error("could not respond to identify request",o),n.abort(o)}}async _handlePush(e){const{connection:t,stream:n}=e;try{var r;if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const e={signal:AbortSignal.timeout(this.timeout)},i=hk(n,{maxDataLength:null!==(r=this.maxIdentifyMessageSize)&&void 0!==r?r:xpe}).pb(Rpe),o=await i.read(e);await n.close(e),await Xd(this,Ope,Bpe).call(this,t,o)}catch(i){return(0,Ix.Z)(this,Dpe).error("received invalid message",i),void n.abort(i)}(0,Ix.Z)(this,Dpe).call(this,"handled push from %p",t.remotePeer)}}async function Bpe(e,t){if((0,Ix.Z)(this,Dpe).call(this,"received identify from %p",e.remotePeer),null==t)throw new Pq("message was null or undefined","ERR_INVALID_MESSAGE");const n={};if(t.listenAddrs.length>0&&(n.addresses=t.listenAddrs.map((e=>({isCertified:!1,multiaddr:(0,og.HM)(e)})))),t.protocols.length>0&&(n.protocols=t.protocols),null!=t.publicKey){n.publicKey=t.publicKey;if(!(await P1(t.publicKey)).equals(e.remotePeer))throw new Pq("public key did not match remote PeerId","ERR_INVALID_PUBLIC_KEY")}let r;if(null!=t.signedPeerRecord){(0,Ix.Z)(this,Dpe).call(this,"received signedPeerRecord in push from %p",e.remotePeer);let i=t.signedPeerRecord;const s=await sk.openAndCertify(i,uk.DOMAIN);let a,c=uk.createFromProtobuf(s.payload);if(!c.peerId.equals(s.peerId))throw new Pq("signing key does not match PeerId in the PeerRecord","ERR_INVALID_SIGNING_KEY");if(!e.remotePeer.equals(c.peerId))throw new Pq("signing key does not match remote PeerId","ERR_INVALID_PEER_RECORD_KEY");try{a=await this.peerStore.get(c.peerId)}catch(o){if("ERR_NOT_FOUND"!==o.code)throw o}if(null!=a&&(n.metadata=a.metadata,null!=a.peerRecordEnvelope)){const e=await sk.createFromProtobuf(a.peerRecordEnvelope),t=uk.createFromProtobuf(e.payload);t.seqNumber>=c.seqNumber&&((0,Ix.Z)(this,Dpe).call(this,"sequence number was lower or equal to existing sequence number - stored: %d received: %d",t.seqNumber,c.seqNumber),c=t,i=a.peerRecordEnvelope)}n.peerRecordEnvelope=i,n.addresses=c.multiaddrs.map((e=>({isCertified:!0,multiaddr:e}))),r={seq:c.seqNumber,addresses:c.multiaddrs}}else(0,Ix.Z)(this,Dpe).call(this,"%p did not send a signed peer record",e.remotePeer);if((0,Ix.Z)(this,Dpe).call(this,"patching %p with",e.remotePeer,n),await this.peerStore.patch(e.remotePeer,n),null!=t.agentVersion||null!=t.protocolVersion){const n={};null!=t.agentVersion&&(n.AgentVersion=(0,mu.m)(t.agentVersion)),null!=t.protocolVersion&&(n.ProtocolVersion=(0,mu.m)(t.protocolVersion)),(0,Ix.Z)(this,Dpe).call(this,"merging %p metadata",e.remotePeer,n),await this.peerStore.merge(e.remotePeer,{metadata:n})}const i={peerId:e.remotePeer,protocolVersion:t.protocolVersion,agentVersion:t.agentVersion,publicKey:t.publicKey,listenAddrs:t.listenAddrs.map((e=>(0,og.HM)(e))),observedAddr:null==t.observedAddr?void 0:(0,og.HM)(t.observedAddr),protocols:t.protocols,signedPeerRecord:r,connection:e};return this.events.safeDispatchEvent("peer:identify",{detail:i}),i}function Lpe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new Npe(t,e)}const Mpe=xH("libp2p:ping");class Upe{constructor(e,t){var n,r,i,o,s;(0,Yo.Z)(this,"protocol",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"started",void 0),(0,Yo.Z)(this,"timeout",void 0),(0,Yo.Z)(this,"maxInboundStreams",void 0),(0,Yo.Z)(this,"maxOutboundStreams",void 0),(0,Yo.Z)(this,"runOnTransientConnection",void 0),this.components=e,this.started=!1,this.protocol="/".concat(null!==(n=t.protocolPrefix)&&void 0!==n?n:"ipfs","/").concat("ping","/").concat("1.0.0"),this.timeout=null!==(r=t.timeout)&&void 0!==r?r:1e4,this.maxInboundStreams=null!==(i=t.maxInboundStreams)&&void 0!==i?i:2,this.maxOutboundStreams=null!==(o=t.maxOutboundStreams)&&void 0!==o?o:1,this.runOnTransientConnection=null===(s=t.runOnTransientConnection)||void 0===s||s}async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnTransientConnection:this.runOnTransientConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){Mpe("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,n=Date.now();_G(t,t).catch((t=>{Mpe.error("incoming ping from %p failed with error",e.connection.remotePeer,t)})).finally((()=>{const t=Date.now()-n;Mpe("incoming ping from %p complete in %dms",e.connection.remotePeer,t)}))}async ping(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Mpe("pinging %p",e);const n=Date.now(),r=uJ(32),i=await this.components.connectionManager.openConnection(e,t);let o,s=()=>{};if(null==t.signal){const e=AbortSignal.timeout(this.timeout);t={...t,signal:e}}try{var a;o=await i.newStream(this.protocol,{...t,runOnTransientConnection:this.runOnTransientConnection}),s=()=>{var e;null===(e=o)||void 0===e||e.abort(new Pq("ping timeout",F5.ERR_TIMEOUT))},null===(a=t.signal)||void 0===a||a.addEventListener("abort",s,{once:!0});const e=await _G([r],o,(async e=>v4(e))),c=Date.now()-n;if(null==e)throw new Pq("Did not receive a ping ack after ".concat(c,"ms"),F5.ERR_WRONG_PING_ACK);if(!(0,Ms.f)(r,e.subarray()))throw new Pq("Received wrong ping ack after ".concat(c,"ms"),F5.ERR_WRONG_PING_ACK);return Mpe("ping %p complete in %dms",i.remotePeer,c),c}catch(u){var c;throw Mpe.error("error while pinging %p",i.remotePeer,u),null===(c=o)||void 0===c||c.abort(u),u}finally{var l;null===(l=t.signal)||void 0===l||l.removeEventListener("abort",s),null!=o&&await o.close()}}}function Fpe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new Upe(t,e)}const Kpe={list:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt","/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"]};async function jpe(e,t){var n;return t=null!==(n=t)&&void 0!==n?n:{},async function(e){const t=await J4(e);return!1!==e.start&&await t.start(),t}({datastore:e,...function(){return{addresses:{listen:["/webrtc"]},transports:[fpe({discoverRelays:1}),t=>new zde(t,e),rfe(),dfe(),UF()],connectionEncryption:[are()],streamMuxers:[Nre(),Qhe()],peerDiscovery:[zoe(Kpe)],services:{identify:Lpe(),autoNAT:Bfe(),pubsub:Mne(),dcutr:Tpe(),delegatedRouting:()=>nv("https://delegated-ipfs.dev"),dht:nhe({clientMode:!0,validators:{ipns:Pfe},selectors:{ipns:Tfe}}),ping:Fpe()}};var e}(),...t,start:!1})}const Zpe="2.1.0",zpe="helia",Vpe=xH("helia");async function Hpe(){var e,t;let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=null!==(e=n.datastore)&&void 0!==e?e:new ZH,i=null!==(t=n.blockstore)&&void 0!==t?t:new UV;let o;o=function(e){if(null==e)return!1;return["dial","dialProtocol","hangUp","handle","unhandle","getMultiaddrs","getProtocols"].every((t=>"function"===typeof e[t]))}(n.libp2p)?n.libp2p:await jpe(r,n.libp2p);const s=new ZY({...n,datastore:r,blockstore:i,libp2p:o});return!1!==n.start&&await s.start(),function(e){try{if(null==e.libp2p.services.identify.host.agentVersion.match(/js-libp2p\/\d+\.\d+\.\d+\sUserAgent=/))return;e.libp2p.services.identify.host.agentVersion="".concat(zpe,"/").concat(Zpe," ").concat(e.libp2p.services.identify.host.agentVersion)}catch(t){Vpe.error("could not add Helia to agent version",t)}}(s),s}function qpe(){return{forComponent:e=>Gpe(e)}}function Gpe(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return cf().enabled("".concat(e,":trace"))&&null!=cf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=cf()("".concat(e,":trace"))),Object.assign(cf()(e),{error:cf()("".concat(e,":error")),trace:t})}cf().formatters.b=e=>null==e?"undefined":vu.base58btc.baseEncode(e),cf().formatters.t=e=>null==e?"undefined":tH.base32.baseEncode(e),cf().formatters.m=e=>null==e?"undefined":Pu.base64.baseEncode(e),cf().formatters.p=e=>null==e?"undefined":e.toString(),cf().formatters.c=e=>null==e?"undefined":e.toString(),cf().formatters.k=e=>null==e?"undefined":e.toString(),cf().formatters.a=e=>null==e?"undefined":e.toString();const Wpe=e=>e;function Qpe(e,t){const n=e.getPeerId();if(null!=n){Vh(n).equals(t)&&(e=e.decapsulate((0,og.HM)("/p2p/".concat(t.toString()))))}return e}class Ype{constructor(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"listen",void 0),(0,Yo.Z)(this,"announce",void 0),(0,Yo.Z)(this,"observed",void 0),(0,Yo.Z)(this,"announceFilter",void 0);const{listen:r=[],announce:i=[]}=n;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map((e=>e.toString())),this.announce=new Set(i.map((e=>e.toString()))),this.observed=new Map,this.announceFilter=null!==(t=n.announceFilter)&&void 0!==t?t:Wpe,this._updatePeerStoreAddresses=function(e,t){let n;return function(){clearTimeout(n),n=setTimeout((function(){n=void 0,e()}),t)}}(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",(()=>{this._updatePeerStoreAddresses()})),e.events.addEventListener("transport:close",(()=>{this._updatePeerStoreAddresses()}))}_updatePeerStoreAddresses(){const e=this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter((e=>{let[t,n]=e;return n.confident})).map((e=>{let[t]=e;return(0,og.HM)(t)}))).map((e=>e.getPeerId()===this.components.peerId.toString()?e.decapsulate("/p2p/".concat(this.components.peerId.toString())):e));this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch((e=>{this.log.error("error updating addresses",e)}))}getListenAddrs(){return Array.from(this.listen).map((e=>(0,og.HM)(e)))}getAnnounceAddrs(){return Array.from(this.announce).map((e=>(0,og.HM)(e)))}getObservedAddrs(){return Array.from(this.observed).map((e=>{let[t]=e;return(0,og.HM)(t)}))}addObservedAddr(e){const t=(e=Qpe(e,this.components.peerId)).toString();this.observed.has(t)||this.observed.set(t,{confident:!1})}confirmObservedAddr(e){var t;const n=(e=Qpe(e,this.components.peerId)).toString(),r=(null!==(t=this.observed.get(n))&&void 0!==t?t:{confident:!1}).confident;this.observed.set(n,{confident:!0}),r||this._updatePeerStoreAddresses()}removeObservedAddr(e){const t=(e=Qpe(e,this.components.peerId)).toString();this.observed.delete(t)}getAddresses(){let e=this.getAnnounceAddrs().map((e=>e.toString()));0===e.length&&(e=this.components.transportManager.getAddrs().map((e=>e.toString()))),e=e.concat(Array.from(this.observed).filter((e=>{let[t,n]=e;return n.confident})).map((e=>{let[t]=e;return t})));const t=new Set(e);return this.announceFilter(Array.from(t).map((e=>(0,og.HM)(e)))).map((e=>{var t;return!0===(null===(t=e.protos().pop())||void 0===t?void 0:t.path)||e.getPeerId()===this.components.peerId.toString()?e:e.encapsulate("/p2p/".concat(this.components.peerId.toString()))}))}}class Jpe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"components",{}),(0,Yo.Z)(this,"_started",!1),this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;null==this.components.logger&&(this.components.logger=qpe())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter((e=>(0,pu.qK)(e))).map((async t=>{var n;await(null===(n=t[e])||void 0===n?void 0:n.call(t))})))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const Xpe=["metrics","connectionProtector"],$pe=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function ege(){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{const t=e.stringTuples();return(4===t[0][0]||41===t[0][0])&&Boolean(SS("".concat(t[0][1])))},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}}}function tge(e){try{const{address:t}=e.nodeAddress();return Boolean(SS(t))}catch{return!0}}function nge(e,t){const n=function(e,t){const n=tge(e.multiaddr),r=tge(t.multiaddr);return n&&!r?1:!n&&r?-1:0}(e,t);if(0!==n)return n;const r=function(e,t){const n=gO.dx.exactMatch(e.multiaddr),r=gO.dx.exactMatch(t.multiaddr);return n&&!r?1:!n&&r?-1:0}(e,t);if(0!==r)return r;const i=function(e,t){return e.isCertified&&!t.isCertified?-1:!e.isCertified&&t.isCertified?1:0}(e,t);return i}var rge,ige;!function(e){e.NOT_STARTED_YET="The libp2p node is not started yet",e.DHT_DISABLED="DHT is not available",e.PUBSUB_DISABLED="PubSub is not available",e.CONN_ENCRYPTION_REQUIRED="At least one connection encryption module is required",e.ERR_TRANSPORTS_REQUIRED="At least one transport module is required",e.ERR_PROTECTOR_REQUIRED="Private network is enforced, but no protector was provided",e.NOT_FOUND="Not found"}(rge||(rge={})),function(e){e.DHT_DISABLED="ERR_DHT_DISABLED",e.ERR_PUBSUB_DISABLED="ERR_PUBSUB_DISABLED",e.PUBSUB_NOT_STARTED="ERR_PUBSUB_NOT_STARTED",e.DHT_NOT_STARTED="ERR_DHT_NOT_STARTED",e.CONN_ENCRYPTION_REQUIRED="ERR_CONN_ENCRYPTION_REQUIRED",e.ERR_TRANSPORTS_REQUIRED="ERR_TRANSPORTS_REQUIRED",e.ERR_PROTECTOR_REQUIRED="ERR_PROTECTOR_REQUIRED",e.ERR_PEER_DIAL_INTERCEPTED="ERR_PEER_DIAL_INTERCEPTED",e.ERR_CONNECTION_INTERCEPTED="ERR_CONNECTION_INTERCEPTED",e.ERR_INVALID_PROTOCOLS_FOR_STREAM="ERR_INVALID_PROTOCOLS_FOR_STREAM",e.ERR_CONNECTION_ENDED="ERR_CONNECTION_ENDED",e.ERR_CONNECTION_FAILED="ERR_CONNECTION_FAILED",e.ERR_NODE_NOT_STARTED="ERR_NODE_NOT_STARTED",e.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",e.ERR_TOO_MANY_ADDRESSES="ERR_TOO_MANY_ADDRESSES",e.ERR_NO_VALID_ADDRESSES="ERR_NO_VALID_ADDRESSES",e.ERR_RELAYED_DIAL="ERR_RELAYED_DIAL",e.ERR_DIALED_SELF="ERR_DIALED_SELF",e.ERR_DISCOVERED_SELF="ERR_DISCOVERED_SELF",e.ERR_DUPLICATE_TRANSPORT="ERR_DUPLICATE_TRANSPORT",e.ERR_ENCRYPTION_FAILED="ERR_ENCRYPTION_FAILED",e.ERR_HOP_REQUEST_FAILED="ERR_HOP_REQUEST_FAILED",e.ERR_INVALID_KEY="ERR_INVALID_KEY",e.ERR_INVALID_MESSAGE="ERR_INVALID_MESSAGE",e.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",e.ERR_INVALID_PEER="ERR_INVALID_PEER",e.ERR_MUXER_UNAVAILABLE="ERR_MUXER_UNAVAILABLE",e.ERR_NOT_FOUND="ERR_NOT_FOUND",e.ERR_TRANSPORT_UNAVAILABLE="ERR_TRANSPORT_UNAVAILABLE",e.ERR_TRANSPORT_DIAL_FAILED="ERR_TRANSPORT_DIAL_FAILED",e.ERR_UNSUPPORTED_PROTOCOL="ERR_UNSUPPORTED_PROTOCOL",e.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED="ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED",e.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",e.ERR_SIGNATURE_NOT_VALID="ERR_SIGNATURE_NOT_VALID",e.ERR_FIND_SELF="ERR_FIND_SELF",e.ERR_NO_ROUTERS_AVAILABLE="ERR_NO_ROUTERS_AVAILABLE",e.ERR_CONNECTION_NOT_MULTIPLEXED="ERR_CONNECTION_NOT_MULTIPLEXED",e.ERR_NO_DIAL_TOKENS="ERR_NO_DIAL_TOKENS",e.ERR_INVALID_CMS="ERR_INVALID_CMS",e.ERR_MISSING_KEYS="ERR_MISSING_KEYS",e.ERR_NO_KEY="ERR_NO_KEY",e.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",e.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",e.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",e.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",e.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",e.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",e.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",e.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",e.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",e.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",e.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",e.ERR_MISSING_PUBLIC_KEY="ERR_MISSING_PUBLIC_KEY",e.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",e.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",e.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH",e.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",e.ERR_WRONG_PING_ACK="ERR_WRONG_PING_ACK",e.ERR_INVALID_RECORD="ERR_INVALID_RECORD",e.ERR_ALREADY_SUCCEEDED="ERR_ALREADY_SUCCEEDED",e.ERR_NO_HANDLER_FOR_PROTOCOL="ERR_NO_HANDLER_FOR_PROTOCOL",e.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS",e.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",e.ERR_CONNECTION_DENIED="ERR_CONNECTION_DENIED",e.ERR_TRANSFER_LIMIT_EXCEEDED="ERR_TRANSFER_LIMIT_EXCEEDED"}(ige||(ige={}));const oge={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:e=>e},connectionManager:{resolvers:{dnsaddr:M5},addressSorter:nge},transportManager:{faultTolerance:pu.P7.FATAL_ALL}};function sge(e){if((0,pu.I$)(e))return{peerId:e,multiaddrs:[]};let t;if(Array.isArray(e)||(e=[e]),e.length>0){const n=e[0].getPeerId();t=null==n?void 0:Vh(n),e.forEach((e=>{if(!(0,og.h2)(e))throw new pu.sv("Invalid Multiaddr",ige.ERR_INVALID_MULTIADDR);const n=e.getPeerId();if(null==n){if(null!=t)throw new pu.sv("Multiaddrs must all have the same peer id or have no peer id",ige.ERR_INVALID_PARAMETERS)}else{const e=Vh(n);if(null==t||!t.equals(e))throw new pu.sv("Multiaddrs must all have the same peer id or have no peer id",ige.ERR_INVALID_PARAMETERS)}}))}return{peerId:t,multiaddrs:e}}const age="last-dial-failure",cge={minConnections:5,maxQueueLength:100,autoDialConcurrency:25,autoDialPriority:0,autoDialInterval:5e3,autoDialPeerRetryThreshold:42e4,autoDialDiscoveredPeersDebounce:10};class lge{constructor(e,t){var n,r,i,o,s,a,c;let l;(0,Yo.Z)(this,"connectionManager",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"queue",void 0),(0,Yo.Z)(this,"minConnections",void 0),(0,Yo.Z)(this,"autoDialPriority",void 0),(0,Yo.Z)(this,"autoDialIntervalMs",void 0),(0,Yo.Z)(this,"autoDialMaxQueueLength",void 0),(0,Yo.Z)(this,"autoDialPeerRetryThresholdMs",void 0),(0,Yo.Z)(this,"autoDialDiscoveredPeersDebounce",void 0),(0,Yo.Z)(this,"autoDialInterval",void 0),(0,Yo.Z)(this,"started",void 0),(0,Yo.Z)(this,"running",void 0),(0,Yo.Z)(this,"log",void 0),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.minConnections=null!==(n=t.minConnections)&&void 0!==n?n:cge.minConnections,this.autoDialPriority=null!==(r=t.autoDialPriority)&&void 0!==r?r:cge.autoDialPriority,this.autoDialIntervalMs=null!==(i=t.autoDialInterval)&&void 0!==i?i:cge.autoDialInterval,this.autoDialMaxQueueLength=null!==(o=t.maxQueueLength)&&void 0!==o?o:cge.maxQueueLength,this.autoDialPeerRetryThresholdMs=null!==(s=t.autoDialPeerRetryThreshold)&&void 0!==s?s:cge.autoDialPeerRetryThreshold,this.autoDialDiscoveredPeersDebounce=null!==(a=t.autoDialDiscoveredPeersDebounce)&&void 0!==a?a:cge.autoDialDiscoveredPeersDebounce,this.log=e.logger.forComponent("libp2p:connection-manager:auto-dial"),this.started=!1,this.running=!1,this.queue=new kx({concurrency:null!==(c=t.autoDialConcurrency)&&void 0!==c?c:cge.autoDialConcurrency}),this.queue.addListener("error",(e=>{this.log.error("error during auto-dial",e)})),e.events.addEventListener("connection:close",(()=>{this.autoDial().catch((e=>{this.log.error(e)}))})),e.events.addEventListener("peer:discovery",(()=>{clearTimeout(l),l=setTimeout((()=>{this.autoDial().catch((e=>{this.log.error(e)}))}),this.autoDialDiscoveredPeersDebounce)}))}isStarted(){return this.started}start(){this.autoDialInterval=setTimeout((()=>{this.autoDial().catch((e=>{this.log.error("error while autodialing",e)}))}),this.autoDialIntervalMs),this.started=!0}afterStart(){this.autoDial().catch((e=>{this.log.error("error while autodialing",e)}))}stop(){this.queue.clear(),clearTimeout(this.autoDialInterval),this.started=!1,this.running=!1}async autoDial(){if(!this.started)return;const e=this.connectionManager.getConnectionsMap(),t=e.size;if(t>=this.minConnections)return void(this.minConnections>0&&this.log.trace("have enough connections %d/%d",t,this.minConnections));if(this.queue.size>this.autoDialMaxQueueLength)return void this.log("not enough connections %d/%d but auto dial queue is full",t,this.minConnections);if(this.running)return void this.log("not enough connections %d/%d - but skipping autodial as it is already running",t,this.minConnections);this.running=!0,this.log("not enough connections %d/%d - will dial peers to increase the number of connections",t,this.minConnections);const n=new Ax(this.connectionManager.getDialQueue().map((e=>e.peerId)).filter(Boolean)),r=await this.peerStore.all({filters:[t=>0===t.addresses.length?(this.log.trace("not autodialing %p because they have no addresses",t.id),!1):e.has(t.id)?(this.log.trace("not autodialing %p because they are already connected",t.id),!1):n.has(t.id)?(this.log.trace("not autodialing %p because they are already being dialed",t.id),!1):!this.queue.hasJob(t.id)||(this.log.trace("not autodialing %p because they are already being autodialed",t.id),!1)]}),i=r.sort((()=>Math.random()>.5?1:-1)),o=new Ex;for(const a of i)o.has(a.id)||o.set(a.id,[...a.tags.values()].reduce(((e,t)=>e+t.value),0));const s=i.sort(((e,t)=>{var n,r;const i=null!==(n=o.get(e.id))&&void 0!==n?n:0,s=null!==(r=o.get(t.id))&&void 0!==r?r:0;return i>s?-1:i<s?1:0})).filter((e=>{const t=e.metadata.get(age);if(null==t)return!0;const n=parseInt((0,Su.B)(t));return!!isNaN(n)||Date.now()-n>this.autoDialPeerRetryThresholdMs}));this.log("selected %d/%d peers to dial",s.length,r.length);for(const a of s)this.queue.add((async()=>{const e=this.connectionManager.getConnectionsMap().size;if(e>=this.minConnections)return this.log("got enough connections now %d/%d",e,this.minConnections),void this.queue.clear();this.log("connecting to a peerStore stored peer %p",a.id),await this.connectionManager.openConnection(a.id,{priority:this.autoDialPriority})}),{peerId:a.id}).catch((e=>{this.log.error("could not connect to peerStore stored peer",e)}));this.running=!1,this.started&&(this.autoDialInterval=setTimeout((()=>{this.autoDial().catch((e=>{this.log.error("error while autodialing",e)}))}),this.autoDialIntervalMs))}}const uge={maxConnections:100,allow:[]};class hge{constructor(e){var t,n;let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"maxConnections",void 0),(0,Yo.Z)(this,"connectionManager",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"allow",void 0),(0,Yo.Z)(this,"events",void 0),(0,Yo.Z)(this,"log",void 0),this.maxConnections=null!==(t=r.maxConnections)&&void 0!==t?t:uge.maxConnections,this.allow=null!==(n=r.allow)&&void 0!==n?n:uge.allow,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),e.events.addEventListener("connection:open",(()=>{this.maybePruneConnections().catch((e=>{this.log.error(e)}))}))}async maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,n=Math.max(t-this.maxConnections,0);if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;this.log("max connections limit exceeded %d/%d, pruning %d connection(s)",t,this.maxConnections,n);const r=new Ex;for(const a of e){const e=a.remotePeer;if(!r.has(e)){r.set(e,0);try{const t=await this.peerStore.get(e);r.set(e,[...t.tags.values()].reduce(((e,t)=>e+t.value),0))}catch(s){"ERR_NOT_FOUND"!==s.code&&this.log.error("error loading peer tags",s)}}}const i=e.sort(((e,t)=>{var n,i;const o=null!==(n=r.get(e.remotePeer))&&void 0!==n?n:0,s=null!==(i=r.get(t.remotePeer))&&void 0!==i?i:0;if(o>s)return 1;if(o<s)return-1;const a=e.timeline.open,c=t.timeline.open;return a<c?1:a>c?-1:0})),o=[];for(const a of i){this.log("too many connections open - closing a connection to %p",a.remotePeer);if(this.allow.some((e=>a.remoteAddr.toString().startsWith(e.toString())))||o.push(a),o.length===n)break}await Promise.all(o.map((async e=>{try{await e.close()}catch(s){this.log.error(s)}}))),this.events.safeDispatchEvent("connection:prune",{detail:o})}}function dge(e){const t=new globalThis.AbortController;function n(){t.abort();for(const t of e)null!=(null===t||void 0===t?void 0:t.removeEventListener)&&t.removeEventListener("abort",n)}for(const i of e){if(!0===(null===i||void 0===i?void 0:i.aborted)){n();break}null!=(null===i||void 0===i?void 0:i.addEventListener)&&i.addEventListener("abort",n)}const r=t.signal;return r.clear=function(){for(const t of e)null!=(null===t||void 0===t?void 0:t.removeEventListener)&&t.removeEventListener("abort",n)},r}async function fge(e,t){if(!e.protoNames().includes("dnsaddr"))return[e];const n=await async function(e,t){try{e=(0,og.HM)(e.toString());return await e.resolve(t)}catch(n){return t.log.error("multiaddr ".concat(e.toString()," could not be resolved"),n),[]}}(e,t),r=(await Promise.all(n.map((async e=>fge(e,t))))).flat().reduce(((e,t)=>(null==e.find((e=>e.equals(t)))&&e.push(t),e)),[]);return t.log("resolved %s to",e,r.map((e=>e.toString()))),r}const pge={addressSorter:nge,maxParallelDials:50,maxPeerAddrsToDial:25,dialTimeout:3e4,resolvers:{dnsaddr:M5}};class gge{constructor(e){var t,n,r,i,o,s,a;let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"pendingDials",void 0),(0,Yo.Z)(this,"queue",void 0),(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"connectionGater",void 0),(0,Yo.Z)(this,"transportManager",void 0),(0,Yo.Z)(this,"addressSorter",void 0),(0,Yo.Z)(this,"maxPeerAddrsToDial",void 0),(0,Yo.Z)(this,"dialTimeout",void 0),(0,Yo.Z)(this,"inProgressDialCount",void 0),(0,Yo.Z)(this,"pendingDialCount",void 0),(0,Yo.Z)(this,"shutDownController",void 0),(0,Yo.Z)(this,"connections",void 0),(0,Yo.Z)(this,"log",void 0),this.addressSorter=null!==(t=c.addressSorter)&&void 0!==t?t:pge.addressSorter,this.maxPeerAddrsToDial=null!==(n=c.maxPeerAddrsToDial)&&void 0!==n?n:pge.maxPeerAddrsToDial,this.dialTimeout=null!==(r=c.dialTimeout)&&void 0!==r?r:pge.dialTimeout,this.connections=null!==(i=c.connections)&&void 0!==i?i:new Ex,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.connectionGater=e.connectionGater,this.transportManager=e.transportManager,this.shutDownController=new AbortController,(0,pu.Wp)(1/0,this.shutDownController.signal),this.pendingDialCount=null===(o=e.metrics)||void 0===o?void 0:o.registerMetric("libp2p_dial_queue_pending_dials"),this.inProgressDialCount=null===(s=e.metrics)||void 0===s?void 0:s.registerMetric("libp2p_dial_queue_in_progress_dials"),this.pendingDials=[];for(const[u,h]of Object.entries(null!==(l=c.resolvers)&&void 0!==l?l:{})){var l;og.s_.set(u,h)}this.queue=new Fm.Z({concurrency:null!==(a=c.maxParallelDials)&&void 0!==a?a:pge.maxParallelDials}),this.queue.on("add",(()=>{var e,t;null===(e=this.pendingDialCount)||void 0===e||e.update(this.queue.size),null===(t=this.inProgressDialCount)||void 0===t||t.update(this.queue.pending)})),this.queue.on("active",(()=>{var e,t;null===(e=this.pendingDialCount)||void 0===e||e.update(this.queue.size),null===(t=this.inProgressDialCount)||void 0===t||t.update(this.queue.pending)})),this.queue.on("completed",(()=>{var e,t;null===(e=this.pendingDialCount)||void 0===e||e.update(this.queue.size),null===(t=this.inProgressDialCount)||void 0===t||t.update(this.queue.pending)})),this.queue.on("error",(e=>{var t,n;this.log.error("error in dial queue",e),null===(t=this.pendingDialCount)||void 0===t||t.update(this.queue.size),null===(n=this.inProgressDialCount)||void 0===n||n.update(this.queue.pending)})),this.queue.on("empty",(()=>{var e,t;null===(e=this.pendingDialCount)||void 0===e||e.update(this.queue.size),null===(t=this.inProgressDialCount)||void 0===t||t.update(this.queue.pending)})),this.queue.on("idle",(()=>{var e,t;null===(e=this.pendingDialCount)||void 0===e||e.update(this.queue.size),null===(t=this.inProgressDialCount)||void 0===t||t.update(this.queue.pending)}))}stop(){this.shutDownController.abort()}async dial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{peerId:n,multiaddrs:r}=sge(e),i=r.map((e=>({multiaddr:e,isCertified:!1}))),o=this.createDialAbortControllers(t.signal);let s;try{s=await this.calculateMultiaddrs(n,i,{...t,signal:o})}catch(h){throw o.clear(),h}let a=Array.from(this.connections.values()).flat().find((e=>!0!==t.force&&s.find((t=>t.multiaddr.equals(e.remoteAddr)))));if(null!=a)return this.log("already connected to %a",a.remoteAddr),a;const c=this.pendingDials.find((e=>!(null==e.peerId||null==n||!e.peerId.equals(n))||s.map((e=>{let{multiaddr:t}=e;return t.toString()})).join()===e.multiaddrs.map((e=>e.toString())).join()));if(null!=c)return this.log("joining existing dial target for %p",n),o.clear(),c.promise;this.log("creating dial target for",s.map((e=>{let{multiaddr:t}=e;return t.toString()})));const l={id:"".concat(parseInt(String(1e9*Math.random()),10).toString()).concat(Date.now()),status:"queued",peerId:n,multiaddrs:s.map((e=>{let{multiaddr:t}=e;return t}))};l.promise=this.performDial(l,{...t,signal:o}).finally((()=>{this.pendingDials=this.pendingDials.filter((e=>e.id!==l.id)),o.clear()})).catch((async e=>{if(this.log.error("dial failed to %s",l.multiaddrs.map((e=>e.toString())).join(", "),e),null!=n)try{await this.peerStore.patch(n,{metadata:{[age]:(0,mu.m)(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",n,e)}if(o.aborted){throw new pu.sv(e.message,pu.l9)}throw e})),this.pendingDials.push(l);const u=await l.promise;return a=Array.from(this.connections.values()).flat().find((e=>!0!==t.force&&(e.id!==u.id&&e.remoteAddr.equals(u.remoteAddr)))),null!=a?(this.log("already connected to %a",a.remoteAddr),await u.close(),a):(this.log("connection opened to %a",u.remoteAddr),u)}createDialAbortControllers(e){const t=dge([AbortSignal.timeout(this.dialTimeout),this.shutDownController.signal,e]);try{null===pu.Wp||void 0===pu.Wp||(0,pu.Wp)(1/0,t)}catch{}return t}async calculateMultiaddrs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(null!=e){var r,i;if(this.peerId.equals(e))throw new pu.sv("Tried to dial self",ige.ERR_DIALED_SELF);if(!0===await(null===(r=(i=this.connectionGater).denyDialPeer)||void 0===r?void 0:r.call(i,e)))throw new pu.sv("The dial request is blocked by gater.allowDialPeer",ige.ERR_PEER_DIAL_INTERCEPTED);if(0===t.length){this.log("loading multiaddrs for %p",e);try{const n=await this.peerStore.get(e);t.push(...n.addresses),this.log("loaded multiaddrs for %p",e,t.map((e=>{let{multiaddr:t}=e;return t.toString()})))}catch(h){if(h.code!==ige.ERR_NOT_FOUND)throw h}}}let o=(await Promise.all(t.map((async e=>{const t=await fge(e.multiaddr,{...n,log:this.log});return 1===t.length&&t[0].equals(e.multiaddr)?e:t.map((e=>({multiaddr:e,isCertified:!1})))})))).flat();if(null!=e){const t="/p2p/".concat(e.toString());o=o.map((e=>{const n=e.multiaddr.protos().pop();return!0===(null===n||void 0===n?void 0:n.path)?e:null==e.multiaddr.getPeerId()?{multiaddr:e.multiaddr.encapsulate(t),isCertified:e.isCertified}:e}))}const s=o.filter((t=>{if(null==this.transportManager.transportForMultiaddr(t.multiaddr))return!1;const n=t.multiaddr.getPeerId();return null==e||null==n||e.equals(n)})),a=new Map;for(const d of s){const e=d.multiaddr.toString(),t=a.get(e);null==t?a.set(e,d):t.isCertified=t.isCertified||d.isCertified||!1}const c=[...a.values()];if((0===c.length||c.length>this.maxPeerAddrsToDial)&&(this.log("addresses for %p before filtering",null!==e&&void 0!==e?e:"unknown peer",o.map((e=>{let{multiaddr:t}=e;return t.toString()}))),this.log("addresses for %p after filtering",null!==e&&void 0!==e?e:"unknown peer",c.map((e=>{let{multiaddr:t}=e;return t.toString()})))),0===c.length)throw new pu.sv("The dial request has no valid addresses",ige.ERR_NO_VALID_ADDRESSES);if(c.length>this.maxPeerAddrsToDial)throw new pu.sv("dial with more addresses than allowed",ige.ERR_TOO_MANY_ADDRESSES);const l=[];for(const d of c)null!=this.connectionGater.denyDialMultiaddr&&await this.connectionGater.denyDialMultiaddr(d.multiaddr)||l.push(d);const u=l.sort(this.addressSorter);if(0===u.length)throw new pu.sv("The connection gater denied all addresses in the dial request",ige.ERR_NO_VALID_ADDRESSES);return u}async performDial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.multiaddrs.map((()=>new AbortController));try{const r=new Fm.Z({concurrency:1});r.on("error",(t=>{this.log.error("error dialing %s %o",e.multiaddrs,t)}));const i=await Promise.any(e.multiaddrs.map((async(i,o)=>{const s=n[o];if(null==s)throw new pu.sv("dialAction did not come with an AbortController",ige.ERR_INVALID_PARAMETERS);const a=function(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const o of n)null!=o&&((0,pu.Wp)(1/0,o),e.push(o));const i=dge(e);return(0,pu.Wp)(1/0,i),i}(s.signal,t.signal);a.addEventListener("abort",(()=>{this.log("dial to %a aborted",i)}));const c=Ws();return await r.add((async()=>{if(a.aborted)return this.log("dial to %a was aborted before reaching the head of the peer dial queue",i),void c.reject(new pu._L);await this.queue.add((async()=>{try{if(a.aborted)return this.log("dial to %a was aborted before reaching the head of the dial queue",i),void c.reject(new pu._L);e.status="active";const r=await this.transportManager.dial(i,{...t,signal:a});if(s.signal.aborted)return this.log("multiple dials succeeded, closing superfluous connection"),r.close().catch((e=>{this.log.error("error closing superfluous connection",e)})),void c.reject(new pu._L);n[o]=void 0,n.forEach((e=>{void 0!==e&&e.abort()})),this.log("dial to %a succeeded",i),c.resolve(r)}catch(r){this.log.error("error during dial of %a",i,r),c.reject(r)}}),{...t,signal:a}).catch((e=>{c.reject(e)}))}),{signal:a}).catch((e=>{c.reject(e)})).finally((()=>{a.clear()})),c.promise})));if(null==i)throw new pu.sv("successful dial led to empty object returned from peer dial queue",ige.ERR_TRANSPORT_DIAL_FAILED);return e.status="success",i}catch(r){if(e.status="error",1===e.multiaddrs.length&&"AggregateError"===r.name)throw r.errors[0];throw r}}}const yge=5,mge=100,vge=5,bge=10,wge=25,Ege=0,Age=100;class Sge{constructor(e){var t,n,r,i,o,s,a,c,l,u,h,d,f,p;let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"started",void 0),(0,Yo.Z)(this,"connections",void 0),(0,Yo.Z)(this,"allow",void 0),(0,Yo.Z)(this,"deny",void 0),(0,Yo.Z)(this,"maxIncomingPendingConnections",void 0),(0,Yo.Z)(this,"incomingPendingConnections",void 0),(0,Yo.Z)(this,"maxConnections",void 0),(0,Yo.Z)(this,"dialQueue",void 0),(0,Yo.Z)(this,"autoDial",void 0),(0,Yo.Z)(this,"connectionPruner",void 0),(0,Yo.Z)(this,"inboundConnectionRateLimiter",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,"events",void 0),(0,Yo.Z)(this,"log",void 0),this.maxConnections=null!==(t=g.maxConnections)&&void 0!==t?t:mge;const y=null!==(n=g.minConnections)&&void 0!==n?n:yge;if(this.maxConnections<y)throw new pu.sv("Connection Manager maxConnections must be greater than minConnections",ige.ERR_INVALID_PARAMETERS);this.connections=new Ex,this.started=!1,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),this.allow=(null!==(r=g.allow)&&void 0!==r?r:[]).map((e=>(0,og.HM)(e))),this.deny=(null!==(i=g.deny)&&void 0!==i?i:[]).map((e=>(0,og.HM)(e))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=null!==(o=g.maxIncomingPendingConnections)&&void 0!==o?o:bge,this.inboundConnectionRateLimiter=new j5.RateLimiterMemory({points:null!==(s=g.inboundConnectionThreshold)&&void 0!==s?s:vge,duration:1}),this.autoDial=new lge({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{minConnections:y,autoDialConcurrency:null!==(a=g.autoDialConcurrency)&&void 0!==a?a:wge,autoDialPriority:null!==(c=g.autoDialPriority)&&void 0!==c?c:Ege,maxQueueLength:null!==(l=g.autoDialMaxQueueLength)&&void 0!==l?l:Age}),this.connectionPruner=new hge({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:this.allow}),this.dialQueue=new gge({peerId:e.peerId,metrics:e.metrics,peerStore:e.peerStore,transportManager:e.transportManager,connectionGater:e.connectionGater,logger:e.logger},{addressSorter:null!==(u=g.addressSorter)&&void 0!==u?u:nge,maxParallelDials:null!==(h=g.maxParallelDials)&&void 0!==h?h:50,maxPeerAddrsToDial:null!==(d=g.maxPeerAddrsToDial)&&void 0!==d?d:25,dialTimeout:null!==(f=g.dialTimeout)&&void 0!==f?f:3e4,resolvers:null!==(p=g.resolvers)&&void 0!==p?p:{dnsaddr:M5},connections:this.connections})}isStarted(){return this.started}async start(){var e,t,n;null===(e=this.metrics)||void 0===e||e.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,outbound:0};for(const t of this.connections.values())for(const n of t)"inbound"===n.direction?e.inbound++:e.outbound++;return e}}),null===(t=this.metrics)||void 0===t||t.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const r of this.connections.values())for(const i of r)for(const r of i.streams){var t,n;const i="".concat(r.direction," ").concat(null!==(t=r.protocol)&&void 0!==t?t:"unnegotiated");e[i]=(null!==(n=e[i])&&void 0!==n?n:0)+1}return e}}),null===(n=this.metrics)||void 0===n||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const o of this.connections.values())for(const i of o){const o={};for(const e of i.streams){var t,n;const r="".concat(e.direction," ").concat(null!==(t=e.protocol)&&void 0!==t?t:"unnegotiated");o[r]=(null!==(n=o[r])&&void 0!==n?n:0)+1}for(const[t,n]of Object.entries(o)){var r;e[t]=null!==(r=e[t])&&void 0!==r?r:[],e[t].push(n)}}const i={};for(let[o,s]of Object.entries(e)){s=s.sort(((e,t)=>e-t));const e=Math.floor(.9*s.length);i[o]=s[e]}return i}}),this.autoDial.start(),this.started=!0,this.log("started")}async afterStart(){Promise.resolve().then((async()=>{const e=await this.peerStore.all({filters:[e=>e.tags.has("keep-alive")]});await Promise.all(e.map((async e=>{await this.openConnection(e.id).catch((e=>{this.log.error(e)}))})))})).catch((e=>{this.log.error(e)})),this.autoDial.afterStart()}async stop(){this.dialQueue.stop(),this.autoDial.stop();const e=[];for(const t of this.connections.values())for(const n of t)e.push((async()=>{try{await n.close()}catch(e){this.log.error(e)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}onConnect(e){this._onConnect(e).catch((e=>{this.log.error(e)}))}async _onConnect(e){const{detail:t}=e;if(!this.started)return void await t.close();const n=t.remotePeer,r=this.connections.get(n);let i=!1;null!=r?r.push(t):(i=!0,this.connections.set(n,[t])),null!=n.publicKey&&"RSA"===n.type&&await this.peerStore.patch(n,{publicKey:n.publicKey}),i&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e;if(!this.started)return;const n=t.remotePeer;let r=this.connections.get(n);null!=r&&r.length>1?(r=r.filter((e=>e.id!==t.id)),this.connections.set(n,r)):null!=r&&(this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){var t;if(null!=e)return null!==(t=this.connections.get(e))&&void 0!==t?t:[];let n=[];for(const r of this.connections.values())n=n.concat(r);return n}getConnectionsMap(){return this.connections}async openConnection(e){var t,n;let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isStarted())throw new pu.sv("Not started",ige.ERR_NODE_NOT_STARTED);null===(t=r.signal)||void 0===t||t.throwIfAborted();const{peerId:i}=sge(e);if(null!=i&&!0!==r.force){this.log("dial %p",i);const e=this.getConnections(i).find((e=>!e.transient));if(null!=e)return this.log("had an existing non-transient connection to %p",i),e}const o=await this.dialQueue.dial(e,{...r,priority:null!==(n=r.priority)&&void 0!==n?n:50});let s=this.connections.get(o.remotePeer);null==s&&(s=[],this.connections.set(o.remotePeer,s));let a=!1;for(const c of s)c.id===o.id&&(a=!0);return a||s.push(o),o}async closeConnections(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=null!==(t=this.connections.get(e))&&void 0!==t?t:[];await Promise.all(r.map((async e=>{try{await e.close(n)}catch(t){e.abort(t)}})))}async acceptIncomingConnection(e){if(this.deny.some((t=>e.remoteAddr.toString().startsWith(t.toString()))))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some((t=>e.remoteAddr.toString().startsWith(t.toString()))))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const t=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(t,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,t),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){return this.dialQueue.pendingDials}}const _ge=function(e,t){if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)yield t(n)}();const n=WV(e),{value:r,done:i}=n.next();if(!0===i)return function*(){}();const o=t(r);if("function"===typeof o.then)return async function*(){yield await o;for await(const e of n)yield t(e)}();const s=t;return function*(){yield o;for(const e of n)yield s(e)}()};async function*Ige(e,t){yield*_ge(e,(async e=>(await t.merge(e.id,{multiaddrs:e.multiaddrs}),e)))}function Cge(e){const t=new Set;return QV(e,(e=>!t.has(e.id.toString())&&(t.add(e.id.toString()),!0)))}function Tge(e){try{let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return async function*(){let n=0;for await(const t of e)n++,yield t;if(n<t)throw new pu.sv("more peers required, seen: ".concat(n,"  min: ").concat(t),"NOT_FOUND")}()}catch(t){return Promise.reject(t)}}class kge{constructor(e,t){var n;(0,Yo.Z)(this,"routers",void 0),(0,Yo.Z)(this,"started",void 0),(0,Yo.Z)(this,"components",void 0),this.routers=null!==(n=t.routers)&&void 0!==n?n:[],this.started=!1,this.components=e}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}findProviders(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){if(0===t.routers.length)throw new pu.sv("No content routers available",ige.ERR_NO_ROUTERS_AVAILABLE);yield*va(ma(...t.routers.map((t=>t.findProviders(e,n)))),(e=>Ige(e,t.components.peerStore)),(e=>Cge(e)),(e=>Tge(e)))}()}catch(n){return Promise.reject(n)}}async provide(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(0===this.routers.length)throw new pu.sv("No content routers available",ige.ERR_NO_ROUTERS_AVAILABLE);await Promise.all(this.routers.map((async n=>{await n.provide(e,t)})))}async put(e,t,n){if(!this.isStarted())throw new pu.sv(rge.NOT_STARTED_YET,ige.DHT_NOT_STARTED);await Promise.all(this.routers.map((async r=>{await r.put(e,t,n)})))}async get(e,t){if(!this.isStarted())throw new pu.sv(rge.NOT_STARTED_YET,ige.DHT_NOT_STARTED);return Promise.any(this.routers.map((async n=>n.get(e,t))))}}const Rge=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e)return t})();for(const t of e)return t};class xge{constructor(e,t){var n;(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"routers",void 0),this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=null!==(n=t.routers)&&void 0!==n?n:[]}async findPeer(e,t){if(0===this.routers.length)throw new pu.sv("No peer routers available",ige.ERR_NO_ROUTERS_AVAILABLE);if(e.toString()===this.peerId.toString())throw new pu.sv("Should not try to find self",ige.ERR_FIND_SELF);const n=this,r=await va(ma(...this.routers.map((r=>async function*(){try{yield await r.findPeer(e,t)}catch(i){n.log.error(i)}}()))),(e=>QV(e,Boolean)),(e=>Ige(e,this.peerStore)),(async e=>Rge(e)));if(null!=r)return r;throw new pu.sv(rge.NOT_FOUND,ige.ERR_NOT_FOUND)}async*getClosestPeers(e,t){if(0===this.routers.length)throw new pu.sv("No peer routers available",ige.ERR_NO_ROUTERS_AVAILABLE);yield*va(ma(...this.routers.map((n=>n.getClosestPeers(e,t)))),(e=>Ige(e,this.peerStore)),(e=>Cge(e)),(e=>Tge(e)))}}class Pge{constructor(e){(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"topologies",void 0),(0,Yo.Z)(this,"handlers",void 0),(0,Yo.Z)(this,"components",void 0),this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(null==t)throw new pu.sv("No handler registered for protocol ".concat(e),ige.ERR_NO_HANDLER_FOR_PROTOCOL);return t}getTopologies(e){const t=this.topologies.get(e);return null==t?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e))throw new pu.sv("Handler already registered for protocol ".concat(e),ige.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);const r=H0.Z.bind({ignoreUndefined:!0})({maxInboundStreams:32,maxOutboundStreams:64},n);this.handlers.set(e,{handler:t,options:r}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach((e=>{this.handlers.delete(e)})),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(null==t)throw new pu.sv("invalid topology",ige.ERR_INVALID_PARAMETERS);const n="".concat((1e9*Math.random()).toString(36)).concat(Date.now());let r=this.topologies.get(e);return null==r&&(r=new Map,this.topologies.set(e,r)),r.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),0===n.size&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then((e=>{for(const r of e.protocols){const e=this.topologies.get(r);if(null!=e)for(const r of e.values()){var n;null===(n=r.onDisconnect)||void 0===n||n.call(r,t)}}})).catch((e=>{e.code!==ige.ERR_NOT_FOUND&&this.log.error("could not inform topologies of disconnecting peer %p",t,e)}))}_onPeerUpdate(e){var t;const{peer:n,previous:r}=e.detail,i=(null!==(t=null===r||void 0===r?void 0:r.protocols)&&void 0!==t?t:[]).filter((e=>!n.protocols.includes(e)));for(const s of i){const e=this.topologies.get(s);if(null!=e)for(const t of e.values()){var o;null===(o=t.onDisconnect)||void 0===o||o.call(t,n.id)}}}_onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,r=e.detail.peerId;for(const o of t){const e=this.topologies.get(o);if(null!=e)for(const t of e.values()){var i;n.transient&&!0!==t.notifyOnTransient||(null===(i=t.onConnect)||void 0===i||i.call(t,r,n))}}}}class Dge extends Map{constructor(e){super(),(0,Yo.Z)(this,"metric",void 0);const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}class Oge{constructor(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"transports",void 0),(0,Yo.Z)(this,"listeners",void 0),(0,Yo.Z)(this,"faultTolerance",void 0),(0,Yo.Z)(this,"started",void 0),this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=function(e){const{name:t,metrics:n}=e;let r;return r=null!=n?new Dge({name:t,metrics:n}):new Map,r}({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=null!==(t=n.faultTolerance)&&void 0!==t?t:pu.P7.FATAL_ALL}add(e){const t=e[Symbol.toStringTag];if(null==t)throw new pu.sv("Transport must have a valid tag",ige.ERR_INVALID_KEY);if(this.transports.has(t))throw new pu.sv("There is already a transport with the tag ".concat(t),ige.ERR_DUPLICATE_TRANSPORT);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const t=n.pop();null!=t&&e.push(t.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const n=this.transportForMultiaddr(e);if(null==n)throw new pu.sv("No transport available for address ".concat(String(e)),ige.ERR_TRANSPORT_UNAVAILABLE);try{return await n.dial(e,{...t,upgrader:this.components.upgrader})}catch(r){throw null==r.code&&(r.code=ige.ERR_TRANSPORT_DIAL_FAILED),r}}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}transportForMultiaddr(e){for(const t of this.transports.values()){if(t.filter([e]).length>0)return t}}async listen(e){if(!this.isStarted())throw new pu.sv("Not started",ige.ERR_NODE_NOT_STARTED);if(null==e||0===e.length)return void this.log("no addresses were provided for listening, this node is dial only");const t=[];for(const[r,i]of this.transports.entries()){const o=i.filter(e),s=[];for(const e of o){var n;this.log("creating listener for %s on %a",r,e);const t=i.createListener({upgrader:this.components.upgrader});let o=null!==(n=this.listeners.get(r))&&void 0!==n?n:[];null==o&&(o=[],this.listeners.set(r,o)),o.push(t),t.addEventListener("listening",(()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:t})})),t.addEventListener("close",(()=>{const e=o.findIndex((e=>e===t));o.splice(e,1),this.components.events.safeDispatchEvent("transport:close",{detail:t})})),s.push(t.listen(e))}if(0===s.length){t.push(r);continue}if(null==(await Promise.allSettled(s)).find((e=>"fulfilled"===e.status))&&this.faultTolerance!==pu.P7.NO_FATAL)throw new pu.sv("Transport (".concat(r,") could not listen on any available address"),ige.ERR_NO_VALID_ADDRESSES)}if(t.length===this.transports.size){const e="no valid addresses were provided for transports [".concat(t.join(", "),"]");if(this.faultTolerance===pu.P7.FATAL_ALL)throw new pu.sv(e,ige.ERR_NO_VALID_ADDRESSES);this.log("libp2p in dial mode only: ".concat(e))}}async remove(e){var t;const n=null!==(t=this.listeners.get(e))&&void 0!==t?t:[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);n.length>0;){const e=n.pop();null!=e&&r.push(e.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}let Nge;Nge=Symbol.toStringTag;class Bge{constructor(e){var t;(0,Yo.Z)(this,"id",void 0),(0,Yo.Z)(this,"remoteAddr",void 0),(0,Yo.Z)(this,"remotePeer",void 0),(0,Yo.Z)(this,"direction",void 0),(0,Yo.Z)(this,"timeline",void 0),(0,Yo.Z)(this,"multiplexer",void 0),(0,Yo.Z)(this,"encryption",void 0),(0,Yo.Z)(this,"status",void 0),(0,Yo.Z)(this,"transient",void 0),(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"tags",void 0),(0,Yo.Z)(this,"_newStream",void 0),(0,Yo.Z)(this,"_close",void 0),(0,Yo.Z)(this,"_abort",void 0),(0,Yo.Z)(this,"_getStreams",void 0),(0,Yo.Z)(this,Nge,"Connection"),(0,Yo.Z)(this,pu.fL,!0);const{remoteAddr:n,remotePeer:r,newStream:i,close:o,abort:s,getStreams:a}=e;this.id="".concat(parseInt(String(1e9*Math.random())).toString(36)).concat(Date.now()),this.remoteAddr=n,this.remotePeer=r,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.transient=null!==(t=e.transient)&&void 0!==t&&t,this.log=e.logger.forComponent("libp2p:connection:".concat(this.direction,":").concat(this.id)),null==this.remoteAddr.getPeerId()&&(this.remoteAddr=this.remoteAddr.encapsulate("/p2p/".concat(this.remotePeer))),this._newStream=i,this._close=o,this._abort=s,this._getStreams=a,this.tags=[]}get streams(){return this._getStreams()}async newStream(e,t){if("closing"===this.status)throw new pu.sv("the connection is being closed","ERR_CONNECTION_BEING_CLOSED");if("closed"===this.status)throw new pu.sv("the connection is closed","ERR_CONNECTION_CLOSED");if(Array.isArray(e)||(e=[e]),this.transient&&!0!==(null===t||void 0===t?void 0:t.runOnTransientConnection))throw new pu.sv("Cannot open protocol stream on transient connection","ERR_TRANSIENT_CONNECTION");const n=await this._newStream(e,t);return n.direction="outbound",n}async close(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("closed"!==this.status&&"closing"!==this.status){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",null==e.signal){const t=AbortSignal.timeout(500);(0,pu.Wp)(1/0,t),e={...e,signal:t}}try{this.log.trace("closing all streams"),await Promise.all(this.streams.map((async t=>t.close(e)))),this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this.streams.forEach((t=>{t.abort(e)})),this.log.error("all streams aborted",this.streams.length),this._abort(e),this.timeline.close=Date.now(),this.status="closed"}}function Lge(e,t,n){let r=0;return n.streams.forEach((n=>{n.direction===t&&n.protocol===e&&r++})),r}class Mge{constructor(e,t){var n;(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"connectionEncryption",void 0),(0,Yo.Z)(this,"muxers",void 0),(0,Yo.Z)(this,"inboundUpgradeTimeout",void 0),(0,Yo.Z)(this,"events",void 0),(0,Yo.Z)(this,"log",void 0),this.components=e,this.connectionEncryption=new Map,this.log=e.logger.forComponent("libp2p:upgrader"),t.connectionEncryption.forEach((e=>{this.connectionEncryption.set(e.protocol,e)})),this.muxers=new Map,t.muxers.forEach((e=>{this.muxers.set(e.protocol,e)})),this.inboundUpgradeTimeout=null!==(n=t.inboundUpgradeTimeout)&&void 0!==n?n:3e4,this.events=e.events}async shouldBlockConnection(e,t,n){const r=this.components.connectionGater[n];if(void 0!==r&&await r(e,t))throw new pu.sv("The multiaddr connection is blocked by gater.".concat(n),ige.ERR_CONNECTION_INTERCEPTED)}async upgradeInbound(e,t){if(!await this.components.connectionManager.acceptIncomingConnection(e))throw new pu.sv("connection denied",ige.ERR_CONNECTION_DENIED);let n,r,i,o,s;const a=AbortSignal.timeout(this.inboundUpgradeTimeout),c=()=>{e.abort(new pu.sv("inbound upgrade timeout",pu.l9))};a.addEventListener("abort",c,{once:!0}),(0,pu.Wp)(1/0,a);try{var l,u,h;if(!0===await(null===(l=(u=this.components.connectionGater).denyInboundConnection)||void 0===l?void 0:l.call(u,e)))throw new pu.sv("The multiaddr connection is blocked by gater.acceptConnection",ige.ERR_CONNECTION_INTERCEPTED);null===(h=this.components.metrics)||void 0===h||h.trackMultiaddrConnection(e),this.log("starting the inbound connection upgrade");let a=e;if(!0!==(null===t||void 0===t?void 0:t.skipProtection)){const t=this.components.connectionProtector;null!=t&&(this.log("protecting the inbound connection"),a=await t.protect(e))}try{if(n=a,!0!==(null===t||void 0===t?void 0:t.skipEncryption)){({conn:n,remotePeer:r,protocol:s}=await this._encryptInbound(a));const e={...a,...n};await this.shouldBlockConnection(r,e,"denyInboundEncryptedConnection")}else{const t=e.remoteAddr.getPeerId();if(null==t)throw new pu.sv("inbound connection that skipped encryption must have a peer id",ige.ERR_INVALID_MULTIADDR);const n=Vh(t);s="native",r=n}if(i=n,null!=(null===t||void 0===t?void 0:t.muxerFactory))o=t.muxerFactory;else if(this.muxers.size>0){const e=await this._multiplexInbound({...a,...n},this.muxers);o=e.muxerFactory,i=e.stream}}catch(d){throw this.log.error("Failed to upgrade inbound connection",d),d}return await this.shouldBlockConnection(r,e,"denyInboundUpgradedConnection"),this.log("successfully upgraded inbound connection"),this._createConnection({cryptoProtocol:s,direction:"inbound",maConn:e,upgradedConn:i,muxerFactory:o,remotePeer:r,transient:null===t||void 0===t?void 0:t.transient})}finally{a.removeEventListener("abort",c),this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){var n;const r=e.remoteAddr.getPeerId();let i,o,s,a,c,l;null!=r&&(i=Vh(r),await this.shouldBlockConnection(i,e,"denyOutboundConnection")),null===(n=this.components.metrics)||void 0===n||n.trackMultiaddrConnection(e),this.log("Starting the outbound connection upgrade");let u=e;if(!0!==(null===t||void 0===t?void 0:t.skipProtection)){const t=this.components.connectionProtector;null!=t&&(u=await t.protect(e))}try{if(o=u,!0!==(null===t||void 0===t?void 0:t.skipEncryption)){({conn:o,remotePeer:s,protocol:c}=await this._encryptOutbound(u,i));const e={...u,...o};await this.shouldBlockConnection(s,e,"denyOutboundEncryptedConnection")}else{if(null==i)throw new pu.sv("Encryption was skipped but no peer id was passed",ige.ERR_INVALID_PEER);c="native",s=i}if(a=o,null!=(null===t||void 0===t?void 0:t.muxerFactory))l=t.muxerFactory;else if(this.muxers.size>0){const e=await this._multiplexOutbound({...u,...o},this.muxers);l=e.muxerFactory,a=e.stream}}catch(h){throw this.log.error("Failed to upgrade outbound connection",h),await e.close(h),h}return await this.shouldBlockConnection(s,e,"denyOutboundUpgradedConnection"),this.log("Successfully upgraded outbound connection"),this._createConnection({cryptoProtocol:c,direction:"outbound",maConn:e,upgradedConn:a,muxerFactory:l,remotePeer:s,transient:null===t||void 0===t?void 0:t.transient})}_createConnection(e){var t,n,r=this;const{cryptoProtocol:i,direction:o,maConn:s,upgradedConn:a,remotePeer:c,muxerFactory:l,transient:u}=e;let h,d,f;null!=l&&(h=l.createStreamMuxer({direction:o,onIncomingStream:e=>{null!=f&&Promise.resolve().then((async()=>{var t;const n=this.components.registrar.getProtocols(),{stream:r,protocol:i}=await M4(e,n,{log:e.log,yieldBytes:!1});if(null==f)return;f.log("incoming stream opened on %s",i);const o=function(e,t){try{const{options:n}=t.getHandler(e);return n.maxInboundStreams}catch(n){if(n.code!==ige.ERR_NO_HANDLER_FOR_PROTOCOL)throw n}return 32}(i,this.components.registrar);if(Lge(i,"inbound",f)===o){const t=new pu.sv('Too many inbound protocol streams for protocol "'.concat(i,'" - limit ').concat(o),ige.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);throw e.abort(t),t}e.source=r.source,e.sink=r.sink,e.protocol=i,null!=r.closeWrite&&(e.closeWrite=r.closeWrite),null!=r.closeRead&&(e.closeRead=r.closeRead),null!=r.close&&(e.close=r.close),await this.components.peerStore.merge(c,{protocols:[i]}),null===(t=this.components.metrics)||void 0===t||t.trackProtocolStream(e,f),this._onStream({connection:f,stream:e,protocol:i})})).catch((async t=>{this.log.error("error handling incoming stream id %s",e.id,t.message,t.code,t.stack),null==e.timeline.close&&await e.close()}))}}),d=async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null==h)throw new pu.sv("Stream is not multiplexed",ige.ERR_MUXER_UNAVAILABLE);f.log("starting new stream for protocols %s",e);const n=await h.newStream();f.log.trace("started new stream %s for protocols %s",n.id,e);try{var i;if(null==t.signal){r.log("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout",e);const n=AbortSignal.timeout(3e4);(0,pu.Wp)(1/0,n),t={...t,signal:n}}n.log.trace("selecting protocol from protocols %s",e);const{stream:o,protocol:s}=await x4(n,e,{...t,log:n.log,yieldBytes:!0});n.log("selected protocol %s",s);const a=function(e,t){var n;let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{const{options:n}=t.getHandler(e);if(null!=n.maxOutboundStreams)return n.maxOutboundStreams}catch(i){if(i.code!==ige.ERR_NO_HANDLER_FOR_PROTOCOL)throw i}return null!==(n=r.maxOutboundStreams)&&void 0!==n?n:64}(s,r.components.registrar,t);if(Lge(s,"outbound",f)>=a){const e=new pu.sv('Too many outbound protocol streams for protocol "'.concat(s,'" - limit ').concat(a),ige.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);throw n.abort(e),e}return await r.components.peerStore.merge(c,{protocols:[s]}),n.source=o.source,n.sink=o.sink,n.protocol=s,null!=o.closeWrite&&(n.closeWrite=o.closeWrite),null!=o.closeRead&&(n.closeRead=o.closeRead),null!=o.close&&(n.close=o.close),null===(i=r.components.metrics)||void 0===i||i.trackProtocolStream(n,f),n}catch(o){if(f.log.error("could not create new stream for protocols %s",e,o),null==n.timeline.close&&n.abort(o),null!=o.code)throw o;throw new pu.sv(String(o),ige.ERR_UNSUPPORTED_PROTOCOL)}},Promise.all([h.sink(a.source),a.sink(h.source)]).catch((e=>{this.log.error(e)})));const p=s.timeline;s.timeline=new Proxy(p,{set:function(){return null!=f&&"close"===(arguments.length<=1?void 0:arguments[1])&&null!=(arguments.length<=2?void 0:arguments[2])&&null==p.close&&(async()=>{try{"open"===f.status&&await f.close()}catch(e){r.log.error(e)}finally{r.events.safeDispatchEvent("connection:close",{detail:f})}})().catch((e=>{r.log.error(e)})),Reflect.set(...arguments)}}),s.timeline.upgraded=Date.now();var g;return g={remoteAddr:s.remoteAddr,remotePeer:c,status:"open",direction:o,timeline:s.timeline,multiplexer:null===(t=h)||void 0===t?void 0:t.protocol,encryption:i,transient:u,logger:this.components.logger,newStream:null!==(n=d)&&void 0!==n?n:()=>{throw new pu.sv("connection is not multiplexed",ige.ERR_CONNECTION_NOT_MULTIPLEXED)},getStreams:()=>null!=h?h.streams:[],close:async e=>{null!=h&&(this.log.trace("close muxer"),await h.close(e)),this.log.trace("close maconn"),await s.close(e),this.log.trace("closed maconn")},abort:e=>{s.abort(e),null!=h&&h.abort(e)}},f=new Bge(g),this.events.safeDispatchEvent("connection:open",{detail:f}),f}_onStream(e){const{connection:t,stream:n,protocol:r}=e,{handler:i,options:o}=this.components.registrar.getHandler(r);if(t.transient&&!0!==o.runOnTransientConnection)throw new pu.sv("Cannot open protocol stream on transient connection","ERR_TRANSIENT_CONNECTION");i({connection:t,stream:n})}async _encryptInbound(e){const t=Array.from(this.connectionEncryption.keys());this.log("handling inbound crypto protocol selection",t);try{const{stream:n,protocol:r}=await M4(e,t,{log:e.log}),i=this.connectionEncryption.get(r);if(null==i)throw new Error("no crypto module found for ".concat(r));return this.log("encrypting inbound connection using",r),{...await i.secureInbound(this.components.peerId,n),protocol:r}}catch(n){throw new pu.sv(String(n),ige.ERR_ENCRYPTION_FAILED)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncryption.keys());this.log("selecting outbound crypto protocol",n);try{e.log.trace("selecting encrypter from %s",n);const{stream:r,protocol:i}=await x4(e,n,{log:e.log,yieldBytes:!0}),o=this.connectionEncryption.get(i);if(null==o)throw new Error("no crypto module found for ".concat(i));return e.log("encrypting outbound connection to %p using %p",t),{...await o.secureOutbound(this.components.peerId,r,t),protocol:i}}catch(r){throw new pu.sv(String(r),ige.ERR_ENCRYPTION_FAILED)}}async _multiplexOutbound(e,t){const n=Array.from(t.keys());this.log("outbound selecting muxer %s",n);try{e.log.trace("selecting stream muxer from %s",n);const{stream:r,protocol:i}=await x4(e,n,{log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",i);return{stream:r,muxerFactory:t.get(i)}}catch(r){throw e.log.error("error multiplexing outbound stream",r),new pu.sv(String(r),ige.ERR_MUXER_UNAVAILABLE)}}async _multiplexInbound(e,t){const n=Array.from(t.keys());this.log("inbound handling muxers %s",n);try{const{stream:r,protocol:i}=await M4(e,n,{log:e.log});return{stream:r,muxerFactory:t.get(i)}}catch(r){throw this.log.error("error multiplexing inbound stream",r),new pu.sv(String(r),ige.ERR_MUXER_UNAVAILABLE)}}}var Uge=new WeakMap,Fge=new WeakSet;class Kge extends pu.Le{constructor(e){var t,n,r,i,o,s,a,c;super(),Jd(this,Fge),(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"peerStore",void 0),(0,Yo.Z)(this,"contentRouting",void 0),(0,Yo.Z)(this,"peerRouting",void 0),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,"services",void 0),(0,Yo.Z)(this,"logger",void 0),(0,Yo.Z)(this,"components",void 0),(0,_x.Z)(this,Uge,{writable:!0,value:void 0}),(0,Yo.Z)(this,"log",void 0);const l=new pu.Le,u=l.dispatchEvent.bind(l);l.dispatchEvent=e=>{const t=u(e),n=this.dispatchEvent(new pu.Aw(e.type,{detail:e.detail}));return t||n},(0,pu.Wp)(1/0,l),eW(this,Uge,!1),this.peerId=e.peerId,this.logger=null!==(t=e.logger)&&void 0!==t?t:qpe(),this.log=this.logger.forComponent("libp2p"),this.services={};const h=this.components=function(){const e=new Jpe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{});return new Proxy(e,{get(t,n,r){if("string"===typeof n&&!$pe.includes(n)){const t=e.components[n];if(null==t&&!Xpe.includes(n))throw new pu.sv("".concat(n," not set"),"ERR_SERVICE_MISSING");return t}return Reflect.get(t,n,r)},set:(t,n,r)=>("string"===typeof n?e.components[n]=r:Reflect.set(t,n,r),!0)})}({peerId:e.peerId,nodeInfo:null!==(n=e.nodeInfo)&&void 0!==n?n:{name:"libp2p",version:"1.0.0"},logger:this.logger,events:l,datastore:null!==(r=e.datastore)&&void 0!==r?r:new eH,connectionGater:ege(e.connectionGater)});this.peerStore=this.configureComponent("peerStore",new p5(h,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),null!=e.metrics&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),h.events.addEventListener("peer:update",(e=>{if(null==e.detail.previous){const t={id:e.detail.peer.id,multiaddrs:e.detail.peer.addresses.map((e=>e.multiaddr))};h.events.safeDispatchEvent("peer:discovery",{detail:t})}})),null!=e.connectionProtector&&this.configureComponent("connectionProtector",e.connectionProtector(h)),this.components.upgrader=new Mge(this.components,{connectionEncryption:(null!==(i=e.connectionEncryption)&&void 0!==i?i:[]).map(((e,t)=>this.configureComponent("connection-encryption-".concat(t),e(this.components)))),muxers:(null!==(o=e.streamMuxers)&&void 0!==o?o:[]).map(((e,t)=>this.configureComponent("stream-muxers-".concat(t),e(this.components)))),inboundUpgradeTimeout:e.connectionManager.inboundUpgradeTimeout}),this.configureComponent("transportManager",new Oge(this.components,e.transportManager)),this.configureComponent("connectionManager",new Sge(this.components,e.connectionManager)),this.configureComponent("registrar",new Pge(this.components)),this.configureComponent("addressManager",new Ype(this.components,e.addresses));const d=(null!==(s=e.peerRouters)&&void 0!==s?s:[]).map(((e,t)=>this.configureComponent("peer-router-".concat(t),e(this.components))));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new xge(this.components,{routers:d}));const f=(null!==(a=e.contentRouters)&&void 0!==a?a:[]).map(((e,t)=>this.configureComponent("content-router-".concat(t),e(this.components))));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new kge(this.components,{routers:f})),(null!==(c=e.peerDiscovery)&&void 0!==c?c:[]).forEach(((e,t)=>{this.configureComponent("peer-discovery-".concat(t),e(this.components)).addEventListener("peer",(e=>{Xd(this,Fge,jge).call(this,e)}))})),e.transports.forEach(((e,t)=>{this.components.transportManager.add(this.configureComponent("transport-".concat(t),e(this.components)))})),null!=e.services)for(const p of Object.keys(e.services)){const t=(0,e.services[p])(this.components);null!=t?(this.services[p]=t,this.configureComponent(p,t),null!=t[pu.wj]&&(this.log("registering service %s for content routing",p),f.push(t[pu.wj])),null!=t[pu.mV]&&(this.log("registering service %s for peer routing",p),d.push(t[pu.mV])),null!=t[pu.JX]&&(this.log("registering service %s for peer discovery",p),t[pu.JX].addEventListener("peer",(e=>{Xd(this,Fge,jge).call(this,e)})))):this.log.error("service factory %s returned null or undefined instance",p)}}configureComponent(e,t){return null==t&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(!(0,Ix.Z)(this,Uge)){eW(this,Uge,!0),this.log("libp2p is starting");try{var e,t,n,r;await(null===(e=(t=this.components).beforeStart)||void 0===e?void 0:e.call(t)),await this.components.start(),await(null===(n=(r=this.components).afterStart)||void 0===n?void 0:n.call(r)),this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(i){throw this.log.error("An error occurred starting libp2p",i),await this.stop(),i}}}async stop(){var e,t,n,r;(0,Ix.Z)(this,Uge)&&(this.log("libp2p is stopping"),eW(this,Uge,!1),await(null===(e=(t=this.components).beforeStop)||void 0===e?void 0:e.call(t)),await this.components.stop(),await(null===(n=(r=this.components).afterStop)||void 0===n?void 0:n.call(r)),this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}isStarted(){return(0,Ix.Z)(this,Uge)}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Ax;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.components.connectionManager.openConnection(e,t)}async dialProtocol(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(null==t)throw new pu.sv("no protocols were provided to open a stream",ige.ERR_INVALID_PROTOCOLS_FOR_STREAM);if(0===(t=Array.isArray(t)?t:[t]).length)throw new pu.sv("no protocols were provided to open a stream",ige.ERR_INVALID_PROTOCOLS_FOR_STREAM);return(await this.dial(e,n)).newStream(t,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};var n;(0,og.h2)(e)&&(e=Vh(null!==(n=e.getPeerId())&&void 0!==n?n:""));await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this.log("getPublicKey %p",e),null!=e.publicKey)return e.publicKey;const n=await this.peerStore.get(e);if(null!=n.id.publicKey)return n.id.publicKey;const r=(0,Ls.z)([(0,mu.m)("/pk/"),e.multihash.digest]),i=await this.contentRouting.get(r,t);return Ph(i),await this.peerStore.patch(e,{publicKey:i}),i}async handle(e,t,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map((async e=>{await this.components.registrar.handle(e,t,n)})))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map((async e=>{await this.components.registrar.unhandle(e)})))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}}function jge(e){const{detail:t}=e;t.id.toString()!==this.peerId.toString()?this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch((e=>{this.log.error(e)})):this.log.error(new Error(ige.ERR_DISCOVERED_SELF))}async function Zge(e){var t;return null!==(t=e.peerId)&&void 0!==t||(e.peerId=await OA()),new Kge(function(e){var t,n;const r=(0,H0.Z)(oge,e);if(null==r.transports||r.transports.length<1)throw new pu.sv(rge.ERR_TRANSPORTS_REQUIRED,ige.ERR_TRANSPORTS_REQUIRED);if(null===r.connectionProtector&&null!=(null===(t=globalThis.process)||void 0===t||null===(n=t.env)||void 0===n?void 0:n.LIBP2P_FORCE_PNET))throw new pu.sv(rge.ERR_PROTECTOR_REQUIRED,ige.ERR_PROTECTOR_REQUIRED);return r}(e))}async function zge(e){var t;const n=new UV,r=new eH,i=await async function(e){const t=await Zge(e);return!1!==e.start&&await t.start(),t}({connectionManager:{minConnections:0},datastore:r,transports:[e=>new JL(e,o),XU(),Lz(),UF(),EP({discoverRelays:1})],connectionEncryption:[cd()],streamMuxers:[Qd()],services:{identify:jO(),autoNAT:CS(),delegatedRouting:()=>nv("https://delegated-ipfs.dev")}});var o;const s=[lW({gateways:["".concat(null!==(t=e.protocol)&&void 0!==t?t:"http","://").concat(e.host,":").concat(e.port)]})];(function(){const e="explore.ipld.gatewayEnabled";console.info("\ud83c\udf9b\ufe0f Customise whether ipld-explorer-components fetches content from gateways by setting an '".concat(e,"' value to true/false in localStorage. e.g. localStorage.setItem('explore.ipld.gatewayEnabled', false) -- NOTE: defaults to true"));const t=localStorage.getItem(e);return null==t||JSON.parse(t)})()&&s.push(lW());const a=await Hpe({blockBrokers:[...s],hashers:await(0,Xr.i)(17,18,19,20,27,30),datastore:r,blockstore:n,libp2p:i});return await Promise.allSettled([ei(a,"dag-json",{hello:"world"}),ei(a,"dag-cbor",{hello:"world"},27),ei(a,"json",{hello:"world"},20),ei(a,"json",{hello:"world"},30),ei(a,"raw",(new TextEncoder).encode("hello"),30)]),a}const Vge={kuboGatewayOptions:{host:"127.0.0.1",port:"8080",protocol:"http"},error:null};let Hge=null;const qge={name:"helia",reducer(e,t){var n;let{type:r,payload:i,error:o}=t;var s;return e=null!==(n=e)&&void 0!==n?n:Vge,"HELIA_INIT_FINISHED"===r?Object.assign({},e,{kuboGatewayOptions:null!==(s=i.kuboGatewayOptions)&&void 0!==s?s:e.kuboGatewayOptions,error:null}):"HELIA_INIT_FAILED"===r?Object.assign({},e,{error:o}):e},selectHelia:()=>Hge,selectHeliaReady:()=>null!==Hge,selectHeliaIdentity:()=>{var e,t,n,r;const i=null===(e=Hge)||void 0===e||null===(t=e.libp2p.services)||void 0===t?void 0:t.identify;return null!==(n=null===i||void 0===i||null===(r=i.host)||void 0===r?void 0:r.agentVersion.split(" ")[0])&&void 0!==n?n:"null"},doInitHelia:()=>async e=>{let{dispatch:t,getState:n}=e;t({type:"HELIA_INIT_STARTED"});const r=Object.assign({},n().helia.kuboGatewayOptions,function(e){let t={};if(null!=globalThis.localStorage)try{var n;const r=null!==(n=globalThis.localStorage.getItem(e))&&void 0!==n?n:"{}";t=JSON.parse(r)}catch(r){console.error("Error reading '".concat(e,"' value from localStorage"),r)}return t}("kuboGateway"));try{return console.info("\ud83c\udf9b\ufe0f Customise your Kubo gateway opts by setting an `kuboGateway` value in localStorage. e.g. localStorage.setItem('kuboGateway', JSON.stringify({port: '1337'}))"),console.time("HELIA_INIT"),Hge=await zge(r),console.timeEnd("HELIA_INIT"),t({type:"HELIA_INIT_FINISHED",payload:{kuboGatewayOptions:r,provider:"helia"}})}catch(i){return t({type:"HELIA_INIT_FAILED",error:i})}}},Gge=qge;n(24461);var Wge=n(72791),Qge=n(87945),Yge=n(218);const Jge=n.p+"static/media/spinner.2b9ba5ad729c470bcc2f15327fe033d5.svg";const Xge=n.p+"static/media/upload.62e1d0494e4ab941631324eac71c71a4.svg";class $ge extends Wge.Component{constructor(e){super(e),this.state={file:{}},this.handleOnChange=this.handleOnChange.bind(this),this.handleOnSubmit=this.handleOnSubmit.bind(this)}handleOnSubmit(e){e.preventDefault()}handleOnChange(){document.getElementById("car-loader-image").src=Jge;const e=document.getElementById("car-file").files[0];this.props.doUploadUserProvidedCar(e,Xge)}render(){const{t:e}=this.props;return Wge.createElement("form",{"data-id":"IpldCarExploreForm",className:"sans-serif black-80 flex",onSubmit:this.handleOnSubmit,encType:"multipart/form-data"},Wge.createElement("div",{className:"flex-auto"},Wge.createElement("div",{className:"relative"},Wge.createElement("input",{id:"car-file",type:"file",accept:".car",className:"input-reset bn pa2 mb2 db w-100 f6 br-0 placeholder-light focus-outline",style:{borderRadius:"3px 0 0 3px",backgroundColor:"white",padding:"5px 0px 5px 5px",width:"99%"},"aria-describedby":"name-desc",onChange:this.handleOnChange}),Wge.createElement("small",{id:"car-file-desc",className:"o-0 absolute f6 black-60 db mb2"},e("IpldCarExploreForm.uploadCarFile")),Wge.createElement("img",{id:"car-loader-image",alt:"placeholder for upload and loader",src:Xge,className:"absolute",style:{top:"0px",right:"0px",height:"30px",width:"30px",paddingRight:"10px"}}))))}}(0,Yge.$)("doUploadUserProvidedCar",(0,Qge.Zh)("explore")($ge));function eye(){return eye=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},eye.apply(this,arguments)}const tye=e=>Wge.createElement("svg",eye({viewBox:"0 0 100 100"},e),Wge.createElement("path",{d:"M87.714 44.764c0-1.157-.45-2.245-1.269-3.062a4.304 4.304 0 0 0-3.063-1.269 4.304 4.304 0 0 0-3.062 1.269 4.337 4.337 0 0 0 0 6.125c.602.602 1.351 1 2.164 1.172v2.442l-14.686 9.276v-19.79l4.498-2.842v-3.717a4.27 4.27 0 0 0 1.827-1.067 4.337 4.337 0 0 0 0-6.125 4.337 4.337 0 0 0-6.126 0 4.304 4.304 0 0 0-1.269 3.063c0 1.157.45 2.245 1.269 3.062a4.282 4.282 0 0 0 1.963 1.107v2.391L51.236 48.627v-8.901l9.304-5.877v-7.051a4.282 4.282 0 0 0 1.986-1.114 4.336 4.336 0 0 0-.001-6.125 4.337 4.337 0 0 0-6.125 0h-.001a4.337 4.337 0 0 0 0 6.125c.52.519 1.145.859 1.804 1.059v5.818l-6.967 4.401V15.561a4.283 4.283 0 0 0 2.008-1.12 4.337 4.337 0 0 0-.001-6.126 4.337 4.337 0 0 0-6.125 0h-.001a4.337 4.337 0 0 0 .001 6.126 4.273 4.273 0 0 0 1.782 1.053v15.881l-7.229-4.566v-3.436a4.292 4.292 0 0 0 2.008-1.12 4.337 4.337 0 0 0 0-6.125 4.337 4.337 0 0 0-6.126 0 4.304 4.304 0 0 0-1.269 3.063c0 1.157.45 2.245 1.269 3.062a4.276 4.276 0 0 0 1.781 1.053v4.79l9.565 6.042v21.108l-7.708-4.226v-7.809a4.275 4.275 0 0 0 2.034-1.128 4.337 4.337 0 0 0 0-6.125 4.337 4.337 0 0 0-6.126 0 4.304 4.304 0 0 0-1.269 3.063c0 1.157.45 2.245 1.269 3.062a4.284 4.284 0 0 0 1.756 1.046v6.61L27.15 43.322v-6.217a4.28 4.28 0 0 0 1.984-1.117 4.3 4.3 0 0 0 1.27-3.063c0-1.157-.45-2.245-1.269-3.062a4.336 4.336 0 0 0-6.126 0 4.337 4.337 0 0 0 0 6.125c.51.51 1.132.858 1.804 1.062v7.621l3.646 2.004v13.632l-10.582-5.77v-2.418a4.29 4.29 0 0 0 2.051-1.133 4.337 4.337 0 0 0 0-6.125 4.304 4.304 0 0 0-3.062-1.269 4.304 4.304 0 0 0-3.063 1.269 4.337 4.337 0 0 0 0 6.125 4.285 4.285 0 0 0 1.738 1.041v3.812L48.9 74.108v11.397a4.277 4.277 0 0 0-1.783 1.053 4.337 4.337 0 0 0 0 6.125 4.32 4.32 0 0 0 3.063 1.266 4.316 4.316 0 0 0 3.063-1.267 4.337 4.337 0 0 0 0-6.125 4.29 4.29 0 0 0-2.008-1.119V73.943L84.82 52.727v-3.892a4.29 4.29 0 0 0 1.625-1.008 4.3 4.3 0 0 0 1.269-3.063zM30.586 61.468V47.844L48.9 57.91v13.542l-18.314-9.984zm34.876-19.065v19.79l-14.227 8.986v-19.79l14.227-8.986zm3.067-12.164c0-.676.264-1.312.742-1.79a2.525 2.525 0 0 1 1.79-.74c.647 0 1.296.247 1.789.74a2.536 2.536 0 0 1 0 3.581 2.535 2.535 0 0 1-3.579 0 2.516 2.516 0 0 1-.742-1.791zm-10.857-9.407a2.534 2.534 0 0 1 3.58 0 2.534 2.534 0 0 1 0 3.58 2.534 2.534 0 0 1-3.58 0 2.534 2.534 0 0 1 0-3.58zM48.389 9.589a2.536 2.536 0 0 1 3.581 0c.987.987.987 2.593.001 3.58a2.536 2.536 0 0 1-3.581 0 2.535 2.535 0 0 1-.001-3.58zM38.084 19.19c0-.676.264-1.312.742-1.79a2.525 2.525 0 0 1 1.79-.74c.647 0 1.296.247 1.789.74a2.536 2.536 0 0 1 0 3.581 2.535 2.535 0 0 1-3.579 0 2.52 2.52 0 0 1-.742-1.791zm-.453 19.832c0-.676.264-1.312.742-1.79a2.525 2.525 0 0 1 1.79-.74c.647 0 1.296.247 1.789.74a2.536 2.536 0 0 1 0 3.581 2.535 2.535 0 0 1-3.58 0 2.525 2.525 0 0 1-.741-1.791zm-13.348-7.887a2.524 2.524 0 0 1 1.789-.74 2.526 2.526 0 0 1 2.532 2.531c0 .677-.264 1.312-.742 1.79-.422.422-.984.647-1.562.696h-.456c-.577-.049-1.139-.274-1.561-.696a2.534 2.534 0 0 1 0-3.581zm-9.207 14.999a2.514 2.514 0 0 1 1.79-.742 2.534 2.534 0 0 1 1.789 4.322 2.533 2.533 0 0 1-3.579 0 2.533 2.533 0 0 1 0-3.58zM51.97 91.411a2.534 2.534 0 0 1-3.58 0 2.534 2.534 0 0 1 0-3.58 2.536 2.536 0 0 1 3.58 0 2.534 2.534 0 0 1 0 3.58zm33.202-44.857c-.955.955-2.624.957-3.579 0a2.534 2.534 0 0 1 1.789-4.322c.677 0 1.312.264 1.791.742.478.478.741 1.113.741 1.79s-.263 1.311-.742 1.79z"}));class nye extends Wge.Component{constructor(e){super(e),this.state={path:""},this.handleOnChange=this.handleOnChange.bind(this),this.handleOnSubmit=this.handleOnSubmit.bind(this)}handleOnSubmit(e){e.preventDefault(),this.props.doExploreUserProvidedPath(this.state.path)}handleOnChange(e){const t=e.target.value;this.setState({path:t})}render(){const{t:e}=this.props;return Wge.createElement("form",{"data-id":"IpldExploreForm",className:"sans-serif black-80 flex",onSubmit:this.handleOnSubmit},Wge.createElement("div",{className:"flex-auto"},Wge.createElement("div",{className:"relative"},Wge.createElement("input",{id:"ipfs-path",className:"input-reset bn pa2 mb2 db w-100 f6 br-0 placeholder-light focus-outline",style:{borderRadius:"3px 0 0 3px"},type:"text",placeholder:"QmHash","aria-describedby":"name-desc",onChange:this.handleOnChange,value:this.state.path}),Wge.createElement("small",{id:"ipfs-path-desc",className:"o-0 absolute f6 black-60 db mb2"},"Paste in a CID or IPFS path"))),Wge.createElement("div",{className:"flex-none"},Wge.createElement("button",{type:"submit",className:"button-reset dib lh-copy pv1 pl2 pr3 ba f7 fw4 focus-outline white bg-aqua bn",style:{borderRadius:"0 3px 3px 0"}},Wge.createElement(tye,{style:{height:24},className:"dib fill-current-color v-mid navy 0-100"}),Wge.createElement("span",{className:"ml2 navy 0-100"},e("IpldExploreForm.explore")))))}}const rye=(0,Yge.$)("doExploreUserProvidedPath",(0,Qge.Zh)("explore")(nye));n(39278);var iye=n(5803),oye=n(51483);const sye=(0,iye.ZP)((()=>n.e(480).then(n.bind(n,90480))),{fallback:Wge.createElement(oye.Z,null)});var aye=n(21568),cye=n(18970),lye=n(14964);const uye=n.p+"static/media/ipld.c2e6094fbcd21952d9a1019f204a629e.svg";var hye=n(59714);const dye=(0,Qge.Zh)("explore")((e=>{let{t:t}=e;return Wge.createElement(hye.Z,{className:"tl dib pa4 avenir measure-wide-l lh-copy dark-gray ba-l b--black-10"},Wge.createElement("div",{className:"tc"},Wge.createElement("a",{className:"link",href:"https://ipld.io"},Wge.createElement("img",{src:uye,alt:"IPLD",style:{height:60}}))),Wge.createElement(Qge.cC,{i18nKey:"AboutIpld.paragraph1",t:t},Wge.createElement("p",null,"IPLD is ",Wge.createElement("strong",null,"the data model of the content-addressable web.")," It allows us to treat all hash-linked data structures as subsets of a unified information space, unifying all data models that link data with hashes as instances of IPLD.")),Wge.createElement(Qge.cC,{i18nKey:"AboutIpld.paragraph2",t:t},Wge.createElement("p",null,"Content addressing through hashes has become a widely-used means of connecting data in distributed systems, from the blockchains that run your favorite cryptocurrencies, to the commits that back your code, to the web\u2019s content at large. Yet, whilst all of these tools rely on some common primitives, their specific underlying data structures are not interoperable.")),Wge.createElement(Qge.cC,{i18nKey:"AboutIpld.paragraph3",t:t},Wge.createElement("p",null,"Enter IPLD: a single namespace for all hash-inspired protocols. Through IPLD, links can be traversed across protocols, allowing you to explore data regardless of the underlying protocol.")))}));var fye=n(29405);const pye=e=>{let{cid:t,name:n,type:r}=e;return Wge.createElement("a",{className:"flex items-center lh-copy pl3 pl0-l pv3 bb b--black-10 link focus-outline",href:"#/explore/".concat(t)},Wge.createElement("span",{className:"flex items-center justify-center w3 h3 w3-m h3-m w3-l h3-l flex-none br-100 tc",style:{background:(0,aye.$j)(r)}},Wge.createElement("span",{className:"montserrat fw3 f6 snow",title:(0,aye.RB)(r)},(0,aye.Yn)(r))),Wge.createElement("span",{className:"pl3 truncate"},Wge.createElement("h2",{className:"ma0 fw4 f5 db black montserrat"},n),Wge.createElement("span",{className:"f7 db blue truncate monospace"},t)))},gye=(0,Qge.Zh)("explore")((e=>{let{t:t,embed:n,runTour:r=!1,joyrideCallback:i}=e;return Wge.createElement("div",{className:"mw9 center explore-sug-2"},Wge.createElement(cye.ql,null,Wge.createElement("title",null,t("StartExploringPage.title"))),Wge.createElement("div",{className:"flex-l"},Wge.createElement("div",{className:"flex-auto-l mr3-l"},Wge.createElement("div",{className:"pl3 pl0-l pt4 pt2-l"},Wge.createElement("h1",{className:"f3 f2-l ma0 fw4 montserrat charcoal"},t("StartExploringPage.header")),Wge.createElement("p",{className:"lh-copy f5 avenir charcoal-muted"},t("StartExploringPage.leadParagraph"))),n?Wge.createElement(rye,null):null,Wge.createElement("ul",{className:"list pl0 ma0 mt4 mt0-l bt bn-l b--black-10"},Wge.createElement("li",null,Wge.createElement(pye,{name:"Project Apollo Archives",cid:"QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D",type:"dag-pb"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"XKCD Archives",cid:"QmdmQXB2mzChmMeKY47C43LxUdg1NDJ5MWcKMKxDu7RgQm",type:"dag-pb"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"HAMT-sharded Wikipedia mirror (>20M files)",cid:"bafybeiaysi4s6lnjev27ln5icwm6tueaw2vdykrtjkwiphwekaywqhcjze",type:"hamt-sharded-directory"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"B-tree search index from ipfs-geoip",cid:"bafyreif3tfdpr5n4jdrbielmcapwvbpcthepfkwq2vwonmlhirbjmotedi",type:"dag-cbor"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"DAG-CBOR Block",cid:"bafyreicnokmhmrnlp2wjhyk2haep4tqxiptwfrp2rrs7rzq7uk766chqvq",type:"dag-cbor"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"dag-cbor hello world (keccak-256)",cid:"bafyrwigbexamue2ba3hmtai7hwlcmd6ekiqsduyf5avv7oz6ln3radvjde",type:"dag-cbor"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"Ceramic LogEntry for sgb.chat Ambassador proposal",cid:"bagcqcerarvdwmhvk73mze3e2n6yvpt5h7fh3eae7n6y3hizsflz5grpyeczq",type:"dag-jose"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"hello world (blake3)",cid:"bagaaihraf4oq2kddg6o5ewlu6aol6xab75xkwbgzx2dlot7cdun7iirve23a",type:"dag-json"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"hello world",cid:"baguqeerasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea",type:"dag-json"})),Wge.createElement("li",null,Wge.createElement(pye,{name:"hello world (sha3-512)",cid:"bagaaifcavabu6fzheerrmtxbbwv7jjhc3kaldmm7lbnvfopyrthcvod4m6ygpj3unrcggkzhvcwv5wnhc5ufkgzlsji7agnmofovc2g4a3ui7ja",type:"json"})),Wge.createElement("li",null,Wge.createElement(pye,{name:'Raw Block for "hello"',cid:"bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44yegnrjhc4yeq",type:"raw"})),Wge.createElement("li",null,Wge.createElement(pye,{name:'Raw Block for "hello" (blake3)',cid:"bafkr4ihkr4ld3m4gqkjf4reryxsy2s5tkbxprqkow6fin2iiyvreuzzab4",type:"raw"})))),Wge.createElement("div",{className:"pt2-l"},Wge.createElement(dye,null))),Wge.createElement(lye.ZP,{run:r,steps:fye.V.getSteps({t:t}),styles:fye.V.styles,callback:i,scrollToFirstStep:!0}))}))},59536:(e,t,n)=>{"use strict";n.d(t,{A$:()=>u,NZ:()=>c,SD:()=>a,uU:()=>l});var r=n(839),i=n(1315),o=n(20099),s=n(40791);function a(e,t){if(!e)return null;try{return s.CID.asCID(e)||s.CID.parse(e,t)}catch(n){return null}}function c(e){const t=a(e);if(null==t)return null;switch(t.code){case r.code:return r.name;case i.code:return i.name;case o.code:return o.name;default:return null}}function l(e){const t=a(e);return t?t.code:null}function u(e){const t=a(e);return t?t.toString():null}},48236:(e,t,n)=>{"use strict";function r(e){switch(e){case 113:return"dag-cbor";case 112:return"dag-pb";case 120:return"git-raw";case 85:return"raw";case 512:return"json";case 297:return"dag-json";case 133:return"dag-jose";default:return"codec code ".concat(e,"=unknown")}}n.d(t,{Z:()=>r})},14824:(e,t,n)=>{"use strict";n.d(t,{C:()=>ie,i:()=>ne});var r=n(9837),i=n.n(r);new Uint8Array(0);var o=function e(t,n,r){n=n||[];var i=r=r||0;for(;t>=c;)n[r++]=255&t|s,t/=128;for(;t&a;)n[r++]=255&t|s,t>>>=7;return n[r]=0|t,e.bytes=r-i+1,n},s=128,a=-128,c=Math.pow(2,31);var l=function e(t,n){var r,i=0,o=0,s=n=n||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],i+=o<28?(r&h)<<o:(r&h)*Math.pow(2,o),o+=7}while(r>=u);return e.bytes=s-n,i},u=128,h=127;var d=Math.pow(2,7),f=Math.pow(2,14),p=Math.pow(2,21),g=Math.pow(2,28),y=Math.pow(2,35),m=Math.pow(2,42),v=Math.pow(2,49),b=Math.pow(2,56),w=Math.pow(2,63);const E={encode:o,decode:l,encodingLength:function(e){return e<d?1:e<f?2:e<p?3:e<g?4:e<y?5:e<m?6:e<v?7:e<b?8:e<w?9:10}},A=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return E.encode(e,t,n),t},S=e=>E.encodingLength(e),_=(e,t)=>{const n=t.byteLength,r=S(e),i=r+S(n),o=new Uint8Array(i+n);return A(e,o,0),A(n,o,r),o.set(t,i),new I(e,n,t,o)};class I{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const C=e=>{let{name:t,code:n,encode:r}=e;return new T(t,n,r)};class T{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?_(this.code,t):t.then((e=>_(this.code,e)))}throw Error("Unknown type, must be binary type")}}function k(e){return t=>new Uint8Array(e.array(t))}C({code:23,name:"sha3-224",encode:k(i().sha3_224)}),C({code:22,name:"sha3-256",encode:k(i().sha3_256)}),C({code:21,name:"sha3-384",encode:k(i().sha3_384)});const R=C({code:20,name:"sha3-512",encode:k(i().sha3_512)}),x=(C({code:24,name:"shake-128",encode:e=>new Uint8Array(i().shake128.array(e,256))}),C({code:25,name:"shake-256",encode:e=>new Uint8Array(i().shake256.array(e,512))}),C({code:26,name:"keccak-224",encode:k(i().keccak224)}),C({code:27,name:"keccak-256",encode:k(i().keccak256)}));C({code:28,name:"keccak-384",encode:k(i().keccak384)}),C({code:29,name:"keccak-512",encode:k(i().keccak512)});function P(e,t,n,r){return new(n||(n=Promise))((function(i,o){function s(e){try{c(r.next(e))}catch(t){o(t)}}function a(e){try{c(r.throw(e))}catch(t){o(t)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}c((r=r.apply(e,t||[])).next())}))}"function"===typeof SuppressedError&&SuppressedError;class D{constructor(){this.mutex=Promise.resolve()}lock(){let e=()=>{};return this.mutex=this.mutex.then((()=>new Promise(e))),new Promise((t=>{e=t}))}dispatch(e){return P(this,void 0,void 0,(function*(){const t=yield this.lock();try{return yield Promise.resolve(e())}finally{t()}}))}}var O;const N="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:"undefined"!==typeof window?window:n.g,B=null!==(O=N.Buffer)&&void 0!==O?O:null,L=N.TextEncoder?new N.TextEncoder:null;function M(e,t){return(15&e)+(e>>6|e>>3&8)<<4|(15&t)+(t>>6|t>>3&8)}function U(e,t){const n=t.length>>1;for(let r=0;r<n;r++){const n=r<<1;e[r]=M(t.charCodeAt(n),t.charCodeAt(n+1))}}const F="a".charCodeAt(0)-10,K="0".charCodeAt(0);function j(e,t,n){let r=0;for(let i=0;i<n;i++){let n=t[i]>>>4;e[r++]=n>9?n+F:n+K,n=15&t[i],e[r++]=n>9?n+F:n+K}return String.fromCharCode.apply(null,e)}const Z=null!==B?e=>{if("string"===typeof e){const t=B.from(e,"utf8");return new Uint8Array(t.buffer,t.byteOffset,t.length)}if(B.isBuffer(e))return new Uint8Array(e.buffer,e.byteOffset,e.length);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Invalid data type!")}:e=>{if("string"===typeof e)return L.encode(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Invalid data type!")},z="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",V=new Uint8Array(256);for(let oe=0;oe<z.length;oe++)V[z.charCodeAt(oe)]=oe;function H(e){let t=Math.floor(.75*e.length);const n=e.length;return"="===e[n-1]&&(t-=1,"="===e[n-2]&&(t-=1)),t}function q(e){const t=H(e),n=e.length,r=new Uint8Array(t);let i=0;for(let o=0;o<n;o+=4){const t=V[e.charCodeAt(o)],n=V[e.charCodeAt(o+1)],s=V[e.charCodeAt(o+2)],a=V[e.charCodeAt(o+3)];r[i]=t<<2|n>>4,i+=1,r[i]=(15&n)<<4|s>>2,i+=1,r[i]=(3&s)<<6|63&a,i+=1}return r}const G=16384,W=4,Q=new D,Y=new Map;function J(e,t){return P(this,void 0,void 0,(function*(){let n=null,r=null,i=!1;if("undefined"===typeof WebAssembly)throw new Error("WebAssembly is not supported in this environment!");const o=()=>new DataView(n.exports.memory.buffer).getUint32(n.exports.STATE_SIZE,!0),s=Q.dispatch((()=>P(this,void 0,void 0,(function*(){if(!Y.has(e.name)){const t=q(e.data),n=WebAssembly.compile(t);Y.set(e.name,n)}const t=yield Y.get(e.name);n=yield WebAssembly.instantiate(t,{})})))),a=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;i=!0,n.exports.Hash_Init(e)},c=e=>{if(!i)throw new Error("update() called before init()");(e=>{let t=0;for(;t<e.length;){const i=e.subarray(t,t+G);t+=i.length,r.set(i),n.exports.Hash_Update(i.length)}})(Z(e))},l=new Uint8Array(2*t),u=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!i)throw new Error("digest() called before init()");return i=!1,n.exports.Hash_Final(o),"binary"===e?r.slice(0,t):j(l,r,t)},h=e=>"string"===typeof e?e.length<G/4:e.byteLength<G;let d=h;switch(e.name){case"argon2":case"scrypt":d=()=>!0;break;case"blake2b":case"blake2s":d=(e,t)=>t<=512&&h(e);break;case"blake3":d=(e,t)=>0===t&&h(e);break;case"xxhash64":case"xxhash3":case"xxhash128":d=()=>!1}return yield(()=>P(this,void 0,void 0,(function*(){n||(yield s);const e=n.exports.Hash_GetBuffer(),t=n.exports.memory.buffer;r=new Uint8Array(t,e,G)})))(),{getMemory:()=>r,writeMemory:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;r.set(e,t)},getExports:()=>n.exports,setMemorySize:e=>{n.exports.Hash_SetMemorySize(e);const t=n.exports.Hash_GetBuffer(),i=n.exports.memory.buffer;r=new Uint8Array(i,t,e)},init:a,update:c,digest:u,save:()=>{if(!i)throw new Error("save() can only be called after init() and before digest()");const t=n.exports.Hash_GetState(),r=o(),s=n.exports.memory.buffer,a=new Uint8Array(s,t,r),c=new Uint8Array(W+r);return U(c,e.hash),c.set(a,W),c},load:t=>{if(!(t instanceof Uint8Array))throw new Error("load() expects an Uint8Array generated by save()");const r=n.exports.Hash_GetState(),s=o(),a=W+s,c=n.exports.memory.buffer;if(t.length!==a)throw new Error("Bad state length (expected ".concat(a," bytes, got ").concat(t.length,")"));if(!function(e,t){if(e.length!==2*t.length)return!1;for(let n=0;n<t.length;n++){const r=n<<1;if(t[n]!==M(e.charCodeAt(r),e.charCodeAt(r+1)))return!1}return!0}(e.hash,t.subarray(0,W)))throw new Error("This state was written by an incompatible hash implementation");const l=t.subarray(W);new Uint8Array(c,r,s).set(l),i=!0},calculate:function(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(!d(e,i))return a(i),c(e),u("hex",o);const s=Z(e);return r.set(s),n.exports.Hash_Calculate(s.length,i,o),j(l,r,t)},hashLength:t}}))}new D;new D;new DataView(new ArrayBuffer(4));new D;var X={name:"blake3",data:"AGFzbQEAAAABMQdgAAF/YAl/f39+f39/f38AYAZ/f39/fn8AYAF/AGADf39/AGABfgBgBX9/fn9/AX8DDg0AAQIDBAUGAwMDAwAEBQQBAQICBg4CfwFBgJgFC38AQYAICwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAAIC0hhc2hfVXBkYXRlAAkKSGFzaF9GaW5hbAAKDUhhc2hfR2V0U3RhdGUACw5IYXNoX0NhbGN1bGF0ZQAMClNUQVRFX1NJWkUDAQqcWw0FAEGACQujAwQCfwF+AX8EfiMAQeAAayIJJAACQCABRQ0AIAcgBXIhCiAEQQBHrSELIAdBACACQQFGGyAGciAFciEMA0AgACgCACEHIAlBACkDgIkBNwMAIAlBACkDiIkBNwMIIAlBACkDkIkBNwMQIAlBACkDmIkBNwMYIAlBIGogCSAHQcAAIAMgDBACIAkgCSkDQCAJKQMghSINNwMAIAkgCSkDSCAJKQMohSIONwMIIAkgCSkDUCAJKQMwhSIPNwMQIAkgCSkDWCAJKQM4hSIQNwMYIAdBwABqIQcgAiEEAkADQCAFIQYCQAJAIARBf2oiBA4CAwABCyAKIQYLIAlBIGogCSAHQcAAIAMgBhACIAkgCSkDQCAJKQMghSINNwMAIAkgCSkDSCAJKQMohSIONwMIIAkgCSkDUCAJKQMwhSIPNwMQIAkgCSkDWCAJKQM4hSIQNwMYIAdBwABqIQcMAAsLIAggEDcDGCAIIA83AxAgCCAONwMIIAggDTcDACAIQSBqIQggAEEEaiEAIAMgC3whAyABQX9qIgENAAsLIAlB4ABqJAALhBwCDH4ffyACKQMgIQYgAikDOCEHIAIpAzAhCCACKQMAIQkgAikDKCEKIAIpAxAhCyACKQMIIQwgAikDGCENIAAgASkDACIONwMAIAAgASkDCCIPNwMIIAAgASkDECIQNwMQIAAgD0IgiKcgDaciAmogASkDGCIRQiCIpyISaiITIA1CIIinIgFqIBMgBXNBEHQgE0EQdnIiFEG66r+qemoiFSASc0EUdyIWaiIXIA6nIAmnIhNqIBCnIhJqIhggCUIgiKciBWogGCAEp3NBEHciGEHnzKfQBmoiGSASc0EUdyISaiIaIBhzQRh3IhsgGWoiHCASc0EZdyIdaiAHpyISaiIeIAdCIIinIhhqIB4gD6cgC6ciGWogEaciH2oiICALQiCIpyIhaiAgIANzQRB0ICBBEHZyIiBB8ua74wNqIiIgH3NBFHciH2oiIyAgc0EYdyIkc0EQdyIeIA5CIIinIAynIiBqIBBCIIinIiVqIiYgDEIgiKciA2ogJiAEQiCIp3NBEHciJkGF3Z7be2oiJyAlc0EUdyIlaiIoICZzQRh3IiYgJ2oiJ2oiKSAdc0EUdyIdaiIqIBlqIBcgFHNBGHciKyAVaiIsIBZzQRl3IhYgI2ogCKciFGoiFyAIQiCIpyIVaiAXICZzQRB3IhcgHGoiHCAWc0EUdyIWaiIjIBdzQRh3IiYgHGoiLSAWc0EZdyIuaiIcIBVqICcgJXNBGXciJSAaaiAGpyIWaiIaIAZCIIinIhdqIBogK3NBEHciGiAkICJqIiJqIiQgJXNBFHciJWoiJyAac0EYdyIrIBxzQRB3Ii8gIiAfc0EZdyIfIChqIAqnIhpqIiIgCkIgiKciHGogIiAbc0EQdyIbICxqIiIgH3NBFHciH2oiKCAbc0EYdyIbICJqIiJqIiwgLnNBFHciLmoiMCAnICBqICogHnNBGHciHiApaiInIB1zQRl3Ih1qIikgAmogGyApc0EQdyIbIC1qIikgHXNBFHciHWoiKiAbc0EYdyIbIClqIikgHXNBGXciHWogGGoiLSAWaiAtICMgAWogIiAfc0EZdyIfaiIiIBNqIB4gInNBEHciHiArICRqIiJqIiMgH3NBFHciH2oiJCAec0EYdyIec0EQdyIrICggA2ogIiAlc0EZdyIiaiIlIBpqICYgJXNBEHciJSAnaiImICJzQRR3IiJqIicgJXNBGHciJSAmaiImaiIoIB1zQRR3Ih1qIi0gAWogMCAvc0EYdyIvICxqIiwgLnNBGXciLiAkaiAXaiIkIBJqICQgJXNBEHciJCApaiIlIC5zQRR3IilqIi4gJHNBGHciJCAlaiIlIClzQRl3IilqIjAgEmogJiAic0EZdyIiICpqIAVqIiYgHGogJiAvc0EQdyImIB4gI2oiHmoiIyAic0EUdyIiaiIqICZzQRh3IiYgMHNBEHciLyAeIB9zQRl3Ih4gJ2ogFGoiHyAhaiAfIBtzQRB3IhsgLGoiHyAec0EUdyIeaiInIBtzQRh3IhsgH2oiH2oiLCApc0EUdyIpaiIwICogA2ogLSArc0EYdyIqIChqIiggHXNBGXciHWoiKyAZaiAbICtzQRB3IhsgJWoiJSAdc0EUdyIdaiIrIBtzQRh3IhsgJWoiJSAdc0EZdyIdaiAWaiItIAVqIC0gLiAVaiAfIB5zQRl3Ih5qIh8gIGogKiAfc0EQdyIfICYgI2oiI2oiJiAec0EUdyIeaiIqIB9zQRh3Ih9zQRB3Ii0gJyAaaiAjICJzQRl3IiJqIiMgFGogJCAjc0EQdyIjIChqIiQgInNBFHciImoiJyAjc0EYdyIjICRqIiRqIiggHXNBFHciHWoiLiAVaiAwIC9zQRh3Ii8gLGoiLCApc0EZdyIpICpqIBxqIiogGGogKiAjc0EQdyIjICVqIiUgKXNBFHciKWoiKiAjc0EYdyIjICVqIiUgKXNBGXciKWoiMCAYaiAkICJzQRl3IiIgK2ogAmoiJCAhaiAkIC9zQRB3IiQgHyAmaiIfaiImICJzQRR3IiJqIisgJHNBGHciJCAwc0EQdyIvIB8gHnNBGXciHiAnaiAXaiIfIBNqIB8gG3NBEHciGyAsaiIfIB5zQRR3Ih5qIicgG3NBGHciGyAfaiIfaiIsIClzQRR3IilqIjAgKyAaaiAuIC1zQRh3IisgKGoiKCAdc0EZdyIdaiItIAFqIBsgLXNBEHciGyAlaiIlIB1zQRR3Ih1qIi0gG3NBGHciGyAlaiIlIB1zQRl3Ih1qIAVqIi4gAmogLiAqIBJqIB8gHnNBGXciHmoiHyADaiArIB9zQRB3Ih8gJCAmaiIkaiImIB5zQRR3Ih5qIiogH3NBGHciH3NBEHciKyAnIBRqICQgInNBGXciImoiJCAXaiAjICRzQRB3IiMgKGoiJCAic0EUdyIiaiInICNzQRh3IiMgJGoiJGoiKCAdc0EUdyIdaiIuIBJqIDAgL3NBGHciLyAsaiIsIClzQRl3IikgKmogIWoiKiAWaiAqICNzQRB3IiMgJWoiJSApc0EUdyIpaiIqICNzQRh3IiMgJWoiJSApc0EZdyIpaiIwIBZqICQgInNBGXciIiAtaiAZaiIkIBNqICQgL3NBEHciJCAfICZqIh9qIiYgInNBFHciImoiLSAkc0EYdyIkIDBzQRB3Ii8gHyAec0EZdyIeICdqIBxqIh8gIGogHyAbc0EQdyIbICxqIh8gHnNBFHciHmoiJyAbc0EYdyIbIB9qIh9qIiwgKXNBFHciKWoiMCAvc0EYdyIvICxqIiwgKXNBGXciKSAqIBhqIB8gHnNBGXciHmoiHyAaaiAuICtzQRh3IiogH3NBEHciHyAkICZqIiRqIiYgHnNBFHciHmoiK2ogE2oiLiAFaiAuICcgF2ogJCAic0EZdyIiaiIkIBxqICMgJHNBEHciIyAqIChqIiRqIicgInNBFHciImoiKCAjc0EYdyIjc0EQdyIqIC0gFGogJCAdc0EZdyIdaiIkIBVqIBsgJHNBEHciGyAlaiIkIB1zQRR3Ih1qIiUgG3NBGHciGyAkaiIkaiItIClzQRR3IilqIi4gFmogKyAfc0EYdyIfICZqIiYgHnNBGXciHiAoaiAhaiIoIANqICggG3NBEHciGyAsaiIoIB5zQRR3Ih5qIisgG3NBGHciGyAoaiIoIB5zQRl3Ih5qIiwgFGogMCAkIB1zQRl3Ih1qIAJqIiQgGWogJCAfc0EQdyIfICMgJ2oiI2oiJCAdc0EUdyIdaiInIB9zQRh3Ih8gLHNBEHciLCAjICJzQRl3IiIgJWogAWoiIyAgaiAjIC9zQRB3IiMgJmoiJSAic0EUdyIiaiImICNzQRh3IiMgJWoiJWoiLyAec0EUdyIeaiIwICxzQRh3IiwgL2oiLyAec0EZdyIeICsgHGogJSAic0EZdyIiaiIlICFqIC4gKnNBGHciKiAlc0EQdyIlIB8gJGoiH2oiJCAic0EUdyIiaiIraiATaiIuIBpqIC4gJiAXaiAfIB1zQRl3Ih1qIh8gEmogGyAfc0EQdyIbICogLWoiH2oiJiAdc0EUdyIdaiIqIBtzQRh3IhtzQRB3Ii0gJyAYaiAfIClzQRl3Ih9qIicgBWogIyAnc0EQdyIjIChqIicgH3NBFHciH2oiKCAjc0EYdyIjICdqIidqIikgHnNBFHciHmoiLiAhaiArICVzQRh3IiEgJGoiJCAic0EZdyIiICpqIBVqIiUgA2ogJSAjc0EQdyIjIC9qIiUgInNBFHciImoiKiAjc0EYdyIjICVqIiUgInNBGXciImoiKyATaiAnIB9zQRl3IhMgMGogIGoiHyACaiAfICFzQRB3IiEgGyAmaiIbaiIfIBNzQRR3IhNqIiYgIXNBGHciISArc0EQdyInICggGyAdc0EZdyIbaiAZaiIdIAFqIB0gLHNBEHciHSAkaiIkIBtzQRR3IhtqIiggHXNBGHciHSAkaiIkaiIrICJzQRR3IiJqIiwgJ3NBGHciJyAraiIrICJzQRl3IiIgKiAcaiAkIBtzQRl3IhxqIhsgGGogLiAtc0EYdyIYIBtzQRB3IhsgISAfaiIhaiIfIBxzQRR3IhxqIiRqIBJqIhIgGmogEiAoIBZqICEgE3NBGXciE2oiISACaiAjICFzQRB3IgIgGCApaiIYaiIhIBNzQRR3IhNqIhYgAnNBGHciAnNBEHciEiAmIAVqIBggHnNBGXciBWoiGCAXaiAdIBhzQRB3IhggJWoiFyAFc0EUdyIFaiIaIBhzQRh3IhggF2oiF2oiHSAic0EUdyIeaiIiNgIAIAAgFyAFc0EZdyIFICxqICBqIiAgFGogICAkIBtzQRh3IhRzQRB3IiAgAiAhaiICaiIhIAVzQRR3IgVqIhcgIHNBGHciIDYCMCAAIBYgFCAfaiIUIBxzQRl3IhxqIAFqIgEgFWogASAYc0EQdyIBICtqIhggHHNBFHciFWoiFiABc0EYdyIBIBhqIhggFXNBGXc2AhAgACAXNgIEIAAgAiATc0EZdyICIBpqIANqIhMgGWogEyAnc0EQdyITIBRqIhkgAnNBFHciAmoiAyATc0EYdyITNgI0IAAgIiASc0EYdyISIB1qIhQgHnNBGXc2AhQgACATIBlqIhM2AiAgACAYNgIkIAAgAzYCCCAAIAE2AjggACAgICFqIgEgBXNBGXc2AhggACAUNgIoIAAgFjYCDCAAIBI2AjwgACATIAJzQRl3NgIcIAAgATYCLAulEgsDfwR+An8BfgF/BH4DfwF+An8BfgR/IwBB0AJrIgEkAAJAIABFDQACQAJAQQAtAImKAUEGdEEALQCIigFqIgINAEGACSEDDAELQaCJAUGACUGACCACayICIAAgAiAASRsiAhAEIAAgAmsiAEUNASABQaABakEAKQPQiQE3AwAgAUGoAWpBACkD2IkBNwMAIAFBACkDoIkBIgQ3A3AgAUEAKQOoiQEiBTcDeCABQQApA7CJASIGNwOAASABQQApA7iJASIHNwOIASABQQApA8iJATcDmAFBAC0AiooBIQhBAC0AiYoBIQlBACkDwIkBIQpBAC0AiIoBIQsgAUGwAWpBACkD4IkBNwMAIAFBuAFqQQApA+iJATcDACABQcABakEAKQPwiQE3AwAgAUHIAWpBACkD+IkBNwMAIAFB0AFqQQApA4CKATcDACABIAs6ANgBIAEgCjcDkAEgASAIIAlFckECciIIOgDZASABIAc3A/gBIAEgBjcD8AEgASAFNwPoASABIAQ3A+ABIAEgAUHgAWogAUGYAWogCyAKIAhB/wFxEAIgASkDICEEIAEpAwAhBSABKQMoIQYgASkDCCEHIAEpAzAhDCABKQMQIQ0gASkDOCEOIAEpAxghDyAKEAVBAEIANwOAigFBAEIANwP4iQFBAEIANwPwiQFBAEIANwPoiQFBAEIANwPgiQFBAEIANwPYiQFBAEIANwPQiQFBAEIANwPIiQFBAEEAKQOAiQE3A6CJAUEAQQApA4iJATcDqIkBQQBBACkDkIkBNwOwiQFBAEEAKQOYiQE3A7iJAUEAQQAtAJCKASILQQFqOgCQigFBAEEAKQPAiQFCAXw3A8CJASALQQV0IgtBqYoBaiAOIA+FNwMAIAtBoYoBaiAMIA2FNwMAIAtBmYoBaiAGIAeFNwMAIAtBkYoBaiAEIAWFNwMAQQBBADsBiIoBIAJBgAlqIQMLAkAgAEGBCEkNACABQdQCaiEQQQApA8CJASEEIAFBKGohEQNAIARCCoYhCkIBIABBAXKteUI/hYanIQIDQCACIhJBAXYhAiAKIBJBf2qtg0IAUg0ACyASQQp2rSETAkACQCASQYAISw0AIAFBADsB2AEgAUIANwPQASABQgA3A8gBIAFCADcDwAEgAUIANwO4ASABQgA3A7ABIAFCADcDqAEgAUIANwOgASABQgA3A5gBIAFBACkDgIkBNwNwIAFBACkDiIkBNwN4IAFBACkDkIkBNwOAASABQQAtAIqKAToA2gEgAUEAKQOYiQE3A4gBIAEgBDcDkAEgAUHwAGogAyASEAQgASABKQNwIgQ3AwAgASABKQN4IgU3AwggASABKQOAASIGNwMQIAEgASkDiAEiBzcDGCABIAEpA5gBNwMoIAEgASkDoAE3AzAgASABKQOoATcDOCABLQDaASECIAEtANkBIQsgASkDkAEhCiABIAEtANgBIgg6AGggASAKNwMgIAEgASkDsAE3A0AgASABKQO4ATcDSCABIAEpA8ABNwNQIAEgASkDyAE3A1ggASABKQPQATcDYCABIAIgC0VyQQJyIgI6AGkgASAHNwO4AiABIAY3A7ACIAEgBTcDqAIgASAENwOgAiABQeABaiABQaACaiARIAggCiACQf8BcRACIAEpA4ACIQQgASkD4AEhBSABKQOIAiEGIAEpA+gBIQcgASkDkAIhDCABKQPwASENIAEpA5gCIQ4gASkD+AEhDyAKEAVBAEEALQCQigEiAkEBajoAkIoBIAJBBXQiAkGpigFqIA4gD4U3AwAgAkGhigFqIAwgDYU3AwAgAkGZigFqIAYgB4U3AwAgAkGRigFqIAQgBYU3AwAMAQsCQAJAIAMgEiAEQQAtAIqKASICIAEQBiIUQQJLDQAgASkDGCEKIAEpAxAhBCABKQMIIQUgASkDACEGDAELIAJBBHIhFUEAKQOYiQEhDUEAKQOQiQEhDkEAKQOIiQEhD0EAKQOAiQEhFgNAIBRBfmoiF0EBdiIYQQFqIhlBA3EhCEEAIQkCQCAXQQZJDQAgGUF8cSEaQQAhCSABIQIgECELA0AgCyACQcABajYCACALQXxqIAJBgAFqNgIAIAtBeGogAkHAAGo2AgAgC0F0aiACNgIAIAJBgAJqIQIgC0EQaiELIBogCUEEaiIJRw0ACwsCQCAIRQ0AIAEgCUEGdGohAiABQcgCaiAJQQJ0aiELA0AgCyACNgIAIAJBwABqIQIgC0EEaiELIAhBf2oiCA0ACwsgAUHIAmohCyABQaACaiECIBkhCANAIAsoAgAhCSABIA03A/gBIAEgDjcD8AEgASAPNwPoASABIBY3A+ABIAFB8ABqIAFB4AFqIAlBwABCACAVEAIgASkDkAEhCiABKQNwIQQgASkDmAEhBSABKQN4IQYgASkDoAEhByABKQOAASEMIAJBGGogASkDqAEgASkDiAGFNwMAIAJBEGogByAMhTcDACACQQhqIAUgBoU3AwAgAiAKIASFNwMAIAJBIGohAiALQQRqIQsgCEF/aiIIDQALAkACQCAXQX5xQQJqIBRJDQAgGSEUDAELIAFBoAJqIBlBBXRqIgIgASAZQQZ0aiILKQMANwMAIAIgCykDCDcDCCACIAspAxA3AxAgAiALKQMYNwMYIBhBAmohFAsgASABKQOgAiIGNwMAIAEgASkDqAIiBTcDCCABIAEpA7ACIgQ3AxAgASABKQO4AiIKNwMYIBRBAksNAAsLIAEpAyAhByABKQMoIQwgASkDMCENIAEpAzghDkEAKQPAiQEQBUEAQQAtAJCKASICQQFqOgCQigEgAkEFdCICQamKAWogCjcDACACQaGKAWogBDcDACACQZmKAWogBTcDACACQZGKAWogBjcDAEEAKQPAiQEgE0IBiHwQBUEAQQAtAJCKASICQQFqOgCQigEgAkEFdCICQamKAWogDjcDACACQaGKAWogDTcDACACQZmKAWogDDcDACACQZGKAWogBzcDAAtBAEEAKQPAiQEgE3wiBDcDwIkBIAMgEmohAyAAIBJrIgBBgAhLDQALIABFDQELQaCJASADIAAQBEEAKQPAiQEQBQsgAUHQAmokAAuGBwIJfwF+IwBBwABrIgMkAAJAAkAgAC0AaCIERQ0AAkBBwAAgBGsiBSACIAUgAkkbIgZFDQAgBkEDcSEHQQAhBQJAIAZBBEkNACAAIARqIQggBkF8cSEJQQAhBQNAIAggBWoiCkEoaiABIAVqIgstAAA6AAAgCkEpaiALQQFqLQAAOgAAIApBKmogC0ECai0AADoAACAKQStqIAtBA2otAAA6AAAgCSAFQQRqIgVHDQALCwJAIAdFDQAgASAFaiEKIAUgBGogAGpBKGohBQNAIAUgCi0AADoAACAKQQFqIQogBUEBaiEFIAdBf2oiBw0ACwsgAC0AaCEECyAAIAQgBmoiBzoAaCABIAZqIQECQCACIAZrIgINAEEAIQIMAgsgAyAAIABBKGpBwAAgACkDICAALQBqIABB6QBqIgUtAAAiCkVyEAIgACADKQMgIAMpAwCFNwMAIAAgAykDKCADKQMIhTcDCCAAIAMpAzAgAykDEIU3AxAgACADKQM4IAMpAxiFNwMYIABBADoAaCAFIApBAWo6AAAgAEHgAGpCADcDACAAQdgAakIANwMAIABB0ABqQgA3AwAgAEHIAGpCADcDACAAQcAAakIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEIANwMoC0EAIQcgAkHBAEkNACAAQekAaiIKLQAAIQUgAC0AaiELIAApAyAhDANAIAMgACABQcAAIAwgCyAFQf8BcUVyQf8BcRACIAAgAykDICADKQMAhTcDACAAIAMpAyggAykDCIU3AwggACADKQMwIAMpAxCFNwMQIAAgAykDOCADKQMYhTcDGCAKIAVBAWoiBToAACABQcAAaiEBIAJBQGoiAkHAAEsNAAsLAkBBwAAgB0H/AXEiBmsiBSACIAUgAkkbIglFDQAgCUEDcSELQQAhBQJAIAlBBEkNACAAIAZqIQcgCUH8AHEhCEEAIQUDQCAHIAVqIgJBKGogASAFaiIKLQAAOgAAIAJBKWogCkEBai0AADoAACACQSpqIApBAmotAAA6AAAgAkEraiAKQQNqLQAAOgAAIAggBUEEaiIFRw0ACwsCQCALRQ0AIAEgBWohASAFIAZqIABqQShqIQUDQCAFIAEtAAA6AAAgAUEBaiEBIAVBAWohBSALQX9qIgsNAAsLIAAtAGghBwsgACAHIAlqOgBoIANBwABqJAAL3gMEBX8DfgV/Bn4jAEHQAWsiASQAAkAgAHunIgJBAC0AkIoBIgNPDQBBAC0AiooBQQRyIQQgAUEoaiEFQQApA5iJASEAQQApA5CJASEGQQApA4iJASEHQQApA4CJASEIIAMhCQNAIAEgADcDGCABIAY3AxAgASAHNwMIIAEgCDcDACABIANBBXQiA0HRiQFqIgopAwA3AyggASADQdmJAWoiCykDADcDMCABIANB4YkBaiIMKQMANwM4IAEgA0HpiQFqIg0pAwA3A0AgASADQfGJAWopAwA3A0ggASADQfmJAWopAwA3A1AgASADQYGKAWopAwA3A1ggA0GJigFqKQMAIQ4gAUHAADoAaCABIA43A2AgAUIANwMgIAEgBDoAaSABIAA3A4gBIAEgBjcDgAEgASAHNwN4IAEgCDcDcCABQZABaiABQfAAaiAFQcAAQgAgBEH/AXEQAiABKQOwASEOIAEpA5ABIQ8gASkDuAEhECABKQOYASERIAEpA8ABIRIgASkDoAEhEyANIAEpA8gBIAEpA6gBhTcDACAMIBIgE4U3AwAgCyAQIBGFNwMAIAogDiAPhTcDACAJQX9qIglB/wFxIgMgAksNAAtBACAJOgCQigELIAFB0AFqJAALwwkCCn8FfiMAQeACayIFJAACQAJAIAFBgAhLDQAgBSAANgL8ASAFQfwBaiABQYAIRiIGQRAgAkEBIANBAUECIAQQASAGQQp0IgcgAU8NASAFQeAAaiIGQgA3AwAgBUHYAGoiCEIANwMAIAVB0ABqIglCADcDACAFQcgAaiIKQgA3AwAgBUHAAGoiC0IANwMAIAVBOGoiDEIANwMAIAVBMGoiDUIANwMAIAUgAzoAaiAFQgA3AyggBUEAOwFoIAVBACkDgIkBNwMAIAVBACkDiIkBNwMIIAVBACkDkIkBNwMQIAVBACkDmIkBNwMYIAUgAUGACEYiDq0gAnw3AyAgBSAAIAdqQQAgASAOGxAEIAVBiAFqQTBqIA0pAwA3AwAgBUGIAWpBOGogDCkDADcDACAFIAUpAwAiDzcDiAEgBSAFKQMIIhA3A5ABIAUgBSkDECIRNwOYASAFIAUpAxgiEjcDoAEgBSAFKQMoNwOwASAFLQBqIQAgBS0AaSEHIAUpAyAhAiAFLQBoIQEgBUGIAWpBwABqIAspAwA3AwAgBUGIAWpByABqIAopAwA3AwAgBUGIAWpB0ABqIAkpAwA3AwAgBUGIAWpB2ABqIAgpAwA3AwAgBUGIAWpB4ABqIAYpAwA3AwAgBSABOgDwASAFIAI3A6gBIAUgACAHRXJBAnIiADoA8QEgBSASNwOYAiAFIBE3A5ACIAUgEDcDiAIgBSAPNwOAAiAFQaACaiAFQYACaiAFQ
eKey:uj(t,n),publicKey:n}}(e);return new Sj(t,n)}function kj(e,t){var n;if((e=Uint8Array.from(null!==(n=e)&&void 0!==n?n:[])).length!==t)throw new pK("Key must be a Uint8Array of length ".concat(t,", got ").concat(e.length),"ERR_INVALID_KEY_TYPE");return e}function Rj(e,t){let n=Uint8Array.from(e.abs().toByteArray());if(n=0===n[0]?n.subarray(1):n,null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return(0,Su.B)(n,"base64url")}function xj(e){const t=function(e,t){let n=(0,mu.m)(e,"base64urlpad");if(null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return n}(e);return new(yu().jsbn.BigInteger)((0,Su.B)(t,"base16"),16)}const Pj={"P-256":256,"P-384":384,"P-521":521};Object.keys(Pj).join(" / ");function Dj(e,t){return t.map((t=>xj(e[t])))}async function Oj(e){const t=[await gj.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await Bj(e)],n=await Nj({privateKey:t[0],publicKey:t[1]});return{privateKey:n[0],publicKey:n[1]}}async function Nj(e){if(null==e.privateKey||null==e.publicKey)throw new pK("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([gj.get().subtle.exportKey("jwk",e.privateKey),gj.get().subtle.exportKey("jwk",e.publicKey)])}async function Bj(e){return gj.get().subtle.importKey("jwk",{kty:e.kty,n:e.n,e:e.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function Lj(e,t,n,r){const i=t?function(e){return yu().pki.setRsaPublicKey(...Dj(e,["n","e"]))}(e):function(e){return yu().pki.setRsaPrivateKey(...Dj(e,["n","e","d","p","q","dp","dq","qi"]))}(e),o=r((0,Su.B)(Uint8Array.from(n),"ascii"),i);return(0,mu.m)(o,"ascii")}function Mj(e){if("RSA"!==e.kty)throw new pK("invalid key type","ERR_INVALID_KEY_TYPE");if(null==e.n)throw new pK("invalid key modulus","ERR_INVALID_KEY_MODULUS");return 8*(0,mu.m)(e.n,"base64url").length}const Uj=8192;class Fj{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=e}async verify(e,t){return async function(e,t,n){const r=await gj.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return gj.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,t,n)}(this._key,t,e)}marshal(){return function(e){if(null==e.n||null==e.e)throw new pK("JWK was missing components","ERR_INVALID_PARAMETERS");const t=yu().pki.publicKeyToAsn1({n:xj(e.n),e:xj(e.e)});return(0,mu.m)(yu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return wj.encode({Type:vj.RSA,Data:this.marshal()}).subarray()}encrypt(e){return Lj(this._key,!0,e,((e,t)=>t.encrypt(e)))}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await oj.digest(this.bytes);return e}}class Kj{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=t}genSecret(){return function(e){if(isNaN(e)||e<=0)throw new pK("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return Ic(e)}(16)}async sign(e){return async function(e,t){const n=await gj.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await gj.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,Uint8Array.from(t));return new Uint8Array(r,0,r.byteLength)}(this._key,e)}get public(){if(null==this._publicKey)throw new pK("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new Fj(this._publicKey)}decrypt(e){return Lj(this._key,!1,e,((e,t)=>t.decrypt(e)))}marshal(){return function(e){if(null==e.n||null==e.e||null==e.d||null==e.p||null==e.q||null==e.dp||null==e.dq||null==e.qi)throw new pK("JWK was missing components","ERR_INVALID_PARAMETERS");const t=yu().pki.privateKeyToAsn1({n:xj(e.n),e:xj(e.e),d:xj(e.d),p:xj(e.p),q:xj(e.q),dP:xj(e.dp),dQ:xj(e.dq),qInv:xj(e.qi)});return(0,mu.m)(yu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return Ej.encode({Type:vj.RSA,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await oj.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Su.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"pkcs-8";if("pkcs-8"===t){const t=new(yu().util.ByteBuffer)(this.marshal()),n=yu().asn1.fromDer(t),r=yu().pki.privateKeyFromAsn1(n),i={algorithm:"aes256",count:1e4,saltSize:16,prfAlgorithm:"sha512"};return yu().pki.encryptRsaPrivateKey(r,e,i)}if("libp2p-key"===t)return mj(this.bytes,e);throw new pK("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}async function jj(e){const t=function(e){const t=yu().asn1.fromDer((0,Su.B)(e,"ascii")),n=yu().pki.privateKeyFromAsn1(t);return{kty:"RSA",n:Rj(n.n),e:Rj(n.e),d:Rj(n.d),p:Rj(n.p),q:Rj(n.q),dp:Rj(n.dP),dq:Rj(n.dQ),qi:Rj(n.qInv),alg:"RS256"}}(e);if(Mj(t)>Uj)throw new pK("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const n=await Oj(t);return new Kj(n.privateKey,n.publicKey)}function Zj(e){const t=function(e){const t=yu().asn1.fromDer((0,Su.B)(e,"ascii")),n=yu().pki.publicKeyFromAsn1(t);return{kty:"RSA",n:Rj(n.n),e:Rj(n.e)}}(e);if(Mj(t)>Uj)throw new pK("key size is too large","ERR_KEY_SIZE_TOO_LARGE");return new Fj(t)}async function zj(e){if(Mj(e)>Uj)throw new pK("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await Oj(e);return new Kj(t.privateKey,t.publicKey)}async function Vj(e){if(e>Uj)throw new pK("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await async function(e){const t=await gj.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await Nj(t);return{privateKey:n[0],publicKey:n[1]}}(e);return new Kj(t.privateKey,t.publicKey)}function Hj(e){try{Ah.ProjectivePoint.fromHex(e)}catch(t){throw new pK(String(t),"ERR_INVALID_PUBLIC_KEY")}}class qj{constructor(e){(0,Yo.Z)(this,"_key",void 0),Hj(e),this._key=e}async verify(e,t){return async function(e,t,n){try{const{digest:r}=await oj.digest(n);return Ah.verify(t,r,e)}catch(r){throw new pK(String(r),"ERR_INVALID_INPUT")}}(this._key,t,e)}marshal(){return e=this._key,Ah.ProjectivePoint.fromHex(e).toRawBytes(!0);var e}get bytes(){return wj.encode({Type:vj.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await oj.digest(this.bytes);return e}}class Gj{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=null!==t&&void 0!==t?t:function(e){try{return Ah.getPublicKey(e,!0)}catch(t){throw new pK(String(t),"ERR_INVALID_PRIVATE_KEY")}}(e),function(e){try{Ah.getPublicKey(e,!0)}catch(t){throw new pK(String(t),"ERR_INVALID_PRIVATE_KEY")}}(this._key),Hj(this._publicKey)}async sign(e){return async function(e,t){const{digest:n}=await oj.digest(t);try{return Ah.sign(n,e).toDERRawBytes()}catch(r){throw new pK(String(r),"ERR_INVALID_INPUT")}}(this._key,e)}get public(){return new qj(this._publicKey)}marshal(){return this._key}get bytes(){return Ej.encode({Type:vj.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await oj.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Su.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return mj(this.bytes,e);throw new pK("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function Wj(e){return new Gj(e)}function Qj(e){return new qj(e)}async function Yj(){const e=Ah.utils.randomPrivateKey();return new Gj(e)}const Jj={rsa:kt,ed25519:Tt,secp256k1:Rt};function Xj(e){const t=Object.keys(Jj).join(" / ");return new pK("invalid or unsupported key type ".concat(e,". Must be ").concat(t),"ERR_UNSUPPORTED_KEY_TYPE")}async function $j(e){var t,n;const r=Ej.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case vj.RSA:return Jj.rsa.unmarshalRsaPrivateKey(i);case vj.Ed25519:return Jj.ed25519.unmarshalEd25519PrivateKey(i);case vj.Secp256k1:return Jj.secp256k1.unmarshalSecp256k1PrivateKey(i);default:throw Xj(null!==(n=r.Type)&&void 0!==n?n:"RSA")}}const eZ=Symbol.for("@libp2p/peer-id");const tZ=TK({prefix:"9",name:"base10",alphabet:"0123456789"}),nZ=kK({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),rZ=kK({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),iZ=kK({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),oZ=Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42"),sZ=oZ.reduce(((e,t,n)=>(e[n]=t,e)),[]),aZ=oZ.reduce(((e,t,n)=>(e[t.codePointAt(0)]=n,e)),[]);const cZ=CK({prefix:"\ud83d\ude80",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=sZ[t]),"")},decode:function(e){const t=[];for(const n of e){const e=aZ[n.codePointAt(0)];if(void 0===e)throw new Error("Non-base256emoji character: ".concat(n));t.push(e)}return new Uint8Array(t)}}),lZ=kK({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),uZ=kK({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),hZ=kK({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),dZ=kK({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),fZ=kK({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),pZ=kK({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),gZ=kK({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),yZ=kK({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),mZ=kK({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),vZ=TK({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),bZ=TK({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),wZ=kK({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),EZ=CK({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>(e=>(new TextEncoder).encode(e))(e)}),AZ=new TextEncoder,SZ=new TextDecoder,_Z="json",IZ=512,CZ=e=>AZ.encode(JSON.stringify(e)),TZ=e=>JSON.parse(SZ.decode(e)),kZ="raw",RZ=85,xZ=e=>wK(e),PZ=e=>wK(e),DZ=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?MZ(n,NZ(e),t||RK.encoder):UZ(n,NZ(e),t||lZ.encoder)},OZ=new WeakMap,NZ=e=>{const t=OZ.get(e);if(null==t){const t=new Map;return OZ.set(e,t),t}return t};class BZ{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==FZ)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==KZ)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return BZ.createV0(t)}default:throw Error("Can not convert CID version ".concat(this.version," to version 0. This is a bug please report"))}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=JK(e,t);return BZ.createV1(this.code,n)}case 1:return this;default:throw Error("Can not convert CID version ".concat(this.version," to version 1. This is a bug please report"))}}equals(e){return BZ.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&((e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}})(e.multihash,n.multihash)}toString(e){return DZ(this,e)}toJSON(){return{"/":DZ(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID(".concat(this.toString(),")")}static asCID(e){if(null==e)return null;const t=e;if(t instanceof BZ)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new BZ(e,n,r,i||jZ(e,n,r.bytes))}if(!0===t[ZZ]){const{version:e,multihash:n,code:r}=t,i=XK(n);return BZ.create(e,r,i)}return null}static create(e,t,n){if("number"!==typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==FZ)throw new Error("Version 0 CID must use dag-pb (code: ".concat(FZ,") block encoding"));return new BZ(e,t,n,n.bytes);case 1:{const r=jZ(e,t,n.bytes);return new BZ(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return BZ.create(0,FZ,e)}static createV1(e,t){return BZ.create(1,e,t)}static decode(e){const[t,n]=BZ.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=BZ.inspectBytes(e),n=t.size-t.multihashSize,r=wK(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),o=new $K(t.multihashCode,t.digestSize,i,r);return[0===t.version?BZ.createV0(o):BZ.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=WK(e.subarray(t));return t+=r,n};let r=n(),i=FZ;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version ".concat(r));const o=t,s=n(),a=n(),c=t+a;return{version:r,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[n,r]=LZ(e,t),i=BZ.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return NZ(i).set(n,e),i}}const LZ=(e,t)=>{switch(e[0]){case"Q":{const n=t||RK;return[RK.prefix,n.decode("".concat(RK.prefix).concat(e))]}case RK.prefix:{const n=t||RK;return[RK.prefix,n.decode(e)]}case lZ.prefix:{const n=t||lZ;return[lZ.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},MZ=(e,t,n)=>{const{prefix:r}=n;if(r!==RK.prefix)throw Error("Cannot string encode V0 in ".concat(n.name," encoding"));const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i},UZ=(e,t,n)=>{const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i},FZ=112,KZ=18,jZ=(e,t,n)=>{const r=YK(e),i=r+YK(t),o=new Uint8Array(i+n.byteLength);return QK(e,o,0),QK(t,o,r),o.set(n,i),o},ZZ=Symbol.for("@ipld/js-cid/CID"),zZ={...Mt,...Dt,...Lt,...xt,...Pt,...Nt,...Bt,...St,...Ct,...Ot};let VZ;const HZ=Symbol.for("nodejs.util.inspect.custom"),qZ=Object.values(zZ).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)),zZ.identity.decoder),GZ=114,WZ=36,QZ=37;VZ=Symbol.toStringTag;class YZ{constructor(e){(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"multihash",void 0),(0,Yo.Z)(this,"privateKey",void 0),(0,Yo.Z)(this,"publicKey",void 0),(0,Yo.Z)(this,"string",void 0),(0,Yo.Z)(this,eZ,!0),this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[VZ](){return"PeerId(".concat(this.toString(),")")}toString(){return null==this.string&&(this.string=RK.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return BZ.createV1(GZ,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e instanceof Uint8Array)return(0,Ms.f)(this.multihash.bytes,e);if("string"===typeof e)return function(e,t){var n;if(t=null!==(n=t)&&void 0!==n?n:qZ,"1"===e.charAt(0)||"Q"===e.charAt(0)){const t=XK(RK.decode("z".concat(e)));return e.startsWith("12D")?new XZ({multihash:t}):e.startsWith("16U")?new $Z({multihash:t}):new JZ({multihash:t})}return function(e){try{const t=XK(e);if(t.code===tj.code){if(t.digest.length===WZ)return new XZ({multihash:t});if(t.digest.length===QZ)return new $Z({multihash:t})}if(t.code===oj.code)return new JZ({multihash:t})}catch{return function(e){if(null==e||null==e.multihash||null==e.version||1===e.version&&e.code!==GZ)throw new Error("Supplied PeerID CID is invalid");const t=e.multihash;if(t.code===oj.code)return new JZ({multihash:e.multihash});if(t.code===tj.code){if(t.digest.length===WZ)return new XZ({multihash:e.multihash});if(t.digest.length===QZ)return new $Z({multihash:e.multihash})}throw new Error("Supplied PeerID CID is invalid")}(BZ.decode(e))}throw new Error("Supplied PeerID CID is invalid")}(qZ.decode(e))}(e).equals(this);if(null!=(null===e||void 0===e||null===(t=e.multihash)||void 0===t?void 0:t.bytes))return(0,Ms.f)(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[HZ](){return"PeerId(".concat(this.toString(),")")}}class JZ extends YZ{constructor(e){super({...e,type:"RSA"}),(0,Yo.Z)(this,"type","RSA"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.publicKey}}class XZ extends YZ{constructor(e){super({...e,type:"Ed25519"}),(0,Yo.Z)(this,"type","Ed25519"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}class $Z extends YZ{constructor(e){super({...e,type:"secp256k1"}),(0,Yo.Z)(this,"type","secp256k1"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}async function ez(e,t){return e.length===WZ?new XZ({multihash:JK(tj.code,e),privateKey:t}):e.length===QZ?new $Z({multihash:JK(tj.code,e),privateKey:t}):new JZ({multihash:await oj.digest(e),publicKey:e,privateKey:t})}var tz,nz;async function rz(e,t,n){const r=await async function(e,t){if(null==e.privateKey)throw new Error("PrivateKey was missing from PeerId");return(await $j(e.privateKey)).sign(t)}(e,sz(t));if(null==e.publicKey)throw new Error("PublicKey was missing from local PeerId");return function(e,t,n){return nz.encode({identityKey:e,identitySig:t,extensions:null!==n&&void 0!==n?n:{webtransportCerthashes:[]}}).subarray()}(e.publicKey,r,n)}async function iz(e){return ez(e.identityKey)}function oz(e){return nz.decode(e)}function sz(e){const t=(0,mu.m)("noise-libp2p-static-key:");return(0,Ls.z)([t,e],t.length+e.length)}async function az(e,t,n){const r=await ez(t.identityKey);if(!r.equals(n))throw new Error("Payload identity key ".concat(r.toString()," does not match expected remote peer ").concat(n.toString()));const i=sz(e);if(null==r.publicKey)throw new Error("PublicKey was missing from PeerId");if(null==t.identitySig)throw new Error("Signature was missing from message");const o=function(e){var t,n;const r=wj.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case vj.RSA:return Jj.rsa.unmarshalRsaPublicKey(i);case vj.Ed25519:return Jj.ed25519.unmarshalEd25519PublicKey(i);case vj.Secp256k1:return Jj.secp256k1.unmarshalSecp256k1PublicKey(i);default:throw Xj(null!==(n=r.Type)&&void 0!==n?n:"unknown")}}(r.publicKey);if(!await o.verify(i,t.identitySig))throw new Error("Static key doesn't match to peer that signed payload!");return r}function cz(e){return e instanceof Uint8Array&&32===e.length}function lz(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return cf().enabled("".concat(e,":trace"))&&null!=cf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=cf()("".concat(e,":trace"))),Object.assign(cf()(e),{error:cf()("".concat(e,":error")),trace:t})}!function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==n.lengthDelimited&&t.fork(),null!=e.webtransportCerthashes)for(const r of e.webtransportCerthashes)t.uint32(10),t.bytes(r);!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={webtransportCerthashes:[]},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();if(t>>>3===1)n.webtransportCerthashes.push(e.bytes());else e.skipType(7&t)}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(tz||(tz={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.identityKey&&e.identityKey.byteLength>0&&(t.uint32(10),t.bytes(e.identityKey)),null!=e.identitySig&&e.identitySig.byteLength>0&&(t.uint32(18),t.bytes(e.identitySig)),null!=e.extensions&&(t.uint32(34),tz.codec().encode(e.extensions,t)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={identityKey:(0,Us.u)(0),identitySig:(0,Us.u)(0)},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.identityKey=e.bytes();break;case 2:n.identitySig=e.bytes();break;case 4:n.extensions=tz.codec().decode(e,e.uint32());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(nz||(nz={})),cf().formatters.b=e=>null==e?"undefined":RK.baseEncode(e),cf().formatters.t=e=>null==e?"undefined":lZ.baseEncode(e),cf().formatters.m=e=>null==e?"undefined":hj.baseEncode(e),cf().formatters.p=e=>null==e?"undefined":e.toString(),cf().formatters.c=e=>null==e?"undefined":e.toString(),cf().formatters.k=e=>null==e?"undefined":e.toString(),cf().formatters.a=e=>null==e?"undefined":e.toString();const uz=lz("libp2p:noise");let hz;function dz(e){e?(hz("LOCAL_PUBLIC_EPHEMERAL_KEY ".concat((0,Su.B)(e.publicKey,"hex"))),hz("LOCAL_PRIVATE_EPHEMERAL_KEY ".concat((0,Su.B)(e.privateKey,"hex")))):hz("Missing local ephemeral keys.")}function fz(e){hz("REMOTE_EPHEMERAL_PUBLIC_KEY ".concat((0,Su.B)(e,"hex")))}hz=oK?uz:Object.assign((()=>{}),{enabled:!1,trace:()=>{},error:()=>{}});class pz{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;(0,Yo.Z)(this,"n",void 0),(0,Yo.Z)(this,"bytes",void 0),(0,Yo.Z)(this,"view",void 0),this.n=e,this.bytes=(0,Us.u)(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>4294967295)throw new Error("Cipherstate has reached maximum n, a new handshake must be performed")}}class gz{constructor(e){(0,Yo.Z)(this,"crypto",void 0),this.crypto=e}encryptWithAd(e,t,n){const r=this.encrypt(e.k,e.n,t,n);return e.n.increment(),r}decryptWithAd(e,t,n,r){const{plaintext:i,valid:o}=this.decrypt(e.k,e.n,t,n,r);return o&&e.n.increment(),{plaintext:i,valid:o}}hasKey(e){return!this.isEmptyKey(e.k)}createEmptyKey(){return(0,Us.u)(32)}isEmptyKey(e){const t=this.createEmptyKey();return(0,Ms.f)(t,e)}encrypt(e,t,n,r){return t.assertValue(),this.crypto.chaCha20Poly1305Encrypt(r,t.getBytes(),n,e)}encryptAndHash(e,t){let n;return n=this.hasKey(e.cs)?this.encryptWithAd(e.cs,e.h,t):t,this.mixHash(e,n),n}decrypt(e,t,n,r,i){t.assertValue();const o=this.crypto.chaCha20Poly1305Decrypt(r,t.getBytes(),n,e,i);return o?{plaintext:o,valid:!0}:{plaintext:(0,Us.u)(0),valid:!1}}decryptAndHash(e,t){let n,r=!0;return this.hasKey(e.cs)?({plaintext:n,valid:r}=this.decryptWithAd(e.cs,e.h,t)):n=t,this.mixHash(e,t),{plaintext:n,valid:r}}dh(e,t){try{const n=this.crypto.generateX25519SharedKey(e,t);return 32===n.length?n:n.subarray(0,32)}catch(n){const e=n;return uz.error(e),(0,Us.u)(32)}}mixHash(e,t){e.h=this.getHash(e.h,t)}getHash(e,t){return this.crypto.hashSHA256((0,Ls.z)([e,t],e.length+t.length))}mixKey(e,t){const[n,r]=this.crypto.getHKDF(e.ck,t);e.cs=this.initializeKey(r),e.ck=n}initializeKey(e){return{k:e,n:new pz}}initializeSymmetric(e){const t=(0,ed.mL)(e,"utf-8"),n=this.hashProtocolName(t),r=n,i=this.createEmptyKey();return{cs:this.initializeKey(i),ck:r,h:n}}hashProtocolName(e){if(e.length<=32){const t=(0,Us.u)(32);return t.set(e),t}return this.getHash(e,(0,Us.u)(0))}split(e){const[t,n]=this.crypto.getHKDF(e.ck,(0,Us.u)(0));return{cs1:this.initializeKey(t),cs2:this.initializeKey(n)}}writeMessageRegular(e,t){const n=this.encryptWithAd(e,(0,Us.u)(0),t);return{ne:this.createEmptyKey(),ns:(0,Us.u)(0),ciphertext:n}}readMessageRegular(e,t){return this.decryptWithAd(e,(0,Us.u)(0),t.ciphertext)}}class yz extends gz{initializeInitiator(e,t,n,r){const i=this.initializeSymmetric("Noise_XX_25519_ChaChaPoly_SHA256");this.mixHash(i,e);return{ss:i,s:t,rs:n,psk:r,re:(0,Us.u)(32)}}initializeResponder(e,t,n,r){const i=this.initializeSymmetric("Noise_XX_25519_ChaChaPoly_SHA256");this.mixHash(i,e);return{ss:i,s:t,rs:n,psk:r,re:(0,Us.u)(32)}}writeMessageA(e,t,n){const r=(0,Us.u)(0);e.e=void 0!==n?n:this.crypto.generateX25519KeyPair();const i=e.e.publicKey;this.mixHash(e.ss,i);return{ne:i,ns:r,ciphertext:this.encryptAndHash(e.ss,t)}}writeMessageB(e,t){e.e=this.crypto.generateX25519KeyPair();const n=e.e.publicKey;this.mixHash(e.ss,n),this.mixKey(e.ss,this.dh(e.e.privateKey,e.re));const r=e.s.publicKey,i=this.encryptAndHash(e.ss,r);this.mixKey(e.ss,this.dh(e.s.privateKey,e.re));return{ne:n,ns:i,ciphertext:this.encryptAndHash(e.ss,t)}}writeMessageC(e,t){const n=e.s.publicKey,r=this.encryptAndHash(e.ss,n);this.mixKey(e.ss,this.dh(e.s.privateKey,e.re));const i=this.encryptAndHash(e.ss,t),o={ne:this.createEmptyKey(),ns:r,ciphertext:i},{cs1:s,cs2:a}=this.split(e.ss);return{h:e.ss.h,messageBuffer:o,cs1:s,cs2:a}}readMessageA(e,t){return cz(t.ne)&&(e.re=t.ne),this.mixHash(e.ss,e.re),this.decryptAndHash(e.ss,t.ciphertext)}readMessageB(e,t){if(cz(t.ne)&&(e.re=t.ne),this.mixHash(e.ss,e.re),!e.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(e.ss,this.dh(e.e.privateKey,e.re));const{plaintext:n,valid:r}=this.decryptAndHash(e.ss,t.ns);r&&cz(n)&&(e.rs=n),this.mixKey(e.ss,this.dh(e.e.privateKey,e.rs));const{plaintext:i,valid:o}=this.decryptAndHash(e.ss,t.ciphertext);return{plaintext:i,valid:r&&o}}readMessageC(e,t){const{plaintext:n,valid:r}=this.decryptAndHash(e.ss,t.ns);if(r&&cz(n)&&(e.rs=n),!e.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(e.ss,this.dh(e.e.privateKey,e.rs));const{plaintext:i,valid:o}=this.decryptAndHash(e.ss,t.ciphertext),{cs1:s,cs2:a}=this.split(e.ss);return{h:e.ss.h,plaintext:i,valid:r&&o,cs1:s,cs2:a}}initSession(e,t,n){const r=this.createEmptyKey(),i=(0,Us.u)(32);let o;return o=e?this.initializeInitiator(t,n,i,r):this.initializeResponder(t,n,i,r),{hs:o,i:e,mc:0}}sendMessage(e,t,n){let r;if(0===e.mc)r=this.writeMessageA(e.hs,t,n);else if(1===e.mc)r=this.writeMessageB(e.hs,t);else if(2===e.mc){const{h:n,messageBuffer:i,cs1:o,cs2:s}=this.writeMessageC(e.hs,t);r=i,e.h=n,e.cs1=o,e.cs2=s}else{if(!(e.mc>2))throw new Error("Session invalid.");if(e.i){if(!e.cs1)throw new Error("CS1 (cipher state) is not defined");r=this.writeMessageRegular(e.cs1,t)}else{if(!e.cs2)throw new Error("CS2 (cipher state) is not defined");r=this.writeMessageRegular(e.cs2,t)}}return e.mc++,r}recvMessage(e,t){let n=(0,Us.u)(0),r=!1;if(0===e.mc)({plaintext:n,valid:r}=this.readMessageA(e.hs,t));else if(1===e.mc)({plaintext:n,valid:r}=this.readMessageB(e.hs,t));else if(2===e.mc){const{h:i,plaintext:o,valid:s,cs1:a,cs2:c}=this.readMessageC(e.hs,t);n=o,r=s,e.h=i,e.cs1=a,e.cs2=c}return e.mc++,{plaintext:n,valid:r}}}class mz{constructor(e,t,n,r,i,o,s,a){(0,Yo.Z)(this,"isInitiator",void 0),(0,Yo.Z)(this,"session",void 0),(0,Yo.Z)(this,"remotePeer",void 0),(0,Yo.Z)(this,"remoteExtensions",{webtransportCerthashes:[]}),(0,Yo.Z)(this,"payload",void 0),(0,Yo.Z)(this,"connection",void 0),(0,Yo.Z)(this,"xx",void 0),(0,Yo.Z)(this,"staticKeypair",void 0),(0,Yo.Z)(this,"prologue",void 0),this.isInitiator=e,this.payload=t,this.prologue=n,this.staticKeypair=i,this.connection=o,s&&(this.remotePeer=s),this.xx=null!==a&&void 0!==a?a:new yz(r),this.session=this.xx.initSession(this.isInitiator,this.prologue,this.staticKeypair)}async propose(){var e;if(e=this.session.hs.s,hz("LOCAL_STATIC_PUBLIC_KEY ".concat((0,Su.B)(e.publicKey,"hex"))),hz("LOCAL_STATIC_PRIVATE_KEY ".concat((0,Su.B)(e.privateKey,"hex"))),this.isInitiator){uz.trace("Stage 0 - Initiator starting to send first message.");const e=this.xx.sendMessage(this.session,(0,Us.u)(0));await this.connection.write(function(e){return(0,Ls.z)([e.ne,e.ciphertext],e.ne.length+e.ciphertext.length)}(e)),uz.trace("Stage 0 - Initiator finished sending first message."),dz(this.session.hs.e)}else{uz.trace("Stage 0 - Responder waiting to receive first message...");const e=function(e){if(e.length<32)throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");return{ne:e.subarray(0,32),ciphertext:e.subarray(32,e.length),ns:(0,Us.u)(0)}}((await this.connection.read()).subarray()),{valid:t}=this.xx.recvMessage(this.session,e);if(!t)throw new hK("xx handshake stage 0 validation fail");uz.trace("Stage 0 - Responder received first message."),fz(this.session.hs.re)}}async exchange(){if(this.isInitiator){uz.trace("Stage 1 - Initiator waiting to receive first message from responder...");const n=function(e){if(e.length<80)throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");return{ne:e.subarray(0,32),ns:e.subarray(32,80),ciphertext:e.subarray(80,e.length)}}((await this.connection.read()).subarray()),{plaintext:r,valid:i}=this.xx.recvMessage(this.session,n);if(!i)throw new hK("xx handshake stage 1 validation fail");uz.trace("Stage 1 - Initiator received the message."),fz(this.session.hs.re),e=this.session.hs.rs,hz("REMOTE_STATIC_PUBLIC_KEY ".concat((0,Su.B)(e,"hex"))),uz.trace("Initiator going to check remote's signature...");try{const e=oz(r);this.remotePeer=this.remotePeer||await iz(e),await az(this.session.hs.rs,e,this.remotePeer),this.setRemoteNoiseExtension(e.extensions)}catch(t){throw new uK("Error occurred while verifying signed payload: ".concat(t.message))}uz.trace("All good with the signature!")}else{uz.trace("Stage 1 - Responder sending out first message with signed payload and static key.");const e=this.xx.sendMessage(this.session,this.payload);await this.connection.write(function(e){return(0,Ls.z)([e.ne,e.ns,e.ciphertext],e.ne.length+e.ns.length+e.ciphertext.length)}(e)),uz.trace("Stage 1 - Responder sent the second handshake message with signed payload."),dz(this.session.hs.e)}var e}async finish(){if(this.isInitiator){uz.trace("Stage 2 - Initiator sending third handshake message.");const e=this.xx.sendMessage(this.session,this.payload);await this.connection.write(function(e){return(0,Ls.z)([e.ns,e.ciphertext],e.ns.length+e.ciphertext.length)}(e)),uz.trace("Stage 2 - Initiator sent message with signed payload.")}else{uz.trace("Stage 2 - Responder waiting for third handshake message...");const e=function(e){if(e.length<48)throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");return{ne:(0,Us.u)(0),ns:e.subarray(0,48),ciphertext:e.subarray(48,e.length)}}((await this.connection.read()).subarray()),{plaintext:n,valid:r}=this.xx.recvMessage(this.session,e);if(!r)throw new hK("xx handshake stage 2 validation fail");uz.trace("Stage 2 - Responder received the message, finished handshake.");try{const e=oz(n);this.remotePeer=this.remotePeer||await iz(e),await az(this.session.hs.rs,e,this.remotePeer),this.setRemoteNoiseExtension(e.extensions)}catch(t){throw new uK("Error occurred while verifying signed payload: ".concat(t.message))}}var e;(e=this.session).cs1&&e.cs2?(hz("CIPHER_STATE_1 ".concat(e.cs1.n.getUint64()," ").concat((0,Su.B)(e.cs1.k,"hex"))),hz("CIPHER_STATE_2 ".concat(e.cs2.n.getUint64()," ").concat((0,Su.B)(e.cs2.k,"hex")))):hz("Missing cipher state.")}encrypt(e,t){const n=this.getCS(t);return this.xx.encryptWithAd(n,(0,Us.u)(0),e)}decrypt(e,t,n){const r=this.getCS(t,!1);return this.xx.decryptWithAd(r,(0,Us.u)(0),e,n)}getRemoteStaticKey(){return this.session.hs.rs}getCS(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!e.cs1||!e.cs2)throw new hK("Handshake not completed properly, cipher state does not exist.");return this.isInitiator?t?e.cs1:e.cs2:t?e.cs2:e.cs1}setRemoteNoiseExtension(e){e&&(this.remoteExtensions=e)}}class vz{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"protocol","/noise"),(0,Yo.Z)(this,"crypto",void 0),(0,Yo.Z)(this,"prologue",void 0),(0,Yo.Z)(this,"staticKeys",void 0),(0,Yo.Z)(this,"extensions",void 0),(0,Yo.Z)(this,"metrics",void 0);const{staticNoiseKey:t,extensions:n,crypto:r,prologueBytes:i,metrics:o}=e;this.crypto=null!==r&&void 0!==r?r:sK,this.extensions=n,this.metrics=o?function(e){return{xxHandshakeSuccesses:e.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:e.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:e.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:e.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:e.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}(o):void 0,this.staticKeys=t?this.crypto.generateX25519KeyPairFromSeed(t):this.crypto.generateX25519KeyPair(),this.prologue=null!==i&&void 0!==i?i:(0,Us.u)(0)}async secureOutbound(e,t,n){const r=ua(t,{lengthEncoder:aK,lengthDecoder:cK,maxDataLength:iK}),i=await this.performHandshake({connection:r,isInitiator:!0,localPeer:e,remotePeer:n});return{conn:await this.createSecureConnection(r,i),remoteExtensions:i.remoteExtensions,remotePeer:i.remotePeer}}async secureInbound(e,t,n){const r=ua(t,{lengthEncoder:aK,lengthDecoder:cK,maxDataLength:iK}),i=await this.performHandshake({connection:r,isInitiator:!1,localPeer:e,remotePeer:n});return{conn:await this.createSecureConnection(r,i),remotePeer:i.remotePeer,remoteExtensions:i.remoteExtensions}}async performHandshake(e){const t=await rz(e.localPeer,this.staticKeys.publicKey,this.extensions);return this.performXXHandshake(e,t)}async performXXHandshake(e,t){const{isInitiator:n,remotePeer:r,connection:i}=e,o=new mz(n,t,this.prologue,this.crypto,this.staticKeys,i,r);try{var s;await o.propose(),await o.exchange(),await o.finish(),null===(s=this.metrics)||void 0===s||s.xxHandshakeSuccesses.increment()}catch(c){var a;if(null===(a=this.metrics)||void 0===a||a.xxHandshakeErrors.increment(),c instanceof Error)throw c.message="Error occurred during XX handshake: ".concat(c.message),c}return o}async createSecureConnection(e,t){const[n,r]=function(){const e=VF(),t=VF();return[{source:e.source,sink:t.sink},{source:t.source,sink:e.sink}]}(),i=e.unwrap();return await function(e){if(null==e)throw new Error("Empty pipeline");if(eK(e)){const t=e;e=()=>t.source}else if($F(e)||XF(e)){const t=e;e=()=>t}for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const i=[e,...n];if(i.length>1&&eK(i[i.length-1])&&(i[i.length-1]=i[i.length-1].sink),i.length>2)for(let o=1;o<i.length-1;o++)eK(i[o])&&(i[o]=tK(i[o]));return JF(...i)}(n,function(e,t){return async function*(n){for await(const r of n)for(let n=0;n<r.length;n+=65519){let i=n+65519;i>r.length&&(i=r.length);const o=e.encrypt(r.subarray(n,i),e.session);null===t||void 0===t||t.encryptedPackets.increment(),yield(0,ed.zo)([aK(o.byteLength),o],2+o.byteLength)}}}(t,this.metrics),i,(e=>zF(e,{lengthDecoder:cK})),function(e,t){return async function*(n){for await(const r of n)for(let n=0;n<r.length;n+=iK){let i=n+iK;if(i>r.length&&(i=r.length),i-16<n)throw new Error("Invalid chunk");const o=r.subarray(n,i),s=r.subarray(n,i-16),{plaintext:a,valid:c}=e.decrypt(o,e.session,s);if(!c)throw null===t||void 0===t||t.decryptErrors.increment(),new Error("Failed to validate decrypted chunk");null===t||void 0===t||t.decryptedPackets.increment(),yield a}}}(t,this.metrics),n),r}}async function bz(e,t,n,r,i,o){const s=o.forComponent("libp2p:webtransport:stream:".concat(n,":").concat(t)),a=e.writable.getWriter(),c=e.readable.getReader();function l(){const e=r.findIndex((e=>e===f));-1!==e&&(r.splice(e,1),f.timeline.close=Date.now(),null===i||void 0===i||i(f))}await a.ready;let u=!1,h=!1;(async function(){const e=await a.closed.catch((e=>e));if(null!=e){const n=e.message;n.includes("aborted by the remote server")||n.includes("STOP_SENDING")||s.error("WebTransport writer closed unexpectedly: streamId=".concat(t," err=").concat(e.message))}u=!0,u&&h&&l()})().catch((()=>{s.error("WebTransport failed to cleanup closed stream")})),async function(){const e=await c.closed.catch((e=>e));null!=e&&s.error("WebTransport reader closed unexpectedly: streamId=".concat(t," err=").concat(e.message)),h=!0,u&&h&&l()}().catch((()=>{s.error("WebTransport failed to cleanup closed stream")}));let d=!1;const f={id:t,status:"open",writeStatus:"ready",readStatus:"ready",abort(e){u||(a.abort(e).catch((e=>{s.error("could not abort stream",e)})),u=!0),h=!0,this.status="aborted",this.writeStatus="closed",this.readStatus="closed",this.timeline.reset=this.timeline.close=this.timeline.closeRead=this.timeline.closeWrite=Date.now(),l()},async close(e){this.status="closing",await Promise.all([f.closeRead(e),f.closeWrite(e)]),l(),this.status="closed",this.timeline.close=Date.now()},async closeRead(e){if(!h){this.readStatus="closing";try{await c.cancel()}catch(t){!0===t.toString().includes("RESET_STREAM")&&(u=!0)}this.timeline.closeRead=Date.now(),this.readStatus="closed",h=!0}u&&l()},async closeWrite(e){if(!u){u=!0,this.writeStatus="closing";try{await a.close()}catch(t){!0===t.toString().includes("RESET_STREAM")&&(h=!0)}this.timeline.closeWrite=Date.now(),this.writeStatus="closed"}h&&l()},direction:n,timeline:{open:Date.now()},metadata:{},source:async function*(){for(;;){const e=await c.read();if(e.done)return h=!0,void(u&&l());yield new Zs(e.value)}}(),sink:async function(e){if(d)throw new Error("sink already called on stream");d=!0;try{this.writeStatus="writing";for await(const t of e)if(t instanceof Uint8Array)await a.write(t);else for(const e of t)await a.write(e);this.writeStatus="done"}finally{this.timeline.closeWrite=Date.now(),this.writeStatus="closed",await f.closeWrite()}},log:s};return f}function wz(){return{source:{[Symbol.asyncIterator]:()=>({next:async()=>new Promise((()=>{}))})},sink:async e=>new Promise((()=>{}))}}let Ez;const Az=Symbol.for("nodejs.util.inspect.custom"),Sz=Object.values(zZ).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)),zZ.identity.decoder),_z=114,Iz=36,Cz=37;Ez=Symbol.toStringTag;class Tz{constructor(e){(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"multihash",void 0),(0,Yo.Z)(this,"privateKey",void 0),(0,Yo.Z)(this,"publicKey",void 0),(0,Yo.Z)(this,"string",void 0),(0,Yo.Z)(this,pu.Cs,!0),this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Ez](){return"PeerId(".concat(this.toString(),")")}toString(){return null==this.string&&(this.string=RK.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return BZ.createV1(_z,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e instanceof Uint8Array)return(0,Ms.f)(this.multihash.bytes,e);if("string"===typeof e)return Pz(e).equals(this);if(null!=(null===e||void 0===e||null===(t=e.multihash)||void 0===t?void 0:t.bytes))return(0,Ms.f)(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[Az](){return"PeerId(".concat(this.toString(),")")}}class kz extends Tz{constructor(e){super({...e,type:"RSA"}),(0,Yo.Z)(this,"type","RSA"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.publicKey}}class Rz extends Tz{constructor(e){super({...e,type:"Ed25519"}),(0,Yo.Z)(this,"type","Ed25519"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}class xz extends Tz{constructor(e){super({...e,type:"secp256k1"}),(0,Yo.Z)(this,"type","secp256k1"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}function Pz(e,t){var n;if(t=null!==(n=t)&&void 0!==n?n:Sz,"1"===e.charAt(0)||"Q"===e.charAt(0)){const t=XK(RK.decode("z".concat(e)));return e.startsWith("12D")?new Rz({multihash:t}):e.startsWith("16U")?new xz({multihash:t}):new kz({multihash:t})}return function(e){try{const t=XK(e);if(t.code===tj.code){if(t.digest.length===Iz)return new Rz({multihash:t});if(t.digest.length===Cz)return new xz({multihash:t})}if(t.code===oj.code)return new kz({multihash:t})}catch{return function(e){if(null==e||null==e.multihash||null==e.version||1===e.version&&e.code!==_z)throw new Error("Supplied PeerID CID is invalid");const t=e.multihash;if(t.code===oj.code)return new kz({multihash:e.multihash});if(t.code===tj.code){if(t.digest.length===Iz)return new Rz({multihash:e.multihash});if(t.digest.length===Cz)return new xz({multihash:e.multihash})}throw new Error("Supplied PeerID CID is invalid")}(BZ.decode(e))}throw new Error("Supplied PeerID CID is invalid")}(Sz.decode(e))}const Dz=Object.values(zZ).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)));function Oz(e){var t;if(!gO.Mk.matches(e))throw new pu.sv("Invalid multiaddr, was not a WebTransport address","ERR_INVALID_MULTIADDR");const n=e.stringTuples(),r=n.filter((e=>{let[t,n]=e;return t===(0,og.a_)("certhash").code})).map((e=>{let[t,n]=e;return r=null!==n&&void 0!==n?n:"",XK(Dz.decode(r));var r})),i=n.filter((e=>{let[t,n]=e;return t===(0,og.a_)("p2p").code})).map((e=>{let[t,n]=e;return Pz(null!==n&&void 0!==n?n:"")}))[0],o=e.toOptions();let s=o.host;return 6===o.family&&null!==(t=s)&&void 0!==t&&t.includes(":")&&(s="[".concat(s,"]")),{url:"https://".concat(s,":").concat(o.port),certhashes:r,remotePeer:i}}let Nz;Nz=Symbol.toStringTag;class Bz{constructor(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"config",void 0),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,Nz,"@libp2p/webtransport"),(0,Yo.Z)(this,pu.SF,!0),this.log=e.logger.forComponent("libp2p:webtransport"),this.components=e,this.config={maxInboundStreams:null!==(t=n.maxInboundStreams)&&void 0!==t?t:1e3},null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webtransport_dialer_events_total",{label:"event",help:"Total count of WebTransport dialer events by type"})})}async dial(e,t){var n,r,i;null===(n=t)||void 0===n||null===(r=n.signal)||void 0===r||r.throwIfAborted(),this.log("dialing %s",e);const o=this.components.peerId;if(void 0===o)throw new Error("Need a local peerid");t=null!==(i=t)&&void 0!==i?i:{};const{url:s,certhashes:a,remotePeer:c}=Oz(e);if(null==c)throw new Error("Need a target peerid");if(0===a.length)throw new Error("Expected multiaddr to contain certhashes");let l,u,h=()=>{},d=!1,f=!1,p=!1;try{var g,y,m,v;null===(g=this.metrics)||void 0===g||g.dialerEvents.increment({pending:!0});const n=new WebTransport("".concat(s,"/.well-known/libp2p-webtransport?type=noise"),{serverCertificateHashes:a.map((e=>({algorithm:"sha-256",value:e.digest})))});if(h=e=>{if(!d)try{var t;null===(t=this.metrics)||void 0===t||t.dialerEvents.increment({[e]:!0}),n.close()}catch(r){this.log.error("error closing wt session",r)}finally{null!=u&&(u.timeline.close=Date.now()),d=!0}},l=()=>{h(f?"noise_timeout":"ready_timeout")},null===(y=t.signal)||void 0===y||y.addEventListener("abort",l,{once:!0}),await Promise.race([n.closed,n.ready]),f=!0,null===(m=this.metrics)||void 0===m||m.dialerEvents.increment({ready:!0}),n.closed.catch((e=>{this.log.error("error on remote wt session close",e)})).finally((()=>{h("remote_close")})),!await this.authenticateWebTransport(n,o,c,a))throw new Error("Failed to authenticate webtransport");return null===(v=this.metrics)||void 0===v||v.dialerEvents.increment({open:!0}),u={close:async()=>{this.log("Closing webtransport"),h("close")},abort:e=>{this.log("aborting webtransport due to passed err",e),h("abort")},remoteAddr:e,timeline:{open:Date.now()},log:this.components.logger.forComponent("libp2p:webtransport:maconn"),...wz()},p=!0,await t.upgrader.upgradeOutbound(u,{skipEncryption:!0,muxerFactory:this.webtransportMuxer(n),skipProtection:!0})}catch(w){throw this.log.error("caught wt session err",w),h(p?"upgrade_error":f?"noise_error":"ready_error"),w}finally{var b;if(null!=l)null===(b=t.signal)||void 0===b||b.removeEventListener("abort",l)}}async authenticateWebTransport(e,t,n,r){var i;const o=await e.createBidirectionalStream(),s=o.writable.getWriter(),a=o.readable.getReader();await s.ready;const c={source:async function*(){for(;;){const e=await a.read();if(null!=e.value&&(yield e.value),e.done)break}}(),sink:async function(e){for await(const t of e)t instanceof Uint8Array?await s.write(t):await s.write(t.subarray())}},l=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return()=>new vz(e)}()(),{remoteExtensions:u}=await l.secureOutbound(t,c,n);if(s.close().catch((e=>{this.log.error("Failed to close authentication stream writer: ".concat(e.message))})),a.cancel().catch((e=>{this.log.error("Failed to close authentication stream reader: ".concat(e.message))})),h=null!==(i=null===u||void 0===u?void 0:u.webtransportCerthashes)&&void 0!==i?i:[],(d=r.map((e=>e.bytes))).filter((e=>Boolean(h.find((t=>(0,Ms.f)(e,t)))))).length!==d.length)throw new Error("Our certhashes are not a subset of the remote's reported certhashes");var h,d;return!0}webtransportMuxer(e){let t=0;const n=this.config,r=this;return{protocol:"webtransport",createStreamMuxer:i=>{"function"===typeof i&&(i={onIncomingStream:i});const o=[];(async function(){const s=e.incomingBidirectionalStreams.getReader();for(;;){const{done:e,value:h}=await s.read();if(e)break;if(o.length>=n.maxInboundStreams)h.writable.close().catch((e=>{r.log.error("Failed to close inbound stream that crossed our maxInboundStream limit: ".concat(e.message))})),h.readable.cancel().catch((e=>{r.log.error("Failed to close inbound stream that crossed our maxInboundStream limit: ".concat(e.message))}));else{var a,c,l,u;const e=await bz(h,String(t++),"inbound",o,null===(a=i)||void 0===a?void 0:a.onStreamEnd,r.components.logger);o.push(e),null===(c=i)||void 0===c||null===(l=(u=c).onIncomingStream)||void 0===l||l.call(u,e)}}})().catch((()=>{this.log.error("WebTransport failed to receive incoming stream")}));return{protocol:"webtransport",streams:o,newStream:async n=>{var s,a,c;const l=await e.createBidirectionalStream(),u=await bz(l,String(t++),null!==(s=null===(a=i)||void 0===a?void 0:a.direction)&&void 0!==s?s:"outbound",o,null===(c=i)||void 0===c?void 0:c.onStreamEnd,r.components.logger);return o.push(u),u},close:async e=>{this.log("Closing webtransport muxer"),await Promise.all(o.map((async t=>t.close(e))))},abort:e=>{this.log("Aborting webtransport muxer with err:",e);for(const t of o)t.abort(e)},...wz()}}}}createListener(e){throw new Error("Webtransport servers are not supported in Node or the browser")}filter(e){return e.filter(gO.Mk.exactMatch)}}function Lz(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new Bz(t,e)}function Mz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Open failed"),Xo()(e,"ERR_OPEN_FAILED")}function Uz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Close failed"),Xo()(e,"ERR_CLOSE_FAILED")}function Fz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Put failed"),Xo()(e,"ERR_PUT_FAILED")}function Kz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Get failed"),Xo()(e,"ERR_GET_FAILED")}function jz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Delete failed"),Xo()(e,"ERR_DELETE_FAILED")}function Zz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Has failed"),Xo()(e,"ERR_HAS_FAILED")}function zz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Not Found"),Xo()(e,"ERR_NOT_FOUND")}function Vz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Aborted"),Xo()(e,"ERR_ABORTED")}var Hz=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=h,t++}if(" "!==e[t]){for(var f=o-i;f!==o&&0===s[f];)f++;for(var p=new Uint8Array(r+(o-f)),g=r;f!==o;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=0,o=t.length;i!==o&&0===t[i];)i++,n++;for(var s=(o-i)*u+1>>>0,l=new Uint8Array(s);i!==o;){for(var h=t[i],d=0,f=s-1;(0!==h||d<r)&&-1!==f;f--,d++)h+=256*l[f]>>>0,l[f]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");r=d,i++}for(var p=s-r;p!==s&&0===l[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:h,decode:function(e){var n=h(e);if(n)return n;throw new Error("Non-".concat(t," character"))}}};const qz=Hz,Gz=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")});class Wz{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return"".concat(this.prefix).concat(this.baseEncode(e));throw Error("Unknown type, must be binary type")}}class Qz{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"===typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error("Unable to decode multibase string ".concat(JSON.stringify(e),", ").concat(this.name," decoder only supports inputs prefixed with ").concat(this.prefix));return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return Jz(this,e)}}class Yz{constructor(e){this.decoders=e}or(e){return Jz(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e),", only inputs prefixed with ").concat(Object.keys(this.decoders)," are supported"))}}const Jz=(e,t)=>new Yz({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class Xz{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new Wz(e,t,n),this.decoder=new Qz(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const $z=e=>{let{name:t,prefix:n,encode:r,decode:i}=e;return new Xz(t,n,r,i)},eV=e=>{let{prefix:t,name:n,alphabet:r}=e;const{encode:i,decode:o}=qz(r,n);return $z({prefix:t,name:n,encode:i,decode:e=>Gz(o(e))})},tV=e=>{let{name:t,prefix:n,bitsPerChar:r,alphabet:i}=e;return $z({prefix:n,name:t,encode:e=>((e,t,n)=>{const r="="===t[t.length-1],i=(1<<n)-1;let o="",s=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],s+=8;s>n;)s-=n,o+=t[i&a>>s];if(s&&(o+=t[i&a<<n-s]),r)for(;o.length*n&7;)o+="=";return o})(e,i,r),decode:e=>((e,t,n,r)=>{const i={};for(let u=0;u<t.length;++u)i[t[u]]=u;let o=e.length;for(;"="===e[o-1];)--o;const s=new Uint8Array(o*n/8|0);let a=0,c=0,l=0;for(let u=0;u<o;++u){const t=i[e[u]];if(void 0===t)throw new SyntaxError("Non-".concat(r," character"));c=c<<n|t,a+=n,a>=8&&(a-=8,s[l++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,i,r,t)})},nV=tV({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),rV=(tV({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),tV({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),tV({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),tV({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),tV({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),tV({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),tV({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),tV({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),eV({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));eV({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var iV=function e(t,n,r){n=n||[];var i=r=r||0;for(;t>=aV;)n[r++]=255&t|oV,t/=128;for(;t&sV;)n[r++]=255&t|oV,t>>>=7;return n[r]=0|t,e.bytes=r-i+1,n},oV=128,sV=-128,aV=Math.pow(2,31);var cV=function e(t,n){var r,i=0,o=0,s=n=n||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],i+=o<28?(r&uV)<<o:(r&uV)*Math.pow(2,o),o+=7}while(r>=lV);return e.bytes=s-n,i},lV=128,uV=127;var hV=Math.pow(2,7),dV=Math.pow(2,14),fV=Math.pow(2,21),pV=Math.pow(2,28),gV=Math.pow(2,35),yV=Math.pow(2,42),mV=Math.pow(2,49),vV=Math.pow(2,56),bV=Math.pow(2,63);const wV={encode:iV,decode:cV,encodingLength:function(e){return e<hV?1:e<dV?2:e<fV?3:e<pV?4:e<gV?5:e<yV?6:e<mV?7:e<vV?8:e<bV?9:10}},EV=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return[wV.decode(e,t),wV.decode.bytes]},AV=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return wV.encode(e,t,n),t},SV=e=>wV.encodingLength(e),_V=e=>{const t=Gz(e),[n,r]=EV(t),[i,o]=EV(t.subarray(r)),s=t.subarray(r+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new IV(n,i,s,t)};class IV{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const CV=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?PV(n,kV(e),t||rV.encoder):DV(n,kV(e),t||nV.encoder)},TV=new WeakMap,kV=e=>{const t=TV.get(e);if(null==t){const t=new Map;return TV.set(e,t),t}return t};class RV{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==OV)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==NV)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return RV.createV0(t)}default:throw Error("Can not convert CID version ".concat(this.version," to version 0. This is a bug please report"))}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=((e,t)=>{const n=t.byteLength,r=SV(e),i=r+SV(n),o=new Uint8Array(i+n);return AV(e,o,0),AV(n,o,r),o.set(t,i),new IV(e,n,t,o)})(e,t);return RV.createV1(this.code,n)}case 1:return this;default:throw Error("Can not convert CID version ".concat(this.version," to version 1. This is a bug please report"))}}equals(e){return RV.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&((e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}})(e.multihash,n.multihash)}toString(e){return CV(this,e)}toJSON(){return{"/":CV(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID(".concat(this.toString(),")")}static asCID(e){if(null==e)return null;const t=e;if(t instanceof RV)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new RV(e,n,r,i||BV(e,n,r.bytes))}if(!0===t[LV]){const{version:e,multihash:n,code:r}=t,i=_V(n);return RV.create(e,r,i)}return null}static create(e,t,n){if("number"!==typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==OV)throw new Error("Version 0 CID must use dag-pb (code: ".concat(OV,") block encoding"));return new RV(e,t,n,n.bytes);case 1:{const r=BV(e,t,n.bytes);return new RV(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return RV.create(0,OV,e)}static createV1(e,t){return RV.create(1,e,t)}static decode(e){const[t,n]=RV.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=RV.inspectBytes(e),n=t.size-t.multihashSize,r=Gz(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),o=new IV(t.multihashCode,t.digestSize,i,r);return[0===t.version?RV.createV0(o):RV.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=EV(e.subarray(t));return t+=r,n};let r=n(),i=OV;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version ".concat(r));const o=t,s=n(),a=n(),c=t+a;return{version:r,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[n,r]=xV(e,t),i=RV.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return kV(i).set(n,e),i}}const xV=(e,t)=>{switch(e[0]){case"Q":{const n=t||rV;return[rV.prefix,n.decode("".concat(rV.prefix).concat(e))]}case rV.prefix:{const n=t||rV;return[rV.prefix,n.decode(e)]}case nV.prefix:{const n=t||nV;return[nV.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},PV=(e,t,n)=>{const{prefix:r}=n;if(r!==rV.prefix)throw Error("Cannot string encode V0 in ".concat(n.name," encoding"));const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i},DV=(e,t,n)=>{const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i},OV=112,NV=18,BV=(e,t,n)=>{const r=SV(e),i=r+SV(t),o=new Uint8Array(i+n.byteLength);return AV(e,o,0),AV(t,o,r),o.set(n,i),o},LV=Symbol.for("@ipld/js-cid/CID");class MV{has(e,t){return Promise.reject(new Error(".has is not implemented"))}put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}async*putMany(e,t){for await(const{cid:n,block:r}of e)await this.put(n,r,t),yield n}get(e,t){return Promise.reject(new Error(".get is not implemented"))}async*getMany(e,t){for await(const n of e)yield{cid:n,block:await this.get(n,t)}}async delete(e,t){await Promise.reject(new Error(".delete is not implemented"))}async*deleteMany(e,t){for await(const n of e)await this.delete(n,t),yield n}async*getAll(e){throw new Error(".getAll is not implemented")}}class UV extends MV{constructor(){super(),(0,Yo.Z)(this,"data",void 0),this.data=new Map}put(e,t){return this.data.set(nV.encode(e.multihash.bytes),t),e}get(e){const t=this.data.get(nV.encode(e.multihash.bytes));if(null==t)throw zz();return t}has(e){return this.data.has(nV.encode(e.multihash.bytes))}async delete(e){this.data.delete(nV.encode(e.multihash.bytes))}async*getAll(){for(const[e,t]of this.data.entries())yield{cid:RV.createV1(85,_V(nV.decode(e))),block:t}}}const FV=tV({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6});tV({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),tV({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),tV({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});function KV(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return cf().enabled("".concat(e,":trace"))&&null!=cf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=cf()("".concat(e,":trace"))),Object.assign(cf()(e),{error:cf()("".concat(e,":error")),trace:t})}cf().formatters.b=e=>null==e?"undefined":rV.baseEncode(e),cf().formatters.t=e=>null==e?"undefined":nV.baseEncode(e),cf().formatters.m=e=>null==e?"undefined":FV.baseEncode(e),cf().formatters.p=e=>null==e?"undefined":e.toString(),cf().formatters.c=e=>null==e?"undefined":e.toString(),cf().formatters.k=e=>null==e?"undefined":e.toString(),cf().formatters.a=e=>null==e?"undefined":e.toString();KV("blockstore:core:tiered");let jV;const ZV="/",zV=(new TextEncoder).encode(ZV),VV=zV[0];jV=Symbol.toStringTag;class HV{constructor(e,t){if((0,Yo.Z)(this,"_buf",void 0),"string"===typeof e)this._buf=(0,mu.m)(e);else{if(!(e instanceof Uint8Array))throw new Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==VV)throw new Error("Invalid key")}toString(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"utf8";return(0,Su.B)(this._buf,e)}uint8Array(){return this._buf}get[jV](){return"Key(".concat(this.toString(),")")}static withNamespaces(e){return new HV(e.join(ZV))}static random(){return new HV(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;return crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+((t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_")),"")}().replace(/-/g,""))}static asKey(e){return e instanceof Uint8Array||"string"===typeof e?new HV(e):"function"===typeof e.uint8Array?new HV(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=zV),this._buf[0]!==VV){const e=new Uint8Array(this._buf.byteLength+1);e.fill(VV,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===VV;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let r=0;r<t.length;r++){if(n.length<r+1)return!1;const e=t[r],i=n[r];if(e<i)return!0;if(e>i)return!1}return t.length<n.length}reverse(){return HV.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(ZV).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new HV(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(ZV)||(e+=ZV),e+=this.type(),new HV(e)}parent(){const e=this.list();return 1===e.length?new HV(ZV):new HV(e.slice(0,-1).join(ZV))}child(e){return this.toString()===ZV?e:e.toString()===ZV?this:new HV(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return HV.withNamespaces([...this.namespaces(),...(r=t.map((e=>e.namespaces())),[].concat(...r))]);var r}}const qV="SHARDING";const GV=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e);})();for(const t of e);};const WV=function(e){const[t,n]=null!=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:e=>{r.push(e)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[n](){return this}}};const QV=function(e,t){if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)await t(n)&&(yield n)}();const n=WV(e),{value:r,done:i}=n.next();if(!0===i)return function*(){}();const o=t(r);if("function"===typeof o.then)return async function*(){await o&&(yield r);for await(const e of n)await t(e)&&(yield e)}();const s=t;return function*(){!0===o&&(yield r);for(const e of n)s(e)&&(yield e)}()};const YV=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{const t=[];for await(const n of e)t.push(n);return t})();const t=[];for(const n of e)t.push(n);return t};const JV=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(){const n=await YV(e);yield*n.sort(t)}():function*(){const n=YV(e);yield*n.sort(t)}()};const XV=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(){let n=0;if(!(t<1))for await(const r of e)if(yield r,n++,n===t)return}():function*(){let n=0;if(!(t<1))for(const r of e)if(yield r,n++,n===t)return}()};class $V{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}putMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const{key:r,value:i}of e)await t.put(r,i,n),yield r}()}catch(n){return Promise.reject(n)}}getMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of e)yield{key:r,value:await t.get(r,n)}}()}catch(n){return Promise.reject(n)}}deleteMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of e)await t.delete(r,n),yield r}()}catch(n){return Promise.reject(n)}}batch(){let e=[],t=[];return{put(t,n){e.push({key:t,value:n})},delete(e){t.push(e)},commit:async n=>{await GV(this.putMany(e,n)),e=[],await GV(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(null!=e.prefix){const t=e.prefix;n=QV(n,(e=>e.key.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(n=e.filters.reduce(((e,t)=>QV(e,t)),n)),Array.isArray(e.orders)&&(n=e.orders.reduce(((e,t)=>JV(e,t)),n)),null!=e.offset){let t=0;const r=e.offset;n=QV(n,(()=>t++>=r))}return null!=e.limit&&(n=XV(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(null!=e.prefix){const t=e.prefix;n=QV(n,(e=>e.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(n=e.filters.reduce(((e,t)=>QV(e,t)),n)),Array.isArray(e.orders)&&(n=e.orders.reduce(((e,t)=>JV(e,t)),n)),null!=e.offset){const t=e.offset;let r=0;n=QV(n,(()=>r++>=t))}return null!=e.limit&&(n=XV(n,e.limit)),n}}class eH extends $V{constructor(){super(),(0,Yo.Z)(this,"data",void 0),this.data=new Map}put(e,t){return this.data.set(e.toString(),t),e}get(e){const t=this.data.get(e.toString());if(null==t)throw function(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Not Found"),Xo()(e,"ERR_NOT_FOUND")}();return t}has(e){return this.data.has(e.toString())}delete(e){this.data.delete(e.toString())}*_all(){for(const[e,t]of this.data.entries())yield{key:new HV(e),value:t}}*_allKeys(){for(const e of this.data.keys())yield new HV(e)}}new HV(qV);var tH=n(85970);function nH(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return cf().enabled("".concat(e,":trace"))&&null!=cf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=cf()("".concat(e,":trace"))),Object.assign(cf()(e),{error:cf()("".concat(e,":error")),trace:t})}cf().formatters.b=e=>null==e?"undefined":vu.base58btc.baseEncode(e),cf().formatters.t=e=>null==e?"undefined":tH.base32.baseEncode(e),cf().formatters.m=e=>null==e?"undefined":Pu.base64.baseEncode(e),cf().formatters.p=e=>null==e?"undefined":e.toString(),cf().formatters.c=e=>null==e?"undefined":e.toString(),cf().formatters.k=e=>null==e?"undefined":e.toString(),cf().formatters.a=e=>null==e?"undefined":e.toString();nH("datastore:core:tiered");var rH=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=h,t++}if(" "!==e[t]){for(var f=o-i;f!==o&&0===s[f];)f++;for(var p=new Uint8Array(r+(o-f)),g=r;f!==o;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=0,o=t.length;i!==o&&0===t[i];)i++,n++;for(var s=(o-i)*u+1>>>0,l=new Uint8Array(s);i!==o;){for(var h=t[i],d=0,f=s-1;(0!==h||d<r)&&-1!==f;f--,d++)h+=256*l[f]>>>0,l[f]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");r=d,i++}for(var p=s-r;p!==s&&0===l[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:h,decode:function(e){var n=h(e);if(n)return n;throw new Error("Non-".concat(t," character"))}}};const iH=rH,oH=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")});class sH{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return"".concat(this.prefix).concat(this.baseEncode(e));throw Error("Unknown type, must be binary type")}}class aH{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"===typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error("Unable to decode multibase string ".concat(JSON.stringify(e),", ").concat(this.name," decoder only supports inputs prefixed with ").concat(this.prefix));return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return lH(this,e)}}class cH{constructor(e){this.decoders=e}or(e){return lH(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e),", only inputs prefixed with ").concat(Object.keys(this.decoders)," are supported"))}}const lH=(e,t)=>new cH({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class uH{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new sH(e,t,n),this.decoder=new aH(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const hH=e=>{let{name:t,prefix:n,encode:r,decode:i}=e;return new uH(t,n,r,i)},dH=e=>{let{prefix:t,name:n,alphabet:r}=e;const{encode:i,decode:o}=iH(r,n);return hH({prefix:t,name:n,encode:i,decode:e=>oH(o(e))})},fH=e=>{let{name:t,prefix:n,bitsPerChar:r,alphabet:i}=e;return hH({prefix:n,name:t,encode:e=>((e,t,n)=>{const r="="===t[t.length-1],i=(1<<n)-1;let o="",s=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],s+=8;s>n;)s-=n,o+=t[i&a>>s];if(s&&(o+=t[i&a<<n-s]),r)for(;o.length*n&7;)o+="=";return o})(e,i,r),decode:e=>((e,t,n,r)=>{const i={};for(let u=0;u<t.length;++u)i[t[u]]=u;let o=e.length;for(;"="===e[o-1];)--o;const s=new Uint8Array(o*n/8|0);let a=0,c=0,l=0;for(let u=0;u<o;++u){const t=i[e[u]];if(void 0===t)throw new SyntaxError("Non-".concat(r," character"));c=c<<n|t,a+=n,a>=8&&(a-=8,s[l++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,i,r,t)})},pH=fH({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),gH=fH({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),yH=fH({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),mH=fH({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),vH=fH({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),bH=fH({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),wH=fH({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),EH=fH({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),AH=fH({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),SH=dH({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),_H=dH({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),IH=fH({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),CH=fH({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),TH=fH({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),kH=fH({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});function RH(){return{forComponent:e=>xH(e)}}function xH(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return cf().enabled("".concat(e,":trace"))&&null!=cf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=cf()("".concat(e,":trace"))),Object.assign(cf()(e),{error:cf()("".concat(e,":error")),trace:t})}cf().formatters.b=e=>null==e?"undefined":SH.baseEncode(e),cf().formatters.t=e=>null==e?"undefined":pH.baseEncode(e),cf().formatters.m=e=>null==e?"undefined":IH.baseEncode(e),cf().formatters.p=e=>null==e?"undefined":e.toString(),cf().formatters.c=e=>null==e?"undefined":e.toString(),cf().formatters.k=e=>null==e?"undefined":e.toString(),cf().formatters.a=e=>null==e?"undefined":e.toString();let PH;const DH="/",OH=(new TextEncoder).encode(DH),NH=OH[0];PH=Symbol.toStringTag;class BH{constructor(e,t){if((0,Yo.Z)(this,"_buf",void 0),"string"===typeof e)this._buf=(0,mu.m)(e);else{if(!(e instanceof Uint8Array))throw new Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==NH)throw new Error("Invalid key")}toString(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"utf8";return(0,Su.B)(this._buf,e)}uint8Array(){return this._buf}get[PH](){return"Key(".concat(this.toString(),")")}static withNamespaces(e){return new BH(e.join(DH))}static random(){return new BH(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;return crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+((t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_")),"")}().replace(/-/g,""))}static asKey(e){return e instanceof Uint8Array||"string"===typeof e?new BH(e):"function"===typeof e.uint8Array?new BH(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=OH),this._buf[0]!==NH){const e=new Uint8Array(this._buf.byteLength+1);e.fill(NH,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===NH;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let r=0;r<t.length;r++){if(n.length<r+1)return!1;const e=t[r],i=n[r];if(e<i)return!0;if(e>i)return!1}return t.length<n.length}reverse(){return BH.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(DH).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new BH(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(DH)||(e+=DH),e+=this.type(),new BH(e)}parent(){const e=this.list();return 1===e.length?new BH(DH):new BH(e.slice(0,-1).join(DH))}child(e){return this.toString()===DH?e:e.toString()===DH?this:new BH(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return BH.withNamespaces([...this.namespaces(),...(r=t.map((e=>e.namespaces())),[].concat(...r))]);var r}}const LH="SHARDING";const MH=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e);})();for(const t of e);};const UH=function(e){const[t,n]=null!=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:e=>{r.push(e)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[n](){return this}}};const FH=function(e,t){if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)await t(n)&&(yield n)}();const n=UH(e),{value:r,done:i}=n.next();if(!0===i)return function*(){}();const o=t(r);if("function"===typeof o.then)return async function*(){await o&&(yield r);for await(const e of n)await t(e)&&(yield e)}();const s=t;return function*(){!0===o&&(yield r);for(const e of n)s(e)&&(yield e)}()};const KH=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(){let n=0;if(!(t<1))for await(const r of e)if(yield r,n++,n===t)return}():function*(){let n=0;if(!(t<1))for(const r of e)if(yield r,n++,n===t)return}()};class jH{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}putMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const{key:r,value:i}of e)await t.put(r,i,n),yield r}()}catch(n){return Promise.reject(n)}}getMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of e)yield{key:r,value:await t.get(r,n)}}()}catch(n){return Promise.reject(n)}}deleteMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of e)await t.delete(r,n),yield r}()}catch(n){return Promise.reject(n)}}batch(){let e=[],t=[];return{put(t,n){e.push({key:t,value:n})},delete(e){t.push(e)},commit:async n=>{await MH(this.putMany(e,n)),e=[],await MH(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(null!=e.prefix){const t=e.prefix;n=FH(n,(e=>e.key.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(n=e.filters.reduce(((e,t)=>FH(e,t)),n)),Array.isArray(e.orders)&&(n=e.orders.reduce(((e,t)=>JV(e,t)),n)),null!=e.offset){let t=0;const r=e.offset;n=FH(n,(()=>t++>=r))}return null!=e.limit&&(n=KH(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(null!=e.prefix){const t=e.prefix;n=FH(n,(e=>e.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(n=e.filters.reduce(((e,t)=>FH(e,t)),n)),Array.isArray(e.orders)&&(n=e.orders.reduce(((e,t)=>JV(e,t)),n)),null!=e.offset){const t=e.offset;let r=0;n=FH(n,(()=>r++>=t))}return null!=e.limit&&(n=KH(n,e.limit)),n}}class ZH extends jH{constructor(){super(),(0,Yo.Z)(this,"data",void 0),this.data=new Map}put(e,t){return this.data.set(e.toString(),t),e}get(e){const t=this.data.get(e.toString());if(null==t)throw function(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Not Found"),Xo()(e,"ERR_NOT_FOUND")}();return t}has(e){return this.data.has(e.toString())}delete(e){this.data.delete(e.toString())}*_all(){for(const[e,t]of this.data.entries())yield{key:new BH(e),value:t}}*_allKeys(){for(const e of this.data.keys())yield new BH(e)}}new BH(LH);xH("datastore:core:tiered");function zH(e){return null!=e&&"function"===typeof e.start&&"function"===typeof e.stop}async function VH(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const i of n)zH(i)&&e.push(i);await Promise.all(e.map((async e=>{null!=e.beforeStart&&await e.beforeStart()}))),await Promise.all(e.map((async e=>{await e.start()}))),await Promise.all(e.map((async e=>{null!=e.afterStart&&await e.afterStart()})))}async function HH(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const i of n)zH(i)&&e.push(i);await Promise.all(e.map((async e=>{null!=e.beforeStop&&await e.beforeStop()}))),await Promise.all(e.map((async e=>{await e.stop()}))),await Promise.all(e.map((async e=>{null!=e.afterStop&&await e.afterStop()})))}class qH extends Event{constructor(e,t){super(e),this.detail=t}}function GH(e){const t=new globalThis.AbortController;function n(){t.abort();for(const t of e)null!=(null===t||void 0===t?void 0:t.removeEventListener)&&t.removeEventListener("abort",n)}for(const i of e){if(!0===(null===i||void 0===i?void 0:i.aborted)){n();break}null!=(null===i||void 0===i?void 0:i.addEventListener)&&i.addEventListener("abort",n)}const r=t.signal;return r.clear=function(){for(const t of e)null!=(null===t||void 0===t?void 0:t.removeEventListener)&&t.removeEventListener("abort",n)},r}var WH=function e(t,n,r){n=n||[];var i=r=r||0;for(;t>=JH;)n[r++]=255&t|QH,t/=128;for(;t&YH;)n[r++]=255&t|QH,t>>>=7;return n[r]=0|t,e.bytes=r-i+1,n},QH=128,YH=-128,JH=Math.pow(2,31);var XH=function e(t,n){var r,i=0,o=0,s=n=n||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],i+=o<28?(r&eq)<<o:(r&eq)*Math.pow(2,o),o+=7}while(r>=$H);return e.bytes=s-n,i},$H=128,eq=127;var tq=Math.pow(2,7),nq=Math.pow(2,14),rq=Math.pow(2,21),iq=Math.pow(2,28),oq=Math.pow(2,35),sq=Math.pow(2,42),aq=Math.pow(2,49),cq=Math.pow(2,56),lq=Math.pow(2,63);const uq={encode:WH,decode:XH,encodingLength:function(e){return e<tq?1:e<nq?2:e<rq?3:e<iq?4:e<oq?5:e<sq?6:e<aq?7:e<cq?8:e<lq?9:10}},hq=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return[uq.decode(e,t),uq.decode.bytes]},dq=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return uq.encode(e,t,n),t},fq=e=>uq.encodingLength(e),pq=(e,t)=>{const n=t.byteLength,r=fq(e),i=r+fq(n),o=new Uint8Array(i+n);return dq(e,o,0),dq(n,o,r),o.set(t,i),new yq(e,n,t,o)},gq=e=>{const t=oH(e),[n,r]=hq(t),[i,o]=hq(t.subarray(r)),s=t.subarray(r+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new yq(n,i,s,t)};class yq{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const mq=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?Aq(n,bq(e),t||SH.encoder):Sq(n,bq(e),t||pH.encoder)},vq=new WeakMap,bq=e=>{const t=vq.get(e);if(null==t){const t=new Map;return vq.set(e,t),t}return t};class wq{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==_q)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Iq)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return wq.createV0(t)}default:throw Error("Can not convert CID version ".concat(this.version," to version 0. This is a bug please report"))}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=pq(e,t);return wq.createV1(this.code,n)}case 1:return this;default:throw Error("Can not convert CID version ".concat(this.version," to version 1. This is a bug please report"))}}equals(e){return wq.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&((e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}})(e.multihash,n.multihash)}toString(e){return mq(this,e)}toJSON(){return{"/":mq(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID(".concat(this.toString(),")")}static asCID(e){if(null==e)return null;const t=e;if(t instanceof wq)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new wq(e,n,r,i||Cq(e,n,r.bytes))}if(!0===t[Tq]){const{version:e,multihash:n,code:r}=t,i=gq(n);return wq.create(e,r,i)}return null}static create(e,t,n){if("number"!==typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==_q)throw new Error("Version 0 CID must use dag-pb (code: ".concat(_q,") block encoding"));return new wq(e,t,n,n.bytes);case 1:{const r=Cq(e,t,n.bytes);return new wq(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return wq.create(0,_q,e)}static createV1(e,t){return wq.create(1,e,t)}static decode(e){const[t,n]=wq.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=wq.inspectBytes(e),n=t.size-t.multihashSize,r=oH(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),o=new yq(t.multihashCode,t.digestSize,i,r);return[0===t.version?wq.createV0(o):wq.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=hq(e.subarray(t));return t+=r,n};let r=n(),i=_q;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version ".concat(r));const o=t,s=n(),a=n(),c=t+a;return{version:r,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[n,r]=Eq(e,t),i=wq.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return bq(i).set(n,e),i}}const Eq=(e,t)=>{switch(e[0]){case"Q":{const n=t||SH;return[SH.prefix,n.decode("".concat(SH.prefix).concat(e))]}case SH.prefix:{const n=t||SH;return[SH.prefix,n.decode(e)]}case pH.prefix:{const n=t||pH;return[pH.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},Aq=(e,t,n)=>{const{prefix:r}=n;if(r!==SH.prefix)throw Error("Cannot string encode V0 in ".concat(n.name," encoding"));const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i},Sq=(e,t,n)=>{const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i},_q=112,Iq=18,Cq=(e,t,n)=>{const r=fq(e),i=r+fq(t),o=new Uint8Array(i+n.byteLength);return dq(e,o,0),dq(t,o,r),o.set(n,i),o},Tq=Symbol.for("@ipld/js-cid/CID");class kq extends Map{constructor(e){super(),(0,Yo.Z)(this,"metric",void 0);const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Rq(e){const{name:t,metrics:n}=e;let r;return r=null!=n?new kq({name:t,metrics:n}):new Map,r}class xq extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"The operation was aborted"),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"type",void 0),this.code=xq.code,this.type=xq.type}}(0,Yo.Z)(xq,"code","ABORT_ERR"),(0,Yo.Z)(xq,"type","aborted");class Pq extends Error{constructor(e,t,n){var r;super(e),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"props",void 0),this.code=t,this.name=null!==(r=null===n||void 0===n?void 0:n.name)&&void 0!==r?r:"CodeError",this.props=null!==n&&void 0!==n?n:{}}}class Dq extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected Peer"),(0,Yo.Z)(this,"code",void 0),this.code=Dq.code}}(0,Yo.Z)(Dq,"code","ERR_UNEXPECTED_PEER");class Oq extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto exchange"),(0,Yo.Z)(this,"code",void 0),this.code=Oq.code}}(0,Yo.Z)(Oq,"code","ERR_INVALID_CRYPTO_EXCHANGE");class Nq extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto transmission"),(0,Yo.Z)(this,"code",void 0),this.code=Nq.code}}(0,Yo.Z)(Nq,"code","ERR_INVALID_CRYPTO_TRANSMISSION");const Bq=e=>{let{name:t,code:n,encode:r}=e;return new Lq(t,n,r)};class Lq{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?pq(this.code,t):t.then((e=>pq(this.code,e)))}throw Error("Unknown type, must be binary type")}}const Mq=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),Uq=Bq({name:"sha2-256",code:18,encode:Mq("SHA-256")}),Fq=Bq({name:"sha2-512",code:19,encode:Mq("SHA-512")});var Kq=n(29806),jq=n.n(Kq);let Zq,zq;Zq=Symbol.toStringTag;class Vq{constructor(e,t,n){(0,Yo.Z)(this,"_refCounter",void 0),(0,Yo.Z)(this,"cid",void 0),(0,Yo.Z)(this,"priority",void 0),(0,Yo.Z)(this,"wantType",void 0),this._refCounter=1,this.cid=e,this.priority=null!==t&&void 0!==t?t:1,this.wantType=n}inc(){this._refCounter+=1}dec(){this._refCounter=Math.max(0,this._refCounter-1)}hasRefs(){return this._refCounter>0}get[Zq](){const e=this.cid.toString(SH);return"WantlistEntry <key: ".concat(e,", priority: ").concat(this.priority,", refs: ").concat(this._refCounter,">")}equals(e){return this._refCounter===e._refCounter&&this.cid.equals(e.cid)&&this.priority===e.priority&&this.wantType===e.wantType}}zq=Symbol.toStringTag;class Hq{constructor(e,t,n,r,i){(0,Yo.Z)(this,"entry",void 0),(0,Yo.Z)(this,"cancel",void 0),(0,Yo.Z)(this,"sendDontHave",void 0),this.entry=new Vq(e,t,n),this.cancel=Boolean(r),this.sendDontHave=Boolean(i)}get cid(){return this.entry.cid}set cid(e){this.entry.cid=e}get priority(){return this.entry.priority}set priority(e){this.entry.priority=e}get wantType(){return this.entry.wantType}set wantType(e){this.entry.wantType=e}get[zq](){const e=this.cid.toString(SH);return"BitswapMessageEntry ".concat(e," <cancel: ").concat(this.cancel,", priority: ").concat(this.priority,">")}equals(e){return this.cancel===e.cancel&&this.sendDontHave===e.sendDontHave&&this.wantType===e.wantType&&this.entry.equals(e.entry)}}const qq=(e,t)=>{const n=["bitswap"];return null!=t&&n.push(t),null!=e&&n.push("".concat(e.toString().slice(0,8))),xH(n.join(":"))},Gq=(e,t)=>{if(e.size!==t.size)return!1;for(const[n,r]of e){const e=t.get(n);if(void 0===e)return!1;if(r instanceof Uint8Array&&e instanceof Uint8Array&&!(0,Ms.f)(r,e))return!1;if(r instanceof Hq&&e instanceof Hq&&!r.equals(e))return!1}return!0};const Wq=function(e){let t=new Uint8Array(e.reduce(((e,t)=>e+ii().encodingLength(t)),0)),n=0;for(const r of e)t=ri.encode(r,t,n),n+=ii().encodingLength(r);return t};var Qq;let Yq;!function(e){let t,n,r,i,o,s;!function(t){let n,r,i,o;!function(e){e.Block="Block",e.Have="Have"}(n=t.WantType||(t.WantType={})),function(e){e[e.Block=0]="Block",e[e.Have=1]="Have"}(r||(r={})),function(e){e.codec=()=>bs(r)}(n=t.WantType||(t.WantType={})),function(t){let i;t.codec=()=>(null==i&&(i=ws((function(t,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==i.lengthDelimited&&n.fork(),null!=t.block&&t.block.byteLength>0&&(n.uint32(10),n.bytes(t.block)),null!=t.priority&&0!==t.priority&&(n.uint32(16),n.int32(t.priority)),null!=t.cancel&&!1!==t.cancel&&(n.uint32(24),n.bool(t.cancel)),null!=t.wantType&&0!==r[t.wantType]&&(n.uint32(32),e.Wantlist.WantType.codec().encode(t.wantType,n)),null!=t.sendDontHave&&!1!==t.sendDontHave&&(n.uint32(40),n.bool(t.sendDontHave)),!1!==i.lengthDelimited&&n.ldelim()}),((t,r)=>{const i={block:new Uint8Array(0),priority:0,cancel:!1,wantType:n.Block,sendDontHave:!1},o=null==r?t.len:t.pos+r;for(;t.pos<o;){const n=t.uint32();switch(n>>>3){case 1:i.block=t.bytes();break;case 2:i.priority=t.int32();break;case 3:i.cancel=t.bool();break;case 4:i.wantType=e.Wantlist.WantType.codec().decode(t);break;case 5:i.sendDontHave=t.bool();break;default:t.skipType(7&n)}}return i}))),i),t.encode=e=>fs(e,t.codec()),t.decode=e=>ds(e,t.codec())}(i=t.Entry||(t.Entry={})),t.codec=()=>(null==o&&(o=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==r.lengthDelimited&&n.fork(),null!=t.entries)for(const i of t.entries)n.uint32(10),e.Wantlist.Entry.codec().encode(i,n);null!=t.full&&!1!==t.full&&(n.uint32(16),n.bool(t.full)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={entries:[],full:!1},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.entries.push(e.Wantlist.Entry.codec().decode(t,t.uint32()));break;case 2:r.full=t.bool();break;default:t.skipType(7&n)}}return r}))),o),t.encode=e=>fs(e,t.codec()),t.decode=e=>ds(e,t.codec())}(t=e.Wantlist||(e.Wantlist={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.prefix&&e.prefix.byteLength>0&&(t.uint32(10),t.bytes(e.prefix)),null!=e.data&&e.data.byteLength>0&&(t.uint32(18),t.bytes(e.data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={prefix:new Uint8Array(0),data:new Uint8Array(0)},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.prefix=e.bytes();break;case 2:n.data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(n=e.Block||(e.Block={})),function(e){e.Have="Have",e.DontHave="DontHave"}(r=e.BlockPresenceType||(e.BlockPresenceType={})),function(e){e[e.Have=0]="Have",e[e.DontHave=1]="DontHave"}(i||(i={})),function(e){e.codec=()=>bs(i)}(r=e.BlockPresenceType||(e.BlockPresenceType={})),function(t){let n;t.codec=()=>(null==n&&(n=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.cid&&t.cid.byteLength>0&&(n.uint32(10),n.bytes(t.cid)),null!=t.type&&0!==i[t.type]&&(n.uint32(16),e.BlockPresenceType.codec().encode(t.type,n)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const i={cid:new Uint8Array(0),type:r.Have},o=null==n?t.len:t.pos+n;for(;t.pos<o;){const n=t.uint32();switch(n>>>3){case 1:i.cid=t.bytes();break;case 2:i.type=e.BlockPresenceType.codec().decode(t);break;default:t.skipType(7&n)}}return i}))),n),t.encode=e=>fs(e,t.codec()),t.decode=e=>ds(e,t.codec())}(o=e.BlockPresence||(e.BlockPresence={})),e.codec=()=>(null==s&&(s=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==r.lengthDelimited&&n.fork(),null!=t.wantlist&&(n.uint32(10),e.Wantlist.codec().encode(t.wantlist,n)),null!=t.blocks)for(const e of t.blocks)n.uint32(18),n.bytes(e);if(null!=t.payload)for(const i of t.payload)n.uint32(26),e.Block.codec().encode(i,n);if(null!=t.blockPresences)for(const i of t.blockPresences)n.uint32(34),e.BlockPresence.codec().encode(i,n);null!=t.pendingBytes&&0!==t.pendingBytes&&(n.uint32(40),n.int32(t.pendingBytes)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={blocks:[],payload:[],blockPresences:[],pendingBytes:0},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.wantlist=e.Wantlist.codec().decode(t,t.uint32());break;case 2:r.blocks.push(t.bytes());break;case 3:r.payload.push(e.Block.codec().decode(t,t.uint32()));break;case 4:r.blockPresences.push(e.BlockPresence.codec().decode(t,t.uint32()));break;case 5:r.pendingBytes=t.int32();break;default:t.skipType(7&n)}}return r}))),s),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Qq||(Qq={})),Yq=Symbol.toStringTag;class Jq{constructor(e){(0,Yo.Z)(this,"full",void 0),(0,Yo.Z)(this,"wantlist",void 0),(0,Yo.Z)(this,"blocks",void 0),(0,Yo.Z)(this,"blockPresences",void 0),(0,Yo.Z)(this,"pendingBytes",void 0),this.full=e,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}get empty(){return 0===this.blocks.size&&0===this.wantlist.size&&0===this.blockPresences.size}addEntry(e,t,n,r,i){null==n&&(n=Jq.WantType.Block);const o=e.toString(SH),s=this.wantlist.get(o);null!=s?(s.wantType===n&&(s.priority=t),!0===r&&(s.cancel=Boolean(r)),!0===i&&(s.sendDontHave=Boolean(i)),n===Jq.WantType.Block&&s.wantType===Jq.WantType.Have&&(s.wantType=n)):this.wantlist.set(o,new Hq(e,t,n,r,i))}addBlock(e,t){const n=e.toString(SH);this.blocks.set(n,t)}addHave(e){const t=e.toString(SH);this.blockPresences.has(t)||this.blockPresences.set(t,Jq.BlockPresenceType.Have)}addDontHave(e){const t=e.toString(SH);this.blockPresences.has(t)||this.blockPresences.set(t,Jq.BlockPresenceType.DontHave)}cancel(e){const t=e.toString(SH);this.wantlist.delete(t),this.addEntry(e,0,Jq.WantType.Block,!0,!1)}setPendingBytes(e){this.pendingBytes=e}serializeToBitswap100(){return Qq.encode({wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),cancel:Boolean(e.cancel),wantType:Qq.Wantlist.WantType.Block,sendDontHave:!1}))),full:Boolean(this.full)},blocks:Array.from(this.blocks.values())})}serializeToBitswap110(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),wantType:e.wantType,cancel:Boolean(e.cancel),sendDontHave:Boolean(e.sendDontHave)}))),full:Boolean(this.full)},blockPresences:[],payload:[],pendingBytes:this.pendingBytes,blocks:[]};for(const[t,n]of this.blocks.entries()){const r=wq.parse(t),i=r.version,o=r.code,s=r.multihash.code,a=r.multihash.digest.length,c=Wq([i,o,s,a]);e.payload.push({prefix:c,data:n})}for(const[t,n]of this.blockPresences)e.blockPresences.push({cid:wq.parse(t).bytes,type:n});return this.pendingBytes>0&&(e.pendingBytes=this.pendingBytes),Qq.encode(e)}equals(e){return!!(this.full===e.full&&this.pendingBytes===e.pendingBytes&&Gq(this.wantlist,e.wantlist)&&Gq(this.blocks,e.blocks)&&Gq(this.blockPresences,e.blockPresences))}get[Yq](){const e=Array.from(this.wantlist.keys()),t=Array.from(this.blocks.keys());return"BitswapMessage <full: ".concat(this.full,", list: ").concat(e,", blocks: ").concat(t,">")}}(0,Yo.Z)(Jq,"Entry",Hq),(0,Yo.Z)(Jq,"WantType",{Block:Qq.Wantlist.WantType.Block,Have:Qq.Wantlist.WantType.Have}),(0,Yo.Z)(Jq,"BlockPresenceType",{Have:Qq.BlockPresenceType.Have,DontHave:Qq.BlockPresenceType.DontHave}),(0,Yo.Z)(Jq,"deserialize",(async(e,t)=>{var n,r;const i=Qq.decode(e),o=!0===(null===(n=i.wantlist)||void 0===n?void 0:n.full),s=new Jq(o);return null===(r=i.wantlist)||void 0===r||r.entries.forEach((e=>{var t;if(null==e.block)return;const n=wq.decode(e.block);s.addEntry(n,null!==(t=e.priority)&&void 0!==t?t:0,e.wantType,Boolean(e.cancel),Boolean(e.sendDontHave))})),i.blockPresences.forEach((e=>{if(null==e.cid)return;const t=wq.decode(e.cid);e.type===Jq.BlockPresenceType.Have?s.addHave(t):s.addDontHave(t)})),i.blocks.length>0?(await Promise.all(i.blocks.map((async e=>{const t=await Uq.digest(e),n=wq.createV0(t);s.addBlock(n,e)}))),s):i.payload.length>0?(await Promise.all(i.payload.map((async e=>{if(null==e.prefix||null==e.data)return;const n=jq()(e.prefix),r=n[0],i=n[1],o=n[2],a=o===Uq.code?Uq:await(null===t||void 0===t?void 0:t.getHasher(o));if(null==a)throw new Pq("Unknown hash algorithm","ERR_UNKNOWN_HASH_ALG");const c=await a.digest(e.data),l=wq.create(r,i,c);s.addBlock(l,e.data)}))),s.setPendingBytes(i.pendingBytes),s):s})),(0,Yo.Z)(Jq,"blockPresenceSize",(e=>e.bytes.length+1));const Xq=Qq.Wantlist.WantType.Block,$q=Qq.Wantlist.WantType.Have;class eG{constructor(e,t){(0,Yo.Z)(this,"set",void 0),(0,Yo.Z)(this,"_stats",void 0),this.set=null!=t?Rq({name:"ipfs_bitswap_wantlist",metrics:t.metrics}):new Map,this._stats=e}get length(){return this.set.size}add(e,t,n){const r=e.toString(SH),i=this.set.get(r);null!=i?(i.inc(),i.priority=t,i.wantType===$q&&n===Xq&&(i.wantType=n)):(this.set.set(r,new Vq(e,t,n)),null!=this._stats&&this._stats.push(void 0,"wantListSize",1))}remove(e){const t=e.toString(SH),n=this.set.get(t);null!=n&&(n.dec(),n.hasRefs()||(this.set.delete(t),null!=this._stats&&this._stats.push(void 0,"wantListSize",-1)))}removeForce(e){this.set.has(e)&&this.set.delete(e)}forEach(e){this.set.forEach(e)}entries(){return this.set.entries()}sortedEntries(){return new Map((e=e=>e[1].key,t=Array.from(this.set.entries()),Array.prototype.slice.call(t,0).sort(((t,n)=>{const r=e(t),i=e(n);return r<i?-1:r>i?1:0}))));var e,t}contains(e){const t=e.toString(SH);return this.set.has(t)}get(e){const t=e.toString(SH);return this.set.get(t)}}(0,Yo.Z)(eG,"Entry",Vq);class tG{constructor(e){(0,Yo.Z)(this,"partner",void 0),(0,Yo.Z)(this,"wantlist",void 0),(0,Yo.Z)(this,"exchangeCount",void 0),(0,Yo.Z)(this,"accounting",void 0),(0,Yo.Z)(this,"lastExchange",void 0),this.partner=e,this.wantlist=new eG,this.exchangeCount=0,this.accounting={bytesSent:0,bytesRecv:0}}sentBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesSent+=e}receivedBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesRecv+=e}wants(e,t,n){this.wantlist.add(e,t,n)}cancelWant(e){this.wantlist.remove(e)}wantlistContains(e){return this.wantlist.get(e)}debtRatio(){return this.accounting.bytesSent/(this.accounting.bytesRecv+1)}}let nG;nG=Symbol.iterator;class rG extends Map{constructor(e,t){super(),(0,Yo.Z)(this,"_cmp",void 0),(0,Yo.Z)(this,"_keys",void 0),this._cmp=null!==t&&void 0!==t?t:this._defaultSort,this._keys=[];for(const[n,r]of null!==e&&void 0!==e?e:[])this.set(n,r)}update(e){if(e<0||e>=this._keys.length)return;const t=this._keys[e];this._keys.splice(e,1);const n=this._find(t);this._keys.splice(n,0,t)}set(e,t){if(this.has(e)){const t=this.indexOf(e);this._keys.splice(t,1)}super.set(e,t);const n=this._find(e);return this._keys.splice(n,0,e),this}clear(){super.clear(),this._keys=[]}delete(e){if(!this.has(e))return!1;const t=this.indexOf(e);return this._keys.splice(t,1),super.delete(e)}indexOf(e){if(!this.has(e))return-1;const t=this._find(e);if(this._keys[t]===e)return t;for(let n=1;n<this._keys.length;n++){if(this._keys[t+n]===e)return t+n;if(this._keys[t-n]===e)return t-n}return-1}_find(e){let t=0,n=this._keys.length;for(;t<n;){const r=t+n>>>1,i=this._kCmp(this._keys[r],e);if(i<0)t=r+1;else{if(!(i>0))return r;n=r}}return t}*keys(){for(const e of this._keys)yield e}*values(){for(const e of this._keys)yield this.get(e)}*entries(){for(const e of this._keys)yield[e,this.get(e)]}*[nG](){yield*this.entries()}forEach(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this;if(null!=e)for(const n of this._keys){const r=this.get(n);if(null==r)throw new Error("Value cannot be undefined");e.apply(t,[[n,r]])}}_defaultSort(e,t){return e[0]<t[0]?-1:t[0]<e[0]?1:0}_kCmp(e,t){return this._cmp([e,this.get(e)],[t,this.get(t)])}}const iG={hasNewInfo:()=>!1,merge(){}};class oG{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:iG;(0,Yo.Z)(this,"_taskMerger",void 0),(0,Yo.Z)(this,"_byPeer",void 0),this._taskMerger=e,this._byPeer=new rG([],sG.compare)}pushTasks(e,t){let n=this._byPeer.get(e.toString());null==n&&(n=new sG(e,this._taskMerger)),n.pushTasks(t),this._byPeer.set(e.toString(),n)}popTasks(e){const t=this._head();if(void 0===t)return{tasks:[],pendingSize:0};const{tasks:n,pendingSize:r}=t.popTasks(e);if(0===n.length)return{tasks:n,pendingSize:r};const i=t.peerId;return t.isIdle()?this._byPeer.delete(i.toString()):this._byPeer.update(0),{peerId:i,tasks:n,pendingSize:r}}_head(){if(0!==this._byPeer.size)for(const[,e]of this._byPeer)return e}remove(e,t){const n=this._byPeer.get(t.toString());null===n||void 0===n||n.remove(e)}tasksDone(e,t){const n=this._byPeer.get(e.toString());if(null==n)return;const r=this._byPeer.indexOf(e.toString());for(const i of t)n.taskDone(i);this._byPeer.update(r)}}class sG{constructor(e,t){(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"_taskMerger",void 0),(0,Yo.Z)(this,"_activeTotalSize",void 0),(0,Yo.Z)(this,"_pending",void 0),(0,Yo.Z)(this,"_active",void 0),this.peerId=e,this._taskMerger=t,this._activeTotalSize=0,this._pending=new aG,this._active=new Set}pushTasks(e){for(const t of e)this._pushTask(t)}_pushTask(e){if(!this._taskHasMoreInfoThanActiveTasks(e))return;const t=this._pending.get(e.topic);if(null!=t)return e.priority>t.priority&&this._pending.updatePriority(e.topic,e.priority),void this._taskMerger.merge(e,t);this._pending.add(e)}_taskHasMoreInfoThanActiveTasks(e){const t=[];for(const n of this._active)n.topic===e.topic&&t.push(n);return 0===t.length||this._taskMerger.hasNewInfo(e,t)}popTasks(e){let t=0;const n=[],r=this._pending.tasks();for(let i=0;i<r.length&&t<e;i++){const e=r[i];n.push(e),t+=e.size,this._pending.delete(e.topic),this._activeTotalSize+=e.size,this._active.add(e)}return{tasks:n,pendingSize:this._pending.totalSize}}taskDone(e){this._active.has(e)&&(this._activeTotalSize-=e.size,this._active.delete(e))}remove(e){this._pending.delete(e)}isIdle(){return 0===this._pending.length&&0===this._active.size}static compare(e,t){return 0===e[1]._pending.length?1:0===t[1]._pending.length?-1:e[1]._activeTotalSize===t[1]._activeTotalSize?t[1]._pending.length-e[1]._pending.length:e[1]._activeTotalSize-t[1]._activeTotalSize}}class aG{constructor(){(0,Yo.Z)(this,"_tasks",void 0),this._tasks=new rG([],this._compare)}get length(){return this._tasks.size}get totalSize(){return[...this._tasks.values()].reduce(((e,t)=>e+t.task.size),0)}get(e){var t,n;return null===(t=this._tasks)||void 0===t||null===(n=t.get(e))||void 0===n?void 0:n.task}add(e){this._tasks.set(e.topic,{created:Date.now(),task:e})}delete(e){this._tasks.delete(e)}tasks(){return[...this._tasks.values()].map((e=>e.task))}updatePriority(e,t){const n=this._tasks.get(e);if(null==n)return;const r=this._tasks.indexOf(e);n.task.priority=t,this._tasks.update(r)}_compare(e,t){return e[1].task.priority===t[1].task.priority?e[1].created-t[1].created:t[1].task.priority-e[1].task.priority}}const cG={hasNewInfo(e,t){let n=!1,r=!1;for(const i of t)i.data.haveBlock&&(n=!0),i.data.isWantBlock&&(r=!0);return!(r||!e.data.isWantBlock)||!(n||!e.data.haveBlock)},merge(e,t){const n=e.data,r=t.data;!r.haveBlock&&n.haveBlock&&(r.haveBlock=n.haveBlock,r.blockSize=n.blockSize),!r.isWantBlock&&n.isWantBlock&&(r.isWantBlock=!0,r.haveBlock&&!n.haveBlock||(r.haveBlock=n.haveBlock,t.size=e.size)),r.isWantBlock&&r.haveBlock&&(t.size=r.blockSize)}},lG=Jq.WantType;class uG{constructor(e,t,n,r,i){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};(0,Yo.Z)(this,"_log",void 0),(0,Yo.Z)(this,"blockstore",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"_stats",void 0),(0,Yo.Z)(this,"_opts",void 0),(0,Yo.Z)(this,"ledgerMap",void 0),(0,Yo.Z)(this,"_running",void 0),(0,Yo.Z)(this,"_requestQueue",void 0),this._log=qq(e,"engine"),this.blockstore=t,this.network=n,this._stats=r,this._opts=this._processOpts(o),this.ledgerMap=Rq({name:"ipfs_bitswap_ledger_map",metrics:i.metrics}),this._running=!1,this._requestQueue=new oG(cG)}_processOpts(e){return{maxSizeReplaceHasWithBlock:1024,targetMessageSize:16384,...e}}_scheduleProcessTasks(){setTimeout((()=>{this._processTasks().catch((e=>{this._log.error("error processing stats",e)}))}))}async _processTasks(){if(!this._running)return;const{peerId:e,tasks:t,pendingSize:n}=this._requestQueue.popTasks(this._opts.targetMessageSize);if(0===t.length)return;const r=new Jq(!1);r.setPendingBytes(n);const i=[],o=new Map;for(const c of t){const e=wq.parse(c.topic);c.data.haveBlock?c.data.isWantBlock?(i.push(e),o.set(c.topic,c.data)):r.addHave(e):r.addDontHave(e)}const s=await this._getBlocks(i);for(const[c,l]of o){const e=wq.parse(c),t=s.get(c);null!=t?r.addBlock(e,t):l.sendDontHave&&r.addDontHave(e)}if(r.empty)return null!=e&&this._requestQueue.tasksDone(e,t),void this._scheduleProcessTasks();try{null!=e&&await this.network.sendMessage(e,r);for(const[t,n]of s.entries())null!=e&&this.messageSent(e,wq.parse(t),n)}catch(a){this._log.error(a)}null!=e&&this._requestQueue.tasksDone(e,t),this._scheduleProcessTasks()}wantlistForPeer(e){const t=e.toString(),n=this.ledgerMap.get(t);return null!=n?n.wantlist.sortedEntries():new Map}ledgerForPeer(e){const t=e.toString(),n=this.ledgerMap.get(t);if(null!=n)return{peer:n.partner,value:n.debtRatio(),sent:n.accounting.bytesSent,recv:n.accounting.bytesRecv,exchanged:n.exchangeCount}}peers(){return Array.from(this.ledgerMap.values()).map((e=>e.partner))}receivedBlocks(e){if(0!==e.length){for(const t of this.ledgerMap.values())for(const{cid:n,block:r}of e){const e=t.wantlistContains(n);if(null==e)continue;const i=r.length,o=this._sendAsBlock(e.wantType,i);let s=i;o||(s=Jq.blockPresenceSize(e.cid)),this._requestQueue.pushTasks(t.partner,[{topic:e.cid.toString(SH),priority:e.priority,size:s,data:{blockSize:i,isWantBlock:o,haveBlock:!0,sendDontHave:!1}}])}this._scheduleProcessTasks()}}async messageReceived(e,t){const n=this._findOrCreate(e);if(t.empty)return;if(t.full&&(n.wantlist=new eG),this._updateBlockAccounting(t.blocks,n),0===t.wantlist.size)return void this._scheduleProcessTasks();const r=[],i=[];t.wantlist.forEach((e=>{e.cancel?(n.cancelWant(e.cid),r.push(e.cid)):(n.wants(e.cid,e.priority,e.wantType),i.push(e))})),this._cancelWants(e,r),await this._addWants(e,i),this._scheduleProcessTasks()}_cancelWants(e,t){for(const n of t)this._requestQueue.remove(n.toString(SH),e)}async _addWants(e,t){const n=await this._getBlockSizes(t.map((e=>e.cid))),r=[];for(const i of t){const t=i.cid.toString(SH),o=n.get(t);if(null==o)i.sendDontHave&&r.push({topic:t,priority:i.priority,size:Jq.blockPresenceSize(i.cid),data:{isWantBlock:i.wantType===lG.Block,blockSize:0,haveBlock:!1,sendDontHave:i.sendDontHave}});else{const e=this._sendAsBlock(i.wantType,o);let n=o;e||(n=Jq.blockPresenceSize(i.cid)),r.push({topic:t,priority:i.priority,size:n,data:{isWantBlock:e,blockSize:o,haveBlock:!0,sendDontHave:i.sendDontHave}})}this._requestQueue.pushTasks(e,r)}}_sendAsBlock(e,t){return e===lG.Block||t<=this._opts.maxSizeReplaceHasWithBlock}async _getBlockSizes(e){const t=await this._getBlocks(e);return new Map([...t].map((e=>{let[t,n]=e;return[t,n.length]})))}async _getBlocks(e){const t=new Map;return await Promise.all(e.map((async e=>{try{const n=await this.blockstore.get(e);t.set(e.toString(SH),n)}catch(n){"ERR_NOT_FOUND"!==n.code&&this._log.error("failed to query blockstore for %s: %s",e,n)}}))),t}_updateBlockAccounting(e,t){for(const n of e.values())this._log("got block (%s bytes)",n.length),t.receivedBytes(n.length)}messageSent(e,t,n){const r=this._findOrCreate(e);r.sentBytes(n.length),r.wantlist.remove(t)}numBytesSentTo(e){return this._findOrCreate(e).accounting.bytesSent}numBytesReceivedFrom(e){return this._findOrCreate(e).accounting.bytesRecv}peerDisconnected(e){this.ledgerMap.delete(e.toString())}_findOrCreate(e){const t=e.toString(),n=this.ledgerMap.get(t);if(null!=n)return n;const r=new tG(e);return this.ledgerMap.set(t,r),null!=this._stats&&this._stats.push(t,"peerCount",1),r}start(){this._running=!0}stop(){this._running=!1}}function hG(e){return null!=e[Symbol.asyncIterator]}const dG=e=>{const t=Bs.P$(e),n=(0,Us.E)(t);return Bs.cv(e,n),dG.bytes=t,n};function fG(e,t){var n,r;const i=null!==(r=(t=null!==(n=t)&&void 0!==n?n:{}).lengthEncoder)&&void 0!==r?r:dG;function*o(e){const t=i(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return hG(e)?async function*(){for await(const t of e)yield*o(t)}():function*(){for(const t of e)yield*o(t)}()}dG.bytes=0,fG.single=(e,t)=>{var n,r;const i=null!==(r=(t=null!==(n=t)&&void 0!==n?n:{}).lengthEncoder)&&void 0!==r?r:dG;return new Zs(i(e.byteLength),e)};var pG;!function(e){e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"}(pG||(pG={}));const gG=e=>{const t=Bs.Jx(e);return gG.bytes=Bs.P$(t),t};function yG(e,t){var n,r,i;const o=new Zs;let s=pG.LENGTH,a=-1;const c=null!==(n=null===t||void 0===t?void 0:t.lengthDecoder)&&void 0!==n?n:gG,l=null!==(r=null===t||void 0===t?void 0:t.maxLengthLength)&&void 0!==r?r:8,u=null!==(i=null===t||void 0===t?void 0:t.maxDataLength)&&void 0!==i?i:4194304;function*h(){for(;o.byteLength>0;){if(s===pG.LENGTH)try{if(a=c(o),a<0)throw Xo()(new Error("invalid message length"),"ERR_INVALID_MSG_LENGTH");if(a>u)throw Xo()(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");const e=c.bytes;o.consume(e),null!=(null===t||void 0===t?void 0:t.onLength)&&t.onLength(a),s=pG.DATA}catch(e){if(e instanceof RangeError){if(o.byteLength>l)throw Xo()(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG");break}throw e}if(s===pG.DATA){if(o.byteLength<a)break;const e=o.sublist(0,a);o.consume(a),null!=(null===t||void 0===t?void 0:t.onData)&&t.onData(e),yield e,s=pG.LENGTH}}}return hG(e)?async function*(){for await(const t of e)o.append(t),yield*h();if(o.byteLength>0)throw Xo()(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}():function*(){for(const t of e)o.append(t),yield*h();if(o.byteLength>0)throw Xo()(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}()}gG.bytes=0,yG.fromReader=(e,t)=>{let n=1;return yG(async function*(){for(;;)try{const{done:t,value:r}=await e.next(n);if(!0===t)return;null!=r&&(yield r)}catch(t){if("ERR_UNDER_READ"===t.code)return{done:!0,value:null};throw t}finally{n=1}}(),{...null!==t&&void 0!==t?t:{},onLength:e=>{n=e}})};const mG=function(e,t){if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)yield t(n)}();const n=UH(e),{value:r,done:i}=n.next();if(!0===i)return function*(){}();const o=t(r);if("function"===typeof o.then)return async function*(){yield await o;for await(const e of n)yield t(e)}();const s=t;return function*(){yield o;for(const e of n)yield s(e)}()};class vG{constructor(e){if((0,Yo.Z)(this,"buffer",void 0),(0,Yo.Z)(this,"mask",void 0),(0,Yo.Z)(this,"top",void 0),(0,Yo.Z)(this,"btm",void 0),(0,Yo.Z)(this,"next",void 0),!(e>0)||0!==(e-1&e))throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return void 0===this.buffer[this.top]&&(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(void 0!==e)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return void 0===this.buffer[this.btm]}}class bG{constructor(){var e;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"size",void 0),(0,Yo.Z)(this,"hwm",void 0),(0,Yo.Z)(this,"head",void 0),(0,Yo.Z)(this,"tail",void 0),this.hwm=null!==(e=t.splitLimit)&&void 0!==e?e:16,this.head=new vG(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return null!=(null===e||void 0===e?void 0:e.byteLength)?e.byteLength:1}push(e){if(null!=(null===e||void 0===e?void 0:e.value)&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new vG(2*this.head.buffer.length),this.head.push(e)}}shift(){var e;let t=this.tail.shift();if(void 0===t&&null!=this.tail.next){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return null!=(null===(e=t)||void 0===e?void 0:e.value)&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}class wG extends Error{constructor(e,t){super(null!==e&&void 0!==e?e:"The operation was aborted"),(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"code",void 0),this.type="aborted",this.code=null!==t&&void 0!==t?t:"ABORT_ERR"}}function EG(){return AG((e=>{const t=e.shift();if(null==t)return{done:!0};if(null!=t.error)throw t.error;return{done:!0===t.done,value:t.value}}),arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}function AG(e,t){var n;let r,i,o,s=(t=null!==(n=t)&&void 0!==n?n:{}).onEnd,a=new bG,c=Ws();const l=e=>null!=i?i(e):(a.push(e),r),u=e=>{var n;if(o)return r;if(!0!==(null===(n=t)||void 0===n?void 0:n.objectMode)&&null==(null===e||void 0===e?void 0:e.byteLength))throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:e})},h=e=>o?r:(o=!0,null!=e?(e=>(a=new bG,null!=i?i({error:e}):(a.push({error:e}),r)))(e):l({done:!0}));if(r={[Symbol.asyncIterator](){return this},next:async()=>{try{return a.isEmpty()?o?{done:!0}:await new Promise(((t,n)=>{i=o=>{i=null,a.push(o);try{t(e(a))}catch(s){n(s)}return r}})):e(a)}finally{a.isEmpty()&&queueMicrotask((()=>{c.resolve(),c=Ws()}))}},return:()=>(a=new bG,h(),{done:!0}),throw:e=>(h(e),{done:!0}),push:u,end:h,get readableLength(){return a.size},onEmpty:async e=>{const t=null===e||void 0===e?void 0:e.signal;if(null===t||void 0===t||t.throwIfAborted(),a.isEmpty())return;let n,r;null!=t&&(n=new Promise(((e,n)=>{r=()=>{n(new wG)},t.addEventListener("abort",r)})));try{await Promise.race([c.promise,n])}finally{null!=r&&null!=t&&(null===t||void 0===t||t.removeEventListener("abort",r))}}},null==s)return r;const d=r;return r={[Symbol.asyncIterator](){return this},next:()=>d.next(),throw:e=>(d.throw(e),null!=s&&(s(e),s=void 0),{done:!0}),return:()=>(d.return(),null!=s&&(s(),s=void 0),{done:!0}),push:u,end:e=>(d.end(e),null!=s&&(s(e),s=void 0),r),get readableLength(){return d.readableLength},onEmpty:e=>d.onEmpty(e)},r}const SG=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=[];for(const i of t)null==i[Symbol.asyncIterator]&&r.push(i);return r.length===t.length?function*(){for(const e of r)yield*e}():async function*(){const e=EG({objectMode:!0});Promise.resolve().then((async()=>{try{await Promise.all(t.map((async t=>{for await(const n of t)e.push(n)}))),e.end()}catch(n){e.end(n)}})),yield*e}()};function _G(e){if(null==e)throw new Error("Empty pipeline");if(kG(e)){const t=e;e=()=>t.source}else if(TG(e)||CG(e)){const t=e;e=()=>t}for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const i=[e,...n];if(i.length>1&&kG(i[i.length-1])&&(i[i.length-1]=i[i.length-1].sink),i.length>2)for(let o=1;o<i.length-1;o++)kG(i[o])&&(i[o]=RG(i[o]));return IG(...i)}const IG=function(){let e;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(;n.length>0;)e=n.shift()(e);return e},CG=e=>null!=(null===e||void 0===e?void 0:e[Symbol.asyncIterator]),TG=e=>null!=(null===e||void 0===e?void 0:e[Symbol.iterator]),kG=e=>null!=e&&(null!=e.sink&&null!=e.source),RG=e=>t=>{const n=e.sink(t);if(null!=(null===n||void 0===n?void 0:n.then)){const t=EG({objectMode:!0});let r;n.then((()=>{t.end()}),(e=>{t.end(e)}));const i=e.source;if(CG(i))r=async function*(){yield*i,t.end()};else{if(!TG(i))throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");r=function*(){yield*i,t.end()}}return SG(t,r())}return e.source};var xG=n(68363);const PG=Math.pow(2,31)-1,DG="/ipfs/bitswap/1.0.0",OG="/ipfs/bitswap/1.1.0",NG="/ipfs/bitswap/1.2.0";class BG{constructor(e,t,n){var r,i,o,s;let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};(0,Yo.Z)(this,"_log",void 0),(0,Yo.Z)(this,"_libp2p",void 0),(0,Yo.Z)(this,"_bitswap",void 0),(0,Yo.Z)(this,"_protocols",void 0),(0,Yo.Z)(this,"_stats",void 0),(0,Yo.Z)(this,"_running",void 0),(0,Yo.Z)(this,"_hashLoader",void 0),(0,Yo.Z)(this,"_maxInboundStreams",void 0),(0,Yo.Z)(this,"_maxOutboundStreams",void 0),(0,Yo.Z)(this,"_incomingStreamTimeout",void 0),(0,Yo.Z)(this,"_registrarIds",void 0),this._log=qq(e.peerId,"network"),this._libp2p=e,this._bitswap=t,this._protocols=[DG],!0!==a.b100Only&&(this._protocols.unshift(OG),this._protocols.unshift(NG)),this._stats=n,this._running=!1,this._onPeerConnect=this._onPeerConnect.bind(this),this._onPeerDisconnect=this._onPeerDisconnect.bind(this),this._onConnection=this._onConnection.bind(this),this._hashLoader=null!==(r=a.hashLoader)&&void 0!==r?r:{async getHasher(){throw new Error("Not implemented")}},this._maxInboundStreams=null!==(i=a.maxInboundStreams)&&void 0!==i?i:1024,this._maxOutboundStreams=null!==(o=a.maxOutboundStreams)&&void 0!==o?o:1024,this._incomingStreamTimeout=null!==(s=a.incomingStreamTimeout)&&void 0!==s?s:3e4}async start(){this._running=!0,await this._libp2p.handle(this._protocols,this._onConnection,{maxInboundStreams:this._maxInboundStreams,maxOutboundStreams:this._maxOutboundStreams});const e={onConnect:this._onPeerConnect,onDisconnect:this._onPeerDisconnect};this._registrarIds=[];for(const t of this._protocols)this._registrarIds.push(await this._libp2p.register(t,e));this._libp2p.getConnections().forEach((e=>{this._onPeerConnect(e.remotePeer)}))}async stop(){if(this._running=!1,await this._libp2p.unhandle(this._protocols),null!=this._registrarIds){for(const e of this._registrarIds)this._libp2p.unregister(e);this._registrarIds=[]}}_onConnection(e){if(!this._running)return;const{stream:t,connection:n}=e,r=new xG.TimeoutController(this._incomingStreamTimeout);Promise.resolve().then((async()=>{this._log("incoming new bitswap %s connection from %p",t.protocol,n.remotePeer);const e=()=>{t.abort(new Pq("Incoming Bitswap stream timed out","ERR_TIMEOUT"))};let r=AbortSignal.timeout(this._incomingStreamTimeout);r.addEventListener("abort",e),await _G(t,(e=>yG(e)),(async t=>{for await(const o of t){try{const e=await Jq.deserialize(o.subarray(),this._hashLoader);await this._bitswap._receiveMessage(n.remotePeer,e)}catch(i){this._bitswap._receiveError(i);break}r.removeEventListener("abort",e),r=AbortSignal.timeout(this._incomingStreamTimeout),r.addEventListener("abort",e)}})),await t.close({signal:r})})).catch((e=>{this._log(e),t.abort(e)})).finally((()=>{r.clear()}))}_onPeerConnect(e){this._bitswap._onPeerConnected(e)}_onPeerDisconnect(e){this._bitswap._onPeerDisconnected(e)}findProviders(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null===(t=n.onProgress)||void 0===t||t.call(n,new qH("bitswap:network:find-providers",e)),this._libp2p.contentRouting.findProviders(e,n)}async findAndConnect(e,t){await MH(KH(mG(this.findProviders(e,t),(async e=>this.connectTo(e.id,t).catch((e=>{this._log.error(e)})))),3)).catch((e=>{this._log.error(e)}))}async provide(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};null===(t=n.onProgress)||void 0===t||t.call(n,new qH("bitswap:network:provide",e)),await this._libp2p.contentRouting.provide(e,n)}async sendMessage(e,t){var n;let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this._running)throw new Error("network isn't running");const i=e.toString();this._log("sendMessage to %s",i,t),null===(n=r.onProgress)||void 0===n||n.call(r,new qH("bitswap:network:send-wantlist",e)),await this._writeMessage(e,t,r),this._updateSentStats(e,t.blocks)}async connectTo(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this._running)throw new Error("network isn't running");return null===(t=n.onProgress)||void 0===t||t.call(n,new qH("bitswap:network:dial",e)),this._libp2p.dial(e,n)}_updateSentStats(e,t){const n=e.toString();if(null!=this._stats){for(const e of t.values())this._stats.push(n,"dataSent",e.length);this._stats.push(n,"blocksSent",t.size)}}async _writeMessage(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=await this._libp2p.dialProtocol(e,[NG,OG,DG]);try{let e;switch(r.protocol){case DG:e=t.serializeToBitswap100();break;case OG:case NG:e=t.serializeToBitswap110();break;default:throw new Error("Unknown protocol: ".concat(r.protocol))}await _G([e],(e=>fG(e)),r),await r.close()}catch(o){var i;null===(i=n.onProgress)||void 0===i||i.call(n,new qH("bitswap:network:send-wantlist:error",{peer:e,error:o})),this._log(o),r.abort(o)}}}var LG=n(47465);const MG=e=>"unwant:".concat((0,Su.B)(e.multihash.bytes,"base64")),UG=e=>"block:".concat((0,Su.B)(e.multihash.bytes,"base64"));class FG extends LG.EventEmitter{constructor(e){super(),(0,Yo.Z)(this,"_log",void 0),this.setMaxListeners(1e3),this._log=qq(e,"notif")}hasBlock(e,t){const n=UG(e);this._log(n),this.emit(n,t)}async wantBlock(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null==e)throw new Error("Not a valid cid");const n=UG(e),r=MG(e);return this._log("wantBlock:".concat(e)),new Promise(((i,o)=>{var s;const a=()=>{var r;this.removeListener(n,c),null===(r=t.onProgress)||void 0===r||r.call(t,new qH("bitswap:want-block:unwant",e)),o(new Error("Block for ".concat(e," unwanted")))},c=n=>{var o;this.removeListener(r,a),null===(o=t.onProgress)||void 0===o||o.call(t,new qH("bitswap:want-block:block",e)),i(n)};this.once(r,a),this.once(n,c),null===(s=t.signal)||void 0===s||s.addEventListener("abort",(()=>{this.removeListener(n,c),this.removeListener(r,a),o(new Error("Want for ".concat(e," aborted")))}))}))}unwantBlock(e){const t=MG(e);this._log(t),this.emit(t)}}var KG=n(56755),jG=n.n(KG);class ZG extends LG.EventEmitter{constructor(e,t){super(),(0,Yo.Z)(this,"_options",void 0),(0,Yo.Z)(this,"_queue",void 0),(0,Yo.Z)(this,"_stats",void 0),(0,Yo.Z)(this,"_frequencyLastTime",void 0),(0,Yo.Z)(this,"_frequencyAccumulators",void 0),(0,Yo.Z)(this,"_movingAverages",void 0),(0,Yo.Z)(this,"_enabled",void 0),(0,Yo.Z)(this,"_timeout",void 0),this._options=t,this._queue=[],this._stats={},this._frequencyLastTime=Date.now(),this._frequencyAccumulators={},this._movingAverages={},this._update=this._update.bind(this),e.forEach((e=>{this._stats[e]=BigInt(0),this._movingAverages[e]={},this._options.movingAverageIntervals.forEach((t=>{(this._movingAverages[e][t]=jG()(t)).push(this._frequencyLastTime,0)}))})),this._enabled=this._options.enabled}enable(){this._enabled=!0}disable(){this._enabled=!1}stop(){null!=this._timeout&&clearTimeout(this._timeout)}get snapshot(){return Object.assign({},this._stats)}get movingAverages(){return Object.assign({},this._movingAverages)}push(e,t){this._enabled&&(this._queue.push([e,t,Date.now()]),this._resetComputeTimeout())}_resetComputeTimeout(){null!=this._timeout&&clearTimeout(this._timeout),this._timeout=setTimeout(this._update,this._nextTimeout())}_nextTimeout(){const e=this._queue.length/this._options.computeThrottleMaxQueueSize;return Math.max(this._options.computeThrottleTimeout*(1-e),0)}_update(){if(this._timeout=void 0,this._queue.length>0){let e;for(;this._queue.length>0;){const t=e=this._queue.shift();null!=t&&this._applyOp(t)}null!=e&&this._updateFrequency(e[2]),this.emit("update",this._stats)}}_updateFrequency(e){const t=e-this._frequencyLastTime;t>0&&Object.keys(this._stats).forEach((n=>{this._updateFrequencyFor(n,t,e)})),this._frequencyLastTime=e}_updateFrequencyFor(e,t,n){var r;const i=null!==(r=this._frequencyAccumulators[e])&&void 0!==r?r:0;this._frequencyAccumulators[e]=0;const o=i/t*1e3;let s=this._movingAverages[e];null==s&&(s=this._movingAverages[e]={}),this._options.movingAverageIntervals.forEach((e=>{let t=s[e];null==t&&(t=s[e]=jG()(e)),t.push(n,o)}))}_applyOp(e){const t=e[0],n=e[1];if("number"!==typeof n)throw new Error("invalid increment number: ".concat(n));Object.prototype.hasOwnProperty.call(this._stats,t)||(this._stats[t]=BigInt(0)),this._stats[t]=BigInt(this._stats[t])+BigInt(n),null==this._frequencyAccumulators[t]&&(this._frequencyAccumulators[t]=0),this._frequencyAccumulators[t]+=n}}const zG={enabled:!1,computeThrottleTimeout:1e3,computeThrottleMaxQueueSize:1e3,movingAverageIntervals:[6e4,3e5,9e5]};class VG extends LG.EventEmitter{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:zG;super(),(0,Yo.Z)(this,"_initialCounters",void 0),(0,Yo.Z)(this,"_options",void 0),(0,Yo.Z)(this,"_enabled",void 0),(0,Yo.Z)(this,"_global",void 0),(0,Yo.Z)(this,"_peers",void 0);const r=Object.assign({},zG,n);if("number"!==typeof r.computeThrottleTimeout)throw new Error("need computeThrottleTimeout");if("number"!==typeof r.computeThrottleMaxQueueSize)throw new Error("need computeThrottleMaxQueueSize");this._initialCounters=t,this._options=r,this._enabled=this._options.enabled,this._global=new ZG(t,r),this._global.on("update",(e=>this.emit("update",e))),this._peers=Rq({name:"ipfs_bitswap_stats_peers",metrics:e.metrics})}enable(){this._enabled=!0,this._options.enabled=!0,this._global.enable()}disable(){this._enabled=!1,this._options.enabled=!1,this._global.disable()}stop(){this._enabled=!1,this._global.stop();for(const e of this._peers)e[1].stop()}get snapshot(){return this._global.snapshot}get movingAverages(){return this._global.movingAverages}forPeer(e){const t=e.toString();return this._peers.get(t)}push(e,t,n){if(this._enabled&&(this._global.push(t,n),null!=e)){let r=this._peers.get(e);null==r&&(r=new ZG(this._initialCounters,this._options),this._peers.set(e,r)),r.push(t,n)}}disconnected(e){const t=e.toString(),n=this._peers.get(t);null!=n&&(n.stop(),this._peers.delete(t))}}var HG=function(e,t,n){var r=null,i=null,o=function(){r&&(clearTimeout(r),i=null,r=null)},s=function(){if(!t)return e.apply(this,arguments);var s=this,a=arguments,c=n&&!r;return o(),i=function(){e.apply(s,a)},r=setTimeout((function(){if(r=null,!c){var e=i;return i=null,e()}}),t),c?i():void 0};return s.cancel=o,s.flush=function(){var e=i;o(),e&&e()},s};class qG{constructor(e,t,n){(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"refcnt",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"_entries",void 0),(0,Yo.Z)(this,"_log",void 0),this.peerId=t,this.network=n,this.refcnt=1,this._entries=[],this._log=qq(e,"msgqueue"),this.sendEntries=HG(this.sendEntries.bind(this),1)}addMessage(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.empty||this.send(e,t)}addEntries(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._entries=this._entries.concat(e),this.sendEntries(t)}sendEntries(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(0===this._entries.length)return;const t=new Jq(!1);this._entries.forEach((e=>{!0===e.cancel?t.cancel(e.cid):t.addEntry(e.cid,e.priority)})),this._entries=[],this.addMessage(t,e)}async send(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};try{await this.network.connectTo(this.peerId,t)}catch(n){return void this._log.error("cant connect to peer %p: %s",this.peerId,n.message)}this._log("sending message to peer %p",this.peerId),this.network.sendMessage(this.peerId,e,t).catch((e=>{this._log.error("send error",e)}))}}class GG{constructor(e,t,n,r){(0,Yo.Z)(this,"peers",void 0),(0,Yo.Z)(this,"wantlist",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"_peerId",void 0),(0,Yo.Z)(this,"_log",void 0),this.peers=Rq({name:"ipfs_bitswap_want_manager_peers",metrics:r.metrics}),this.wantlist=new eG(n,r),this.network=t,this._peerId=e,this._log=qq(e,"want")}_addEntries(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const i=e.map(((e,n)=>new Jq.Entry(e,PG-n,Jq.WantType.Block,t)));i.forEach((e=>{e.cancel?!0===n?this.wantlist.removeForce(e.cid.toString(SH)):this.wantlist.remove(e.cid):(this._log("adding to wantlist"),this.wantlist.add(e.cid,e.priority))}));for(const o of this.peers.values())o.addEntries(i,r)}_startPeerHandler(e){let t=this.peers.get(e.toString());if(null!=t)return void t.refcnt++;t=new qG(this._peerId,e,this.network);const n=new Jq(!0);for(const r of this.wantlist.entries())n.addEntry(r[1].cid,r[1].priority);return t.addMessage(n),this.peers.set(e.toString(),t),t}_stopPeerHandler(e){const t=this.peers.get(e.toString());null!=t&&(t.refcnt--,t.refcnt>0||this.peers.delete(e.toString()))}wantBlocks(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._addEntries(e,!1,!1,n),null===(t=n.signal)||void 0===t||t.addEventListener("abort",(()=>{this.cancelWants(e)}))}unwantBlocks(e){this._log("unwant blocks: %s",e.length),this._addEntries(e,!0,!0)}cancelWants(e){this._log("cancel wants: %s",e.length),this._addEntries(e,!0)}connectedPeers(){return Array.from(this.peers.keys())}connected(e){this._startPeerHandler(e)}disconnected(e){this._stopPeerHandler(e)}start(){}stop(){this.peers.forEach((e=>{this.disconnected(e.peerId)}))}}const WG={maxInboundStreams:1024,maxOutboundStreams:1024,incomingStreamTimeout:3e4,hashLoader:{async getHasher(){throw new Error("Not implemented")}},statsEnabled:!1,statsComputeThrottleTimeout:1e3,statsComputeThrottleMaxQueueSize:1e3},QG=["blocksReceived","dataReceived","dupBlksReceived","dupDataReceived","blocksSent","dataSent","providesBufferLength","wantListLength","peerCount"];class YG{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};(0,Yo.Z)(this,"_libp2p",void 0),(0,Yo.Z)(this,"_log",void 0),(0,Yo.Z)(this,"stats",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"blockstore",void 0),(0,Yo.Z)(this,"engine",void 0),(0,Yo.Z)(this,"wm",void 0),(0,Yo.Z)(this,"notifications",void 0),(0,Yo.Z)(this,"started",void 0),this._libp2p=e,this._log=qq(this.peerId),n=Object.assign({},WG,n),this.stats=new VG(e,QG,{enabled:n.statsEnabled,computeThrottleTimeout:n.statsComputeThrottleTimeout,computeThrottleMaxQueueSize:n.statsComputeThrottleMaxQueueSize}),this.network=new BG(e,this,this.stats,{hashLoader:n.hashLoader,maxInboundStreams:n.maxInboundStreams,maxOutboundStreams:n.maxOutboundStreams,incomingStreamTimeout:n.incomingStreamTimeout}),this.blockstore=t,this.engine=new uG(this.peerId,t,this.network,this.stats,e),this.wm=new GG(this.peerId,this.network,this.stats,e),this.notifications=new FG(this.peerId),this.started=!1}isStarted(){return this.started}get peerId(){return this._libp2p.peerId}async _receiveMessage(e,t){try{await this.engine.messageReceived(e,t)}catch(r){this._log("failed to receive message",t)}if(0===t.blocks.size)return;const n=[];for(const[i,o]of t.blocks.entries()){const e=wq.parse(i);n.push({wasWanted:this.wm.wantlist.contains(e),cid:e,data:o})}this.wm.cancelWants(n.filter((e=>{let{wasWanted:t}=e;return t})).map((e=>{let{cid:t}=e;return t}))),await Promise.all(n.map((async t=>{let{cid:n,wasWanted:r,data:i}=t;await this._handleReceivedBlock(e,n,i,r)})))}async _handleReceivedBlock(e,t,n,r){this._log("received block");const i=await this.blockstore.has(t);this._updateReceiveCounters(e.toString(),t,n,i),r&&await this.put(t,n)}_updateReceiveCounters(e,t,n,r){this.stats.push(e,"blocksReceived",1),this.stats.push(e,"dataReceived",n.length),r&&(this.stats.push(e,"dupBlksReceived",1),this.stats.push(e,"dupDataReceived",n.length))}_receiveError(e){this._log.error("ReceiveError",e)}_onPeerConnected(e){this.wm.connected(e)}_onPeerDisconnected(e){this.wm.disconnected(e),this.engine.peerDisconnected(e),this.stats.disconnected(e)}enableStats(){this.stats.enable()}disableStats(){this.stats.disable()}wantlistForPeer(e,t){return this.engine.wantlistForPeer(e)}ledgerForPeer(e){return this.engine.ledgerForPeer(e)}async want(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=async(e,t)=>(this.wm.wantBlocks([e],t),this.notifications.wantBlock(e,t));let r=!1;const i=async(e,t)=>{try{return await this.blockstore.get(e,t)}catch(i){if("ERR_NOT_FOUND"!==i.code)throw i;return r||(r=!0,this.network.findAndConnect(e,t).catch((e=>{this._log.error(e)}))),await n(e,t)}},o=new AbortController,s=GH([o.signal,t.signal]);try{return await Promise.race([this.notifications.wantBlock(e,{...t,signal:s}),i(e,{...t,signal:s})])}finally{o.abort(),s.clear()}}unwant(e){const t=Array.isArray(e)?e:[e];this.wm.unwantBlocks(t),t.forEach((e=>{this.notifications.unwantBlock(e)}))}cancelWants(e){this.wm.cancelWants(Array.isArray(e)?e:[e])}async put(e,t,n){await this.blockstore.put(e,t),this.notify(e,t)}async*putMany(e,t){yield*this.blockstore.putMany(zd(e,(e=>{let{cid:t,block:n}=e;this.notify(t,n)})),t)}notify(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.notifications.hasBlock(e,t),this.engine.receivedBlocks([{cid:e,block:t}]),this.network.provide(e,n).catch((e=>{this._log.error("Failed to provide: %s",e.message)}))}getWantlist(){return this.wm.wantlist.entries()}get peers(){return this.engine.peers()}async start(){this.wm.start(),await this.network.start(),this.engine.start(),this.started=!0}async stop(){this.stats.stop(),this.wm.stop(),await this.network.stop(),this.engine.stop(),this.started=!1}}class JG{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"bitswap",void 0),(0,Yo.Z)(this,"started",void 0);const{libp2p:n,blockstore:r,hashers:i}=e;this.bitswap=function(e,t){return new YG(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}(n,r,{hashLoader:{getHasher:async e=>{const t=i.find((t=>t.code===e||t.name===e));if(null!=t)return t;throw new Error('Could not load hasher for code/name "'.concat(e,'"'))}},...t}),this.started=!1}isStarted(){return this.started}async start(){await this.bitswap.start(),this.started=!0}async stop(){await this.bitswap.stop(),this.started=!1}announce(e,t,n){this.bitswap.notify(e,t,n)}async retrieve(e){let{validateFn:t,...n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.bitswap.want(e,n)}}function XG(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new JG(t,e)}var $G=n(63914);function eW(e,t,n){return function(e,t,n){if(t.set)t.set.call(e,n);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=n}}(e,(0,$G.Z)(e,t,"set"),n),n}var tW=new WeakMap,nW=new WeakMap,rW=new WeakMap,iW=new WeakMap;class oW{constructor(e){(0,Yo.Z)(this,"url",void 0),(0,_x.Z)(this,tW,{writable:!0,value:0}),(0,_x.Z)(this,nW,{writable:!0,value:0}),(0,_x.Z)(this,rW,{writable:!0,value:0}),(0,_x.Z)(this,iW,{writable:!0,value:0}),this.url=e instanceof URL?e:new URL(e)}async getRawBlock(e,t){const n=this.url;if(n.pathname="/ipfs/".concat(e.toString()),n.search="?format=raw",!0===(null===t||void 0===t?void 0:t.aborted))throw new Error("Signal to fetch raw block for CID ".concat(e," from gateway ").concat(this.url," was aborted prior to fetch"));try{var r,i;eW(this,tW,(r=(0,Ix.Z)(this,tW),r++,r));const s=await fetch(n.toString(),{signal:t,headers:{Accept:"application/vnd.ipld.raw"},cache:"force-cache"});var o;if(!s.ok)throw eW(this,nW,(o=(0,Ix.Z)(this,nW),o++,o)),new Error("unable to fetch raw block for CID ".concat(e," from gateway ").concat(this.url));return eW(this,iW,(i=(0,Ix.Z)(this,iW),i++,i)),new Uint8Array(await s.arrayBuffer())}catch(a){var s;if(!0===(null===t||void 0===t?void 0:t.aborted))throw new Error("fetching raw block for CID ".concat(e," from gateway ").concat(this.url," was aborted"));throw eW(this,nW,(s=(0,Ix.Z)(this,nW),s++,s)),new Error("unable to fetch raw block for CID ".concat(e))}}reliability(){return 0===(0,Ix.Z)(this,tW)?1:(0,Ix.Z)(this,rW)>0?-1/0:(0,Ix.Z)(this,iW)/((0,Ix.Z)(this,tW)+3*(0,Ix.Z)(this,nW))}incrementInvalidBlocks(){var e;eW(this,rW,(e=(0,Ix.Z)(this,rW),e++,e))}}const sW=xH("helia:trustless-gateway-block-broker");class aW{constructor(){var e;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"gateways",void 0),this.gateways=(null!==(e=t.gateways)&&void 0!==e?e:cW).map((e=>new oW(e)))}async retrieve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.gateways.sort(((e,t)=>t.reliability()-e.reliability())),r=[];for(const a of n){sW("getting block for %c from %s",e,a.url);try{const n=await a.getRawBlock(e,t.signal);sW.trace("got block for %c from %s",e,a.url);try{var i;await(null===(i=t.validateFn)||void 0===i?void 0:i.call(t,n))}catch(s){throw sW.error("failed to validate block for %c from %s",e,a.url,s),a.incrementInvalidBlocks(),new Error("unable to validate block for CID ".concat(e," from gateway ").concat(a.url))}return n}catch(s){var o;if(sW.error("failed to get block for %c from %s",e,a.url,s),s instanceof Error?r.push(s):r.push(new Error("unable to fetch raw block for CID ".concat(e," from gateway ").concat(a.url))),!0===(null===(o=t.signal)||void 0===o?void 0:o.aborted)){sW.trace("request aborted while fetching raw block for CID %c from gateway %s",e,a.url);break}}}throw new AggregateError(r,"unable to fetch raw block for CID ".concat(e," from any gateway"))}}const cW=["https://dweb.link","https://cf-ipfs.com","https://4everland.io","https://w3s.link"];function lW(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return()=>new aW(e)}const uW=["string","number","bigint","symbol"],hW=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function dW(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(uW.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";const n=function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(hW.includes(t))return t;return}(e);return n||"Object"}class fW{constructor(e,t,n){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=n}toString(){return"Type[".concat(this.major,"].").concat(this.name)}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}fW.uint=new fW(0,"uint",!0),fW.negint=new fW(1,"negint",!0),fW.bytes=new fW(2,"bytes",!0),fW.string=new fW(3,"string",!0),fW.array=new fW(4,"array",!1),fW.map=new fW(5,"map",!1),fW.tag=new fW(6,"tag",!1),fW.float=new fW(7,"float",!0),fW.false=new fW(7,"false",!0),fW.true=new fW(7,"true",!0),fW.null=new fW(7,"null",!0),fW.undefined=new fW(7,"undefined",!0),fW.break=new fW(7,"break",!0);class pW{constructor(e,t,n){this.type=e,this.value=t,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return"Token[".concat(this.type,"].").concat(this.value)}}const gW=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"===typeof globalThis.Buffer.isBuffer,yW=new TextDecoder,mW=new TextEncoder;function vW(e){return gW&&globalThis.Buffer.isBuffer(e)}function bW(e){return e instanceof Uint8Array?vW(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const wW=gW?(e,t,n)=>n-t>64?globalThis.Buffer.from(e.subarray(t,n)).toString("utf8"):TW(e,t,n):(e,t,n)=>n-t>64?yW.decode(e.subarray(t,n)):TW(e,t,n),EW=gW?e=>e.length>64?globalThis.Buffer.from(e):CW(e):e=>e.length>64?mW.encode(e):CW(e),AW=e=>Uint8Array.from(e),SW=gW?(e,t,n)=>vW(e)?new Uint8Array(e.subarray(t,n)):e.slice(t,n):(e,t,n)=>e.slice(t,n),_W=gW?(e,t)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),bW(globalThis.Buffer.concat(e,t))):(e,t)=>{const n=new Uint8Array(t);let r=0;for(let i of e)r+i.length>n.length&&(i=i.subarray(0,n.length-r)),n.set(i,r),r+=i.length;return n},IW=gW?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function CW(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let i=e.charCodeAt(r);i<128?t[n++]=i:i<2048?(t[n++]=i>>6|192,t[n++]=63&i|128):55296===(64512&i)&&r+1<e.length&&56320===(64512&e.charCodeAt(r+1))?(i=65536+((1023&i)<<10)+(1023&e.charCodeAt(++r)),t[n++]=i>>18|240,t[n++]=i>>12&63|128,t[n++]=i>>6&63|128,t[n++]=63&i|128):(t[n++]=i>>12|224,t[n++]=i>>6&63|128,t[n++]=63&i|128)}return t}function TW(e,t,n){const r=[];for(;t<n;){const i=e[t];let o=null,s=i>239?4:i>223?3:i>191?2:1;if(t+s<=n){let n,r,a,c;switch(s){case 1:i<128&&(o=i);break;case 2:n=e[t+1],128===(192&n)&&(c=(31&i)<<6|63&n,c>127&&(o=c));break;case 3:n=e[t+1],r=e[t+2],128===(192&n)&&128===(192&r)&&(c=(15&i)<<12|(63&n)<<6|63&r,c>2047&&(c<55296||c>57343)&&(o=c));break;case 4:n=e[t+1],r=e[t+2],a=e[t+3],128===(192&n)&&128===(192&r)&&128===(192&a)&&(c=(15&i)<<18|(63&n)<<12|(63&r)<<6|63&a,c>65535&&c<1114112&&(o=c))}}null===o?(o=65533,s=1):o>65535&&(o-=65536,r.push(o>>>10&1023|55296),o=56320|1023&o),r.push(o),t+=s}return RW(r)}const kW=4096;function RW(e){const t=e.length;if(t<=kW)return String.fromCharCode.apply(String,e);let n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=kW));return n}class xW{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:256;this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const n=t.length-(this.maxCursor-this.cursor)-1;t.set(e,n)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=IW(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(){let e,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(1===this.chunks.length){const n=this.chunks[0];t&&this.cursor>n.length/2?(e=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):e=SW(n,0,this.cursor)}else e=_W(this.chunks,this.cursor);return t&&this.reset(),e}}const PW="CBOR decode error:",DW="CBOR encode error:",OW=[];function NW(e,t,n){if(e.length-t<n)throw new Error("".concat(PW," not enough data for type"))}OW[23]=1,OW[24]=2,OW[25]=3,OW[26]=5,OW[27]=9;const BW=[24,256,65536,4294967296,BigInt("18446744073709551616")];function LW(e,t,n){NW(e,t,1);const r=e[t];if(!0===n.strict&&r<BW[0])throw new Error("".concat(PW," integer encoded in more bytes than necessary (strict decode)"));return r}function MW(e,t,n){NW(e,t,2);const r=e[t]<<8|e[t+1];if(!0===n.strict&&r<BW[1])throw new Error("".concat(PW," integer encoded in more bytes than necessary (strict decode)"));return r}function UW(e,t,n){NW(e,t,4);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===n.strict&&r<BW[2])throw new Error("".concat(PW," integer encoded in more bytes than necessary (strict decode)"));return r}function FW(e,t,n){NW(e,t,8);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],i=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],o=(BigInt(r)<<BigInt(32))+BigInt(i);if(!0===n.strict&&o<BW[3])throw new Error("".concat(PW," integer encoded in more bytes than necessary (strict decode)"));if(o<=Number.MAX_SAFE_INTEGER)return Number(o);if(!0===n.allowBigInt)return o;throw new Error("".concat(PW," integers outside of the safe integer range are not supported"))}function KW(e,t){return jW(e,0,t.value)}function jW(e,t,n){if(n<BW[0]){const r=Number(n);e.push([t|r])}else if(n<BW[1]){const r=Number(n);e.push([24|t,r])}else if(n<BW[2]){const r=Number(n);e.push([25|t,r>>>8,255&r])}else if(n<BW[3]){const r=Number(n);e.push([26|t,r>>>24&255,r>>>16&255,r>>>8&255,255&r])}else{const r=BigInt(n);if(!(r<BW[4]))throw new Error("".concat(PW," encountered BigInt larger than allowable range"));{const n=[27|t,0,0,0,0,0,0,0];let i=Number(r&BigInt(4294967295)),o=Number(r>>BigInt(32)&BigInt(4294967295));n[8]=255&i,i>>=8,n[7]=255&i,i>>=8,n[6]=255&i,i>>=8,n[5]=255&i,n[4]=255&o,o>>=8,n[3]=255&o,o>>=8,n[2]=255&o,o>>=8,n[1]=255&o,e.push(n)}}}KW.encodedSize=function(e){return jW.encodedSize(e.value)},jW.encodedSize=function(e){return e<BW[0]?1:e<BW[1]?2:e<BW[2]?3:e<BW[3]?5:9},KW.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const ZW=BigInt(-1),zW=BigInt(1);function VW(e,t){const n=t.value,r="bigint"===typeof n?n*ZW-zW:-1*n-1;jW(e,t.type.majorEncoded,r)}function HW(e,t,n,r){NW(e,t,n+r);const i=SW(e,t+n,t+n+r);return new pW(fW.bytes,i,n+r)}function qW(e,t,n,r){return HW(e,t,1,n)}function GW(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===fW.string?EW(e.value):e.value),e.encodedBytes}function WW(e,t){const n=GW(t);jW(e,t.type.majorEncoded,n.length),e.push(n)}function QW(e,t,n,r,i){const o=n+r;NW(e,t,o);const s=new pW(fW.string,wW(e,t+n,t+o),o);return!0===i.retainStringBytes&&(s.byteValue=SW(e,t+n,t+o)),s}function YW(e,t,n,r){return QW(e,t,1,n,r)}VW.encodedSize=function(e){const t=e.value,n="bigint"===typeof t?t*ZW-zW:-1*t-1;return n<BW[0]?1:n<BW[1]?2:n<BW[2]?3:n<BW[3]?5:9},VW.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},WW.encodedSize=function(e){const t=GW(e);return jW.encodedSize(t.length)+t.length},WW.compareTokens=function(e,t){return n=GW(e),r=GW(t),n.length<r.length?-1:n.length>r.length?1:function(e,t){if(vW(e)&&vW(t))return e.compare(t);for(let n=0;n<e.length;n++)if(e[n]!==t[n])return e[n]<t[n]?-1:1;return 0}(n,r);var n,r};const JW=WW;function XW(e,t,n,r){return new pW(fW.array,r,n)}function $W(e,t,n,r){return XW(0,0,1,n)}function eQ(e,t){jW(e,fW.array.majorEncoded,t.value)}function tQ(e,t,n,r){return new pW(fW.map,r,n)}function nQ(e,t,n,r){return tQ(0,0,1,n)}function rQ(e,t){jW(e,fW.map.majorEncoded,t.value)}function iQ(e,t,n,r){return new pW(fW.tag,n,1)}function oQ(e,t){jW(e,fW.tag.majorEncoded,t.value)}eQ.compareTokens=KW.compareTokens,eQ.encodedSize=function(e){return jW.encodedSize(e.value)},rQ.compareTokens=KW.compareTokens,rQ.encodedSize=function(e){return jW.encodedSize(e.value)},oQ.compareTokens=KW.compareTokens,oQ.encodedSize=function(e){return jW.encodedSize(e.value)};const sQ=20,aQ=21,cQ=22,lQ=23;function uQ(e,t,n){if(n){if(!1===n.allowNaN&&Number.isNaN(e))throw new Error("".concat(PW," NaN values are not supported"));if(!1===n.allowInfinity&&(e===1/0||e===-1/0))throw new Error("".concat(PW," Infinity values are not supported"))}return new pW(fW.float,e,t)}function hQ(e,t,n){const r=t.value;if(!1===r)e.push([fW.float.majorEncoded|sQ]);else if(!0===r)e.push([fW.float.majorEncoded|aQ]);else if(null===r)e.push([fW.float.majorEncoded|cQ]);else if(void 0===r)e.push([fW.float.majorEncoded|lQ]);else{let t,o=!1;n&&!0===n.float64||(gQ(r),t=yQ(pQ,1),r===t||Number.isNaN(r)?(pQ[0]=249,e.push(pQ.slice(0,3)),o=!0):(mQ(r),t=vQ(pQ,1),r===t&&(pQ[0]=250,e.push(pQ.slice(0,5)),o=!0))),o||(i=r,fQ.setFloat64(0,i,!1),t=bQ(pQ,1),pQ[0]=251,e.push(pQ.slice(0,9)))}var i}hQ.encodedSize=function(e,t){const n=e.value;if(!1===n||!0===n||null===n||void 0===n)return 1;if(!t||!0!==t.float64){gQ(n);let e=yQ(pQ,1);if(n===e||Number.isNaN(n))return 3;if(mQ(n),e=vQ(pQ,1),n===e)return 5}return 9};const dQ=new ArrayBuffer(9),fQ=new DataView(dQ,1),pQ=new Uint8Array(dQ,0);function gQ(e){if(e===1/0)fQ.setUint16(0,31744,!1);else if(e===-1/0)fQ.setUint16(0,64512,!1);else if(Number.isNaN(e))fQ.setUint16(0,32256,!1);else{fQ.setFloat32(0,e);const t=fQ.getUint32(0),n=(2139095040&t)>>23,r=8388607&t;if(255===n)fQ.setUint16(0,31744,!1);else if(0===n)fQ.setUint16(0,(2147483648&e)>>16|r>>13,!1);else{const e=n-127;e<-24?fQ.setUint16(0,0):e<-14?fQ.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):fQ.setUint16(0,(2147483648&t)>>16|e+15<<10|r>>13,!1)}}}function yQ(e,t){if(e.length-t<2)throw new Error("".concat(PW," not enough data for float16"));const n=(e[t]<<8)+e[t+1];if(31744===n)return 1/0;if(64512===n)return-1/0;if(32256===n)return NaN;const r=n>>10&31,i=1023&n;let o;return o=0===r?i*2**-24:31!==r?(i+1024)*2**(r-25):0===i?1/0:NaN,32768&n?-o:o}function mQ(e){fQ.setFloat32(0,e,!1)}function vQ(e,t){if(e.length-t<4)throw new Error("".concat(PW," not enough data for float32"));const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,4).getFloat32(0,!1)}function bQ(e,t){if(e.length-t<8)throw new Error("".concat(PW," not enough data for float64"));const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,8).getFloat64(0,!1)}function wQ(e,t,n){throw new Error("".concat(PW," encountered invalid minor (").concat(n,") for major ").concat(e[t]>>>5))}function EQ(e){return()=>{throw new Error("".concat(PW," ").concat(e))}}hQ.compareTokens=KW.compareTokens;const AQ=[];for(let yye=0;yye<=23;yye++)AQ[yye]=wQ;AQ[24]=function(e,t,n,r){return new pW(fW.uint,LW(e,t+1,r),2)},AQ[25]=function(e,t,n,r){return new pW(fW.uint,MW(e,t+1,r),3)},AQ[26]=function(e,t,n,r){return new pW(fW.uint,UW(e,t+1,r),5)},AQ[27]=function(e,t,n,r){return new pW(fW.uint,FW(e,t+1,r),9)},AQ[28]=wQ,AQ[29]=wQ,AQ[30]=wQ,AQ[31]=wQ;for(let yye=32;yye<=55;yye++)AQ[yye]=wQ;AQ[56]=function(e,t,n,r){return new pW(fW.negint,-1-LW(e,t+1,r),2)},AQ[57]=function(e,t,n,r){return new pW(fW.negint,-1-MW(e,t+1,r),3)},AQ[58]=function(e,t,n,r){return new pW(fW.negint,-1-UW(e,t+1,r),5)},AQ[59]=function(e,t,n,r){const i=FW(e,t+1,r);if("bigint"!==typeof i){const e=-1-i;if(e>=Number.MIN_SAFE_INTEGER)return new pW(fW.negint,e,9)}if(!0!==r.allowBigInt)throw new Error("".concat(PW," integers outside of the safe integer range are not supported"));return new pW(fW.negint,ZW-BigInt(i),9)},AQ[60]=wQ,AQ[61]=wQ,AQ[62]=wQ,AQ[63]=wQ;for(let yye=64;yye<=87;yye++)AQ[yye]=qW;AQ[88]=function(e,t,n,r){return HW(e,t,2,LW(e,t+1,r))},AQ[89]=function(e,t,n,r){return HW(e,t,3,MW(e,t+1,r))},AQ[90]=function(e,t,n,r){return HW(e,t,5,UW(e,t+1,r))},AQ[91]=function(e,t,n,r){const i=FW(e,t+1,r);if("bigint"===typeof i)throw new Error("".concat(PW," 64-bit integer bytes lengths not supported"));return HW(e,t,9,i)},AQ[92]=wQ,AQ[93]=wQ,AQ[94]=wQ,AQ[95]=EQ("indefinite length bytes/strings are not supported");for(let yye=96;yye<=119;yye++)AQ[yye]=YW;AQ[120]=function(e,t,n,r){return QW(e,t,2,LW(e,t+1,r),r)},AQ[121]=function(e,t,n,r){return QW(e,t,3,MW(e,t+1,r),r)},AQ[122]=function(e,t,n,r){return QW(e,t,5,UW(e,t+1,r),r)},AQ[123]=function(e,t,n,r){const i=FW(e,t+1,r);if("bigint"===typeof i)throw new Error("".concat(PW," 64-bit integer string lengths not supported"));return QW(e,t,9,i,r)},AQ[124]=wQ,AQ[125]=wQ,AQ[126]=wQ,AQ[127]=EQ("indefinite length bytes/strings are not supported");for(let yye=128;yye<=151;yye++)AQ[yye]=$W;AQ[152]=function(e,t,n,r){return XW(0,0,2,LW(e,t+1,r))},AQ[153]=function(e,t,n,r){return XW(0,0,3,MW(e,t+1,r))},AQ[154]=function(e,t,n,r){return XW(0,0,5,UW(e,t+1,r))},AQ[155]=function(e,t,n,r){const i=FW(e,t+1,r);if("bigint"===typeof i)throw new Error("".concat(PW," 64-bit integer array lengths not supported"));return XW(0,0,9,i)},AQ[156]=wQ,AQ[157]=wQ,AQ[158]=wQ,AQ[159]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error("".concat(PW," indefinite length items not allowed"));return XW(0,0,1,1/0)};for(let yye=160;yye<=183;yye++)AQ[yye]=nQ;AQ[184]=function(e,t,n,r){return tQ(0,0,2,LW(e,t+1,r))},AQ[185]=function(e,t,n,r){return tQ(0,0,3,MW(e,t+1,r))},AQ[186]=function(e,t,n,r){return tQ(0,0,5,UW(e,t+1,r))},AQ[187]=function(e,t,n,r){const i=FW(e,t+1,r);if("bigint"===typeof i)throw new Error("".concat(PW," 64-bit integer map lengths not supported"));return tQ(0,0,9,i)},AQ[188]=wQ,AQ[189]=wQ,AQ[190]=wQ,AQ[191]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error("".concat(PW," indefinite length items not allowed"));return tQ(0,0,1,1/0)};for(let yye=192;yye<=215;yye++)AQ[yye]=iQ;AQ[216]=function(e,t,n,r){return new pW(fW.tag,LW(e,t+1,r),2)},AQ[217]=function(e,t,n,r){return new pW(fW.tag,MW(e,t+1,r),3)},AQ[218]=function(e,t,n,r){return new pW(fW.tag,UW(e,t+1,r),5)},AQ[219]=function(e,t,n,r){return new pW(fW.tag,FW(e,t+1,r),9)},AQ[220]=wQ,AQ[221]=wQ,AQ[222]=wQ,AQ[223]=wQ;for(let yye=224;yye<=243;yye++)AQ[yye]=EQ("simple values are not supported");AQ[244]=wQ,AQ[245]=wQ,AQ[246]=wQ,AQ[247]=function(e,t,n,r){if(!1===r.allowUndefined)throw new Error("".concat(PW," undefined values are not supported"));return!0===r.coerceUndefinedToNull?new pW(fW.null,null,1):new pW(fW.undefined,void 0,1)},AQ[248]=EQ("simple values are not supported"),AQ[249]=function(e,t,n,r){return uQ(yQ(e,t+1),3,r)},AQ[250]=function(e,t,n,r){return uQ(vQ(e,t+1),5,r)},AQ[251]=function(e,t,n,r){return uQ(bQ(e,t+1),9,r)},AQ[252]=wQ,AQ[253]=wQ,AQ[254]=wQ,AQ[255]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error("".concat(PW," indefinite length items not allowed"));return new pW(fW.break,void 0,1)};const SQ=[];for(let yye=0;yye<24;yye++)SQ[yye]=new pW(fW.uint,yye,1);for(let yye=-1;yye>=-24;yye--)SQ[31-yye]=new pW(fW.negint,yye,1);SQ[64]=new pW(fW.bytes,new Uint8Array(0),1),SQ[96]=new pW(fW.string,"",1),SQ[128]=new pW(fW.array,0,1),SQ[160]=new pW(fW.map,0,1),SQ[244]=new pW(fW.false,!1,1),SQ[245]=new pW(fW.true,!0,1),SQ[246]=new pW(fW.null,null,1);const _Q={float64:!1,mapSorter:function(e,t){const n=Array.isArray(e[0])?e[0][0]:e[0],r=Array.isArray(t[0])?t[0][0]:t[0];if(n.type!==r.type)return n.type.compare(r.type);const i=n.type.major,o=IQ[i].compareTokens(n,r);0===o&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");return o},quickEncodeToken:function(e){switch(e.type){case fW.false:return AW([244]);case fW.true:return AW([245]);case fW.null:return AW([246]);case fW.bytes:return e.value.length?void 0:AW([64]);case fW.string:return""===e.value?AW([96]):void 0;case fW.array:return 0===e.value?AW([128]):void 0;case fW.map:return 0===e.value?AW([160]):void 0;case fW.uint:return e.value<24?AW([Number(e.value)]):void 0;case fW.negint:if(e.value>=-24)return AW([31-Number(e.value)])}}};const IQ=function(){const e=[];return e[fW.uint.major]=KW,e[fW.negint.major]=VW,e[fW.bytes.major]=WW,e[fW.string.major]=JW,e[fW.array.major]=eQ,e[fW.map.major]=rQ,e[fW.tag.major]=oQ,e[fW.float.major]=hQ,e}(),CQ=new xW;class TQ{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error("".concat(DW," object contains circular references"));return new TQ(t,e)}}const kQ={null:new pW(fW.null,null),undefined:new pW(fW.undefined,void 0),true:new pW(fW.true,!0),false:new pW(fW.false,!1),emptyArray:new pW(fW.array,0),emptyMap:new pW(fW.map,0)},RQ={number:(e,t,n,r)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new pW(e>=0?fW.uint:fW.negint,e):new pW(fW.float,e),bigint:(e,t,n,r)=>e>=BigInt(0)?new pW(fW.uint,e):new pW(fW.negint,e),Uint8Array:(e,t,n,r)=>new pW(fW.bytes,e),string:(e,t,n,r)=>new pW(fW.string,e),boolean:(e,t,n,r)=>e?kQ.true:kQ.false,null:(e,t,n,r)=>kQ.null,undefined:(e,t,n,r)=>kQ.undefined,ArrayBuffer:(e,t,n,r)=>new pW(fW.bytes,new Uint8Array(e)),DataView:(e,t,n,r)=>new pW(fW.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,n,r){if(!e.length)return!0===n.addBreakTokens?[kQ.emptyArray,new pW(fW.break)]:kQ.emptyArray;r=TQ.createCheck(r,e);const i=[];let o=0;for(const s of e)i[o++]=xQ(s,n,r);return n.addBreakTokens?[new pW(fW.array,e.length),i,new pW(fW.break)]:[new pW(fW.array,e.length),i]},Object(e,t,n,r){const i="Object"!==t,o=i?e.keys():Object.keys(e),s=i?e.size:o.length;if(!s)return!0===n.addBreakTokens?[kQ.emptyMap,new pW(fW.break)]:kQ.emptyMap;r=TQ.createCheck(r,e);const a=[];let c=0;for(const l of o)a[c++]=[xQ(l,n,r),xQ(i?e.get(l):e[l],n,r)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(a,n),n.addBreakTokens?[new pW(fW.map,s),a,new pW(fW.break)]:[new pW(fW.map,s),a]}};RQ.Map=RQ.Object,RQ.Buffer=RQ.Uint8Array;for(const yye of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))RQ["".concat(yye,"Array")]=RQ.DataView;function xQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2?arguments[2]:void 0;const r=dW(e),i=t&&t.typeEncoders&&t.typeEncoders[r]||RQ[r];if("function"===typeof i){const o=i(e,r,t,n);if(null!=o)return o}const o=RQ[r];if(!o)throw new Error("".concat(DW," unsupported type: ").concat(r));return o(e,r,t,n)}function PQ(e,t,n,r){if(Array.isArray(t))for(const i of t)PQ(e,i,n,r);else n[t.type.major](e,t,r)}function DQ(e,t,n){const r=xQ(e,n);if(!Array.isArray(r)&&n.quickEncodeToken){const e=n.quickEncodeToken(r);if(e)return e;const i=t[r.type.major];if(i.encodedSize){const e=i.encodedSize(r,n),t=new xW(e);if(i(t,r,n),1!==t.chunks.length)throw new Error("Unexpected error: pre-calculated length for ".concat(r," was wrong"));return bW(t.chunks[0])}}return CQ.reset(),PQ(CQ,r,t,n),CQ.toBytes(!0)}function OQ(e,t){return t=Object.assign({},_Q,t),DQ(e,IQ,t)}const NQ={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class BQ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=SQ[e];if(void 0===t){const n=AQ[e];if(!n)throw new Error("".concat(PW," no decoder for major type ").concat(e>>>5," (byte 0x").concat(e.toString(16).padStart(2,"0"),")"));const r=31&e;t=n(this.data,this._pos,r,this.options)}return this._pos+=t.encodedLength,t}}const LQ=Symbol.for("DONE"),MQ=Symbol.for("BREAK");function UQ(e,t){if(e.done())return LQ;const n=e.next();if(n.type===fW.break)return MQ;if(n.type.terminal)return n.value;if(n.type===fW.array)return function(e,t,n){const r=[];for(let i=0;i<e.value;i++){const o=UQ(t,n);if(o===MQ){if(e.value===1/0)break;throw new Error("".concat(PW," got unexpected break to lengthed array"))}if(o===LQ)throw new Error("".concat(PW," found array but not enough entries (got ").concat(i,", expected ").concat(e.value,")"));r[i]=o}return r}(n,e,t);if(n.type===fW.map)return function(e,t,n){const r=!0===n.useMaps,i=r?void 0:{},o=r?new Map:void 0;for(let s=0;s<e.value;s++){const a=UQ(t,n);if(a===MQ){if(e.value===1/0)break;throw new Error("".concat(PW," got unexpected break to lengthed map"))}if(a===LQ)throw new Error("".concat(PW," found map but not enough entries (got ").concat(s," [no key], expected ").concat(e.value,")"));if(!0!==r&&"string"!==typeof a)throw new Error("".concat(PW," non-string keys not supported (got ").concat(typeof a,")"));if(!0===n.rejectDuplicateMapKeys&&(r&&o.has(a)||!r&&a in i))throw new Error("".concat(PW,' found repeat map key "').concat(a,'"'));const c=UQ(t,n);if(c===LQ)throw new Error("".concat(PW," found map but not enough entries (got ").concat(s," [no value], expected ").concat(e.value,")"));r?o.set(a,c):i[a]=c}return r?o:i}(n,e,t);if(n.type===fW.tag){if(t.tags&&"function"===typeof t.tags[n.value]){const r=UQ(e,t);return t.tags[n.value](r)}throw new Error("".concat(PW," tag not supported (").concat(n.value,")"))}throw new Error("unsupported")}function FQ(e,t){const[n,r]=function(e,t){if(!(e instanceof Uint8Array))throw new Error("".concat(PW," data to decode must be a Uint8Array"));const n=(t=Object.assign({},NQ,t)).tokenizer||new BQ(e,t),r=UQ(n,t);if(r===LQ)throw new Error("".concat(PW," did not find any content to decode"));if(r===MQ)throw new Error("".concat(PW," got unexpected break"));return[r,e.subarray(n.pos())]}(e,t);if(r.length>0)throw new Error("".concat(PW," too many terminals, data makes no sense"));return n}const KQ=dH({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),jQ=dH({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var ZQ=n(1315);fW.uint.major,fW.negint.major,fW.bytes.major,fW.string.major,fW.array.major,fW.map.major,fW.tag.major,fW.float.major;class zQ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._pos=0,this.data=e,this.options=t,this.modeStack=["value"],this.lastToken=""}pos(){return this._pos}done(){return this._pos>=this.data.length}ch(){return this.data[this._pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let e=this.ch();for(;32===e||9===e||13===e||10===e;)e=this.data[++this._pos]}expect(e){if(this.data.length-this._pos<e.length)throw new Error("".concat(PW," unexpected end of input at position ").concat(this._pos));for(let t=0;t<e.length;t++)if(this.data[this._pos++]!==e[t])throw new Error("".concat(PW," unexpected token at position ").concat(this._pos,", expected to find '").concat(String.fromCharCode(...e),"'"))}parseNumber(){const e=this._pos;let t=!1,n=!1;const r=e=>{for(;!this.done();){const t=this.ch();if(!e.includes(t))break;this._pos++}};if(45===this.ch()&&(t=!0,this._pos++),48===this.ch()){if(this._pos++,46!==this.ch())return new pW(fW.uint,0,this._pos-e);this._pos++,n=!0}if(r([48,49,50,51,52,53,54,55,56,57]),t&&this._pos===e+1)throw new Error("".concat(PW," unexpected token at position ").concat(this._pos));if(!this.done()&&46===this.ch()){if(n)throw new Error("".concat(PW," unexpected token at position ").concat(this._pos));n=!0,this._pos++,r([48,49,50,51,52,53,54,55,56,57])}this.done()||101!==this.ch()&&69!==this.ch()||(n=!0,this._pos++,this.done()||43!==this.ch()&&45!==this.ch()||this._pos++,r([48,49,50,51,52,53,54,55,56,57]));const i=String.fromCharCode.apply(null,this.data.subarray(e,this._pos)),o=parseFloat(i);return n?new pW(fW.float,o,this._pos-e):!0!==this.options.allowBigInt||Number.isSafeInteger(o)?new pW(o>=0?fW.uint:fW.negint,o,this._pos-e):new pW(o>=0?fW.uint:fW.negint,BigInt(i),this._pos-e)}parseString(){if(34!==this.ch())throw new Error("".concat(PW," unexpected character at position ").concat(this._pos,"; this shouldn't happen"));this._pos++;for(let i=this._pos,o=0;i<this.data.length&&o<65536;i++,o++){const e=this.data[i];if(92===e||e<32||e>=128)break;if(34===e){const e=String.fromCharCode.apply(null,this.data.subarray(this._pos,i));return this._pos=i+1,new pW(fW.string,e,o)}}const e=this._pos,t=[],n=()=>{if(this._pos+4>=this.data.length)throw new Error("".concat(PW," unexpected end of unicode escape sequence at position ").concat(this._pos));let e=0;for(let t=0;t<4;t++){let t=this.ch();if(t>=48&&t<=57)t-=48;else if(t>=97&&t<=102)t=t-97+10;else{if(!(t>=65&&t<=70))throw new Error("".concat(PW," unexpected unicode escape character at position ").concat(this._pos));t=t-65+10}e=16*e+t,this._pos++}return e},r=()=>{const e=this.ch();let n,r,i,o,s=null,a=e>239?4:e>223?3:e>191?2:1;if(this._pos+a>this.data.length)throw new Error("".concat(PW," unexpected unicode sequence at position ").concat(this._pos));switch(a){case 1:e<128&&(s=e);break;case 2:n=this.data[this._pos+1],128===(192&n)&&(o=(31&e)<<6|63&n,o>127&&(s=o));break;case 3:n=this.data[this._pos+1],r=this.data[this._pos+2],128===(192&n)&&128===(192&r)&&(o=(15&e)<<12|(63&n)<<6|63&r,o>2047&&(o<55296||o>57343)&&(s=o));break;case 4:n=this.data[this._pos+1],r=this.data[this._pos+2],i=this.data[this._pos+3],128===(192&n)&&128===(192&r)&&128===(192&i)&&(o=(15&e)<<18|(63&n)<<12|(63&r)<<6|63&i,o>65535&&o<1114112&&(s=o))}null===s?(s=65533,a=1):s>65535&&(s-=65536,t.push(s>>>10&1023|55296),s=56320|1023&s),t.push(s),this._pos+=a};for(;!this.done();){const i=this.ch();let o;switch(i){case 92:if(this._pos++,this.done())throw new Error("".concat(PW," unexpected string termination at position ").concat(this._pos));switch(o=this.ch(),this._pos++,o){case 34:case 39:case 92:case 47:t.push(o);break;case 98:t.push(8);break;case 116:t.push(9);break;case 110:t.push(10);break;case 102:t.push(12);break;case 114:t.push(13);break;case 117:t.push(n());break;default:throw new Error("".concat(PW," unexpected string escape character at position ").concat(this._pos))}break;case 34:return this._pos++,new pW(fW.string,RW(t),this._pos-e);default:if(i<32)throw new Error("".concat(PW," invalid control character at position ").concat(this._pos));i<128?(t.push(i),this._pos++):r()}}throw new Error("".concat(PW," unexpected end of string at position ").concat(this._pos))}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this._pos++,new pW(fW.map,1/0,1);case 91:return this.modeStack.push("array-start"),this._pos++,new pW(fW.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new pW(fW.null,null,4);case 102:return this.expect([102,97,108,115,101]),new pW(fW.false,!1,5);case 116:return this.expect([116,114,117,101]),new pW(fW.true,!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error("".concat(PW," unexpected character at position ").concat(this._pos))}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":if(this.modeStack.pop(),93===this.ch())return this._pos++,this.skipWhitespace(),new pW(fW.break,void 0,1);if(44!==this.ch())throw new Error("".concat(PW," unexpected character at position ").concat(this._pos,", was expecting array delimiter but found '").concat(String.fromCharCode(this.ch()),"'"));return this._pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue();case"array-start":return this.modeStack.pop(),93===this.ch()?(this._pos++,this.skipWhitespace(),new pW(fW.break,void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(125===this.ch())return this.modeStack.pop(),this._pos++,this.skipWhitespace(),new pW(fW.break,void 0,1);if(44!==this.ch())throw new Error("".concat(PW," unexpected character at position ").concat(this._pos,", was expecting object delimiter but found '").concat(String.fromCharCode(this.ch()),"'"));this._pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),125===this.ch())return this._pos++,this.skipWhitespace(),new pW(fW.break,void 0,1);const e=this.parseString();if(this.skipWhitespace(),58!==this.ch())throw new Error("".concat(PW," unexpected character at position ").concat(this._pos,", was expecting key/value delimiter ':' but found '").concat(String.fromCharCode(this.ch()),"'"));return this._pos++,this.modeStack.push("obj-value"),e}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error("".concat(PW," unexpected parse state at position ").concat(this._pos,"; this shouldn't happen"))}}}const VQ=new TextEncoder,HQ=new TextDecoder,qQ="json",GQ=512,WQ=e=>VQ.encode(JSON.stringify(e)),QQ=e=>JSON.parse(HQ.decode(e)),YQ="raw",JQ=85,XQ=e=>oH(e),$Q=e=>oH(e),eY={codec:Qo.code,async*walk(e){const t=Qo.decode(e);yield*t.Links.map((e=>e.Hash))}},tY={codec:JQ,async*walk(){}},nY={codec:ti.code,async*walk(e){const t=[],n=[];n[42]=e=>{if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");const n=wq.decode(e.subarray(1));return t.push(n),n},FQ(e,{tags:n}),yield*t}};class rY extends zQ{constructor(e,t){super(e,t),(0,Yo.Z)(this,"tokenBuffer",void 0),this.tokenBuffer=[]}done(){return 0===this.tokenBuffer.length&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===fW.map){const e=this._next();if(e.type===fW.string&&"/"===e.value){const e=this._next();if(e.type===fW.string){if(this._next().type!==fW.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(e),new pW(fW.tag,42,0)}if(e.type===fW.map){const e=this._next();if(e.type===fW.string&&"bytes"===e.value){const e=this._next();if(e.type===fW.string){for(let e=0;e<2;e++){if(this._next().type!==fW.break)throw new Error("Invalid encoded Bytes form")}const t=IH.decode("m".concat(e.value));return new pW(fW.bytes,t,e.value.length)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}return e}}const iY=[tY,eY,nY,{codec:ZQ.code,async*walk(e){const t=[],n=[];var r,i;n[42]=e=>{const n=wq.parse(e);return t.push(n),n},r=e,i={tags:n,tokenizer:new rY(e,{tags:n,allowIndefinite:!0,allowUndefined:!0,allowNaN:!0,allowInfinity:!0,allowBigInt:!0,strict:!1,rejectDuplicateMapKeys:!1})},FQ(r,i=Object.assign({tokenizer:new zQ(r,i)},i)),yield*t}},{codec:GQ,async*walk(){}}],oY="/pin/",sY="/pinned-block/",aY=KQ;function cY(e){return 0===e.version&&(e=e.toV1()),new BH("".concat(oY).concat(e.toString(aY)))}var lY=new WeakSet,uY=new WeakSet;class hY{constructor(e,t,n){Jd(this,uY),Jd(this,lY),(0,Yo.Z)(this,"datastore",void 0),(0,Yo.Z)(this,"blockstore",void 0),(0,Yo.Z)(this,"dagWalkers",void 0),this.datastore=e,this.blockstore=t,this.dagWalkers={},[...iY,...n].forEach((e=>{this.dagWalkers[e.codec]=e}))}async add(e){var t,n;let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const i=cY(e);if(await this.datastore.has(i))throw new Error("Already pinned");const o=Math.round(null!==(t=r.depth)&&void 0!==t?t:1/0);if(o<0)throw new Error("Depth must be greater than or equal to 0");const s=new Fm.Z({concurrency:1});s.add((async()=>{await Xd(this,lY,dY).call(this,e,s,(t=>{null==t.pinnedBy.find((t=>(0,Ms.f)(t,e.bytes)))&&(t.pinCount++,t.pinnedBy.push(e.bytes))}),{...r,depth:o})}));const a=Ws();s.on("error",(e=>{s.clear(),a.reject(e)})),await Promise.race([s.onIdle(),a.promise]);const c={depth:o,metadata:null!==(n=r.metadata)&&void 0!==n?n:{}};return await this.datastore.put(i,OQ(c),r),{cid:e,...c}}async rm(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=cY(e),r=FQ(await this.datastore.get(n,t));await this.datastore.delete(n,t);const i=new Fm.Z({concurrency:1});return i.add((async()=>{await Xd(this,lY,dY).call(this,e,i,(t=>{t.pinCount--,t.pinnedBy=t.pinnedBy.filter((t=>(0,Ms.f)(t,e.bytes)))}),{...t,depth:r.depth})})),await i.onIdle(),{cid:e,...r}}ls(){try{var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return async function*(){for await(const{key:n,value:r}of e.datastore.query({prefix:oY+(null!=t.cid?"".concat(t.cid.toString(KQ)):"")},t)){const e=wq.parse(n.toString().substring(5),KQ),t=FQ(r);yield{cid:e,...t}}}()}catch(t){return Promise.reject(t)}}async isPinned(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new BH("".concat(sY).concat(aY.encode(e.multihash.bytes)));return this.datastore.has(n,t)}}async function dY(e,t,n,r){if(-1===r.depth)return;const i=this.dagWalkers[e.code];if(null==i)throw new Error("No dag walker found for cid codec ".concat(e.code));const o=await this.blockstore.get(e,r);await Xd(this,uY,fY).call(this,e,n,r);for await(const s of i.walk(o))t.add((async()=>{await Xd(this,lY,dY).call(this,s,t,n,{...r,depth:r.depth-1})}))}async function fY(e,t,n){var r;const i=new BH("".concat(sY).concat(aY.encode(e.multihash.bytes)));let o={pinCount:0,pinnedBy:[]};try{o=FQ(await this.datastore.get(i,n))}catch(s){if("ERR_NOT_FOUND"!==s.code)throw s}t(o),0===o.pinCount&&await this.datastore.has(i)?await this.datastore.delete(i):(await this.datastore.put(i,OQ(o),n),null===(r=n.onProgress)||void 0===r||r.call(n,new qH("helia:pin:add",{detail:e})))}const pY="lock:worker:request-read",gY="lock:worker:release-read",yY="lock:master:grant-read",mY="lock:worker:request-write",vY="lock:worker:release-write",bY="lock:master:grant-write",wY={},EY=e=>{e.addEventListener("message",(t=>{EY.dispatchEvent("message",e,t)})),null!=e.port&&e.port.addEventListener("message",(t=>{EY.dispatchEvent("message",e,t)}))};EY.addEventListener=(e,t)=>{null==wY[e]&&(wY[e]=[]),wY[e].push(t)},EY.removeEventListener=(e,t)=>{null!=wY[e]&&(wY[e]=wY[e].filter((e=>e===t)))},EY.dispatchEvent=function(e,t,n){null!=wY[e]&&wY[e].forEach((e=>e(t,n)))};const AY=EY,SY=(e,t,n,r,i)=>(o,s)=>{if(s.data.type!==n)return;const a={type:s.data.type,name:s.data.name,identifier:s.data.identifier};e.dispatchEvent(new MessageEvent(t,{data:{name:a.name,handler:async()=>(o.postMessage({type:i,name:a.name,identifier:a.identifier}),await new Promise((e=>{const t=n=>{if(null==n||null==n.data)return;const i=n.data.type,s=(n.data.name,n.data.identifier);i===r&&s===a.identifier&&(o.removeEventListener("message",t),e())};o.addEventListener("message",t)})))}}))},_Y=(e,t,n,r)=>async()=>{const i=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;return crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+((t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_")),"")}();return globalThis.postMessage({type:t,identifier:i,name:e}),await new Promise((t=>{const o=s=>{if(null==s||null==s.data)return;const a=s.data.type,c=s.data.identifier;a===n&&c===i&&(globalThis.removeEventListener("message",o),t((()=>{globalThis.postMessage({type:r,identifier:i,name:e})})))};globalThis.addEventListener("message",o)}))},IY={singleProcess:!1},CY={};let TY;async function kY(e,t){let n;const r=new Promise((e=>{n=e}));return e.add((async()=>await hL((async()=>await new Promise((e=>{n((()=>{e()}))})))(),{milliseconds:t.timeout}))),await r}const RY={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function xY(e){const t=Object.assign({},RY,e);return null==TY&&(TY=(e=>{if(e=Object.assign({},IY,e),Boolean(globalThis.document)||e.singleProcess){const e=new EventTarget;return AY.addEventListener("message",SY(e,"requestReadLock",pY,gY,yY)),AY.addEventListener("message",SY(e,"requestWriteLock",mY,vY,bY)),e}return{isWorker:!0,readLock:e=>_Y(e,pY,yY,gY),writeLock:e=>_Y(e,mY,bY,vY)}})(t),!0!==TY.isWorker&&(TY.addEventListener("requestReadLock",(e=>{null!=CY[e.data.name]&&CY[e.data.name].readLock().then((async t=>await e.data.handler().finally((()=>t()))))})),TY.addEventListener("requestWriteLock",(async e=>{null!=CY[e.data.name]&&CY[e.data.name].writeLock().then((async t=>await e.data.handler().finally((()=>t()))))})))),null==CY[t.name]&&(CY[t.name]=((e,t)=>{if(!0===TY.isWorker)return{readLock:TY.readLock(e,t),writeLock:TY.writeLock(e,t)};const n=new Fm.Z({concurrency:1});let r;return{async readLock(){if(null!=r)return await kY(r,t);r=new Fm.Z({concurrency:t.concurrency,autoStart:!1});const e=r,i=kY(r,t);return n.add((async()=>(e.start(),await e.onIdle().then((()=>{r===e&&(r=null)}))))),await i},writeLock:async()=>(r=null,await kY(n,t))}})(t.name,t)),CY[t.name]}class PY{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};(0,Yo.Z)(this,"lock",void 0),(0,Yo.Z)(this,"child",void 0),(0,Yo.Z)(this,"pins",void 0),(0,Yo.Z)(this,"started",void 0),this.child=e,this.pins=t,this.lock=xY({singleProcess:n.holdGcLock}),this.started=!1}isStarted(){return this.started}async start(){await VH(this.child),this.started=!0}async stop(){await HH(this.child),this.started=!1}unwrap(){return this.child}async put(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=await this.lock.readLock();try{return await this.child.put(e,t,n)}finally{r()}}putMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){const r=await t.lock.readLock();try{yield*t.child.putMany(e,n)}finally{r()}}()}catch(n){return Promise.reject(n)}}async get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await this.lock.readLock();try{return await this.child.get(e,t)}finally{n()}}getMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){const r=await t.lock.readLock();try{yield*t.child.getMany(e,n)}finally{r()}}()}catch(n){return Promise.reject(n)}}async delete(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await this.lock.writeLock();try{if(await this.pins.isPinned(e))throw new Error("CID was pinned");await this.child.delete(e,t)}finally{n()}}deleteMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){const r=await t.lock.writeLock();try{const r=t;yield*t.child.deleteMany(async function*(){for await(const t of e){if(await r.pins.isPinned(t))throw new Error("CID was pinned");yield t}}(),n)}finally{r()}}()}catch(n){return Promise.reject(n)}}async has(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await this.lock.readLock();try{return await this.child.has(e,t)}finally{n()}}getAll(){try{var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return async function*(){const n=await e.lock.readLock();try{yield*e.child.getAll(t)}finally{n()}}()}catch(t){return Promise.reject(t)}}}const DY=new BH("/version");const OY=oH,NY={code:0,name:"identity",encode:OY,digest:e=>pq(0,OY(e))};const BY=xH("helia:networked-storage");function LY(e){return"function"===typeof e.retrieve}function MY(e){return"function"===typeof e.announce}class UY{constructor(e,t){var n,r,i;(0,Yo.Z)(this,"child",void 0),(0,Yo.Z)(this,"blockRetrievers",void 0),(0,Yo.Z)(this,"blockAnnouncers",void 0),(0,Yo.Z)(this,"hashers",void 0),(0,Yo.Z)(this,"started",void 0),this.child=e,this.blockRetrievers=(null!==(n=t.blockBrokers)&&void 0!==n?n:[]).filter(LY),this.blockAnnouncers=(null!==(r=t.blockBrokers)&&void 0!==r?r:[]).filter(MY),this.hashers=null!==(i=t.hashers)&&void 0!==i?i:[],this.started=!1}isStarted(){return this.started}async start(){await VH(this.child,...new Set([...this.blockRetrievers,...this.blockAnnouncers])),this.started=!0}async stop(){await HH(this.child,...new Set([...this.blockRetrievers,...this.blockAnnouncers])),this.started=!1}unwrap(){return this.child}async put(e,t){var n,r;let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};var o;return await this.child.has(e)?(null===(o=i.onProgress)||void 0===o||o.call(i,new qH("blocks:put:duplicate",e)),e):(null===(n=i.onProgress)||void 0===n||n.call(i,new qH("blocks:put:providers:notify",e)),this.blockAnnouncers.forEach((n=>{n.announce(e,t,i)})),null===(r=i.onProgress)||void 0===r||r.call(i,new qH("blocks:put:blockstore:put",e)),this.child.put(e,t,i))}putMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(r){const i=FH(e,(async e=>{let{cid:r}=e;const i=await t.child.has(r);var o;i&&(null===(o=n.onProgress)||void 0===o||o.call(n,new qH("blocks:put-many:duplicate",r)));return!i})),o=zd(i,(e=>{var r;let{cid:i,block:o}=e;null===(r=n.onProgress)||void 0===r||r.call(n,new qH("blocks:put-many:providers:notify",i)),t.blockAnnouncers.forEach((e=>{e.announce(i,o,n)}))}));null===(r=n.onProgress)||void 0===r||r.call(n,new qH("blocks:put-many:blockstore:put-many")),yield*t.child.putMany(o,n)}()}catch(n){return Promise.reject(n)}}async get(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!0!==n.offline&&!await this.child.has(e)){var r,i,o;null===(r=n.onProgress)||void 0===r||r.call(n,new qH("blocks:get:providers:get",e));const t=await KY(e,this.blockRetrievers,this.hashers,n);return null===(i=n.onProgress)||void 0===i||i.call(n,new qH("blocks:get:blockstore:put",e)),await this.child.put(e,t,n),null===(o=n.onProgress)||void 0===o||o.call(n,new qH("blocks:get:providers:notify",e)),this.blockAnnouncers.forEach((r=>{r.announce(e,t,n)})),t}return null===(t=n.onProgress)||void 0===t||t.call(n,new qH("blocks:get:blockstore:get",e)),this.child.get(e,n)}getMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(r){null===(r=n.onProgress)||void 0===r||r.call(n,new qH("blocks:get-many:blockstore:get-many")),yield*t.child.getMany(zd(e,(async e=>{if(!0!==n.offline&&!await t.child.has(e)){var r,i,o;null===(r=n.onProgress)||void 0===r||r.call(n,new qH("blocks:get-many:providers:get",e));const s=await KY(e,t.blockRetrievers,t.hashers,n);null===(i=n.onProgress)||void 0===i||i.call(n,new qH("blocks:get-many:blockstore:put",e)),await t.child.put(e,s,n),null===(o=n.onProgress)||void 0===o||o.call(n,new qH("blocks:get-many:providers:notify",e)),t.blockAnnouncers.forEach((t=>{t.announce(e,s,n)}))}})))}()}catch(n){return Promise.reject(n)}}async delete(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};null===(t=n.onProgress)||void 0===t||t.call(n,new qH("blocks:delete:blockstore:delete",e)),await this.child.delete(e,n)}deleteMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(r){null===(r=n.onProgress)||void 0===r||r.call(n,new qH("blocks:delete-many:blockstore:delete-many")),yield*t.child.deleteMany(async function*(){for await(const t of e)yield t}(),n)}()}catch(n){return Promise.reject(n)}}async has(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.child.has(e,t)}getAll(){try{var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return async function*(n){null===(n=t.onProgress)||void 0===n||n.call(t,new qH("blocks:get-all:blockstore:get-many")),yield*e.child.getAll(t)}()}catch(t){return Promise.reject(t)}}}const FY=(e,t)=>{const n=t.find((t=>t.code===e.multihash.code));if(null==n)throw new Pq("No hasher configured for multihash code 0x".concat(e.multihash.code.toString(16),", please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv"),"ERR_UNKNOWN_HASH_ALG");return async t=>{const r=await n.digest(t);if(!(0,Ms.f)(r.digest,e.multihash.digest))throw new Pq("Hash of downloaded block did not match multihash from passed CID","ERR_HASH_MISMATCH")}};async function KY(e,t,n,r){const i=FY(e,n),o=GH([(new AbortController).signal,r.signal]);try{return await Promise.any(t.map((async t=>{try{let n=!1;const s=await t.retrieve(e,{...r,signal:o,validateFn:async e=>{await i(e),n=!0}});return n||await i(s),s}catch(n){throw BY.error("could not retrieve verified block for %c",e,n),n}})))}finally{o.clear()}}const jY=xH("helia");class ZY{constructor(e){var t,n,r;(0,Yo.Z)(this,"libp2p",void 0),(0,Yo.Z)(this,"blockstore",void 0),(0,Yo.Z)(this,"datastore",void 0),(0,Yo.Z)(this,"pins",void 0);const i=function(){return[Uq,Fq,NY,...arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]]}(e.hashers),o={blockstore:e.blockstore,datastore:e.datastore,libp2p:e.libp2p,hashers:i},s=null!==(t=null===(n=e.blockBrokers)||void 0===n?void 0:n.map((e=>e(o))))&&void 0!==t?t:[XG()(o),lW()()],a=new UY(e.blockstore,{blockBrokers:s,hashers:i});this.pins=new hY(e.datastore,a,null!==(r=e.dagWalkers)&&void 0!==r?r:[]),this.libp2p=e.libp2p,this.blockstore=new PY(a,this.pins,{holdGcLock:e.holdGcLock}),this.datastore=e.datastore}async start(){await async function(e){if(!await e.has(DY))return void await e.put(DY,(0,mu.m)("".concat(1)));const t=await e.get(DY),n=(0,Su.B)(t);if(1!==parseInt(n,10))throw new Error("Unknown datastore version, a datastore migration may be required")}(this.datastore),await VH(this.blockstore),await this.libp2p.start()}async stop(){await this.libp2p.stop(),await HH(this.blockstore)}async gc(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=await this.blockstore.lock.writeLock();try{const t=this,n=this.blockstore.unwrap();jY("gc start"),await MH(n.deleteMany(async function*(){for await(const{cid:s}of n.getAll())try{var r;if(await t.pins.isPinned(s,e))continue;yield s,null===(r=e.onProgress)||void 0===r||r.call(e,new qH("helia:gc:deleted",s))}catch(o){var i;jY.error("Error during gc",o),null===(i=e.onProgress)||void 0===i||i.call(e,new qH("helia:gc:error",o))}}()))}finally{t()}jY("gc finished")}}const zY=32,VY=64,HY=32;function qY(e,t){const n=new Uint8Array(VY);for(let r=0;r<HY;r++)n[r]=e[r],n[HY+r]=t[r];return n}const GY={get(){const e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:globalThis).crypto;if(null==e||null==e.subtle)throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"),{code:"ERR_MISSING_WEB_CRYPTO"});return e}},WY={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};async function QY(e,t){const n=function(e){var t,n,r,i,o,s;const a=null!==(t=null===e||void 0===e?void 0:e.algorithm)&&void 0!==t?t:"AES-GCM";let c=null!==(n=null===e||void 0===e?void 0:e.keyLength)&&void 0!==n?n:16;const l=null!==(r=null===e||void 0===e?void 0:e.nonceLength)&&void 0!==r?r:12,u=null!==(i=null===e||void 0===e?void 0:e.digest)&&void 0!==i?i:"SHA-256",h=null!==(o=null===e||void 0===e?void 0:e.saltLength)&&void 0!==o?o:16,d=null!==(s=null===e||void 0===e?void 0:e.iterations)&&void 0!==s?s:32767,f=GY.get();return c*=8,{encrypt:async function(e,t){const n=f.getRandomValues(new Uint8Array(h)),r=f.getRandomValues(new Uint8Array(l)),i={name:a,iv:r};let o;if("string"===typeof t&&(t=(0,mu.m)(t)),0===t.length){o=await f.subtle.importKey("jwk",WY,{name:"AES-GCM"},!0,["encrypt"]);try{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);o=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["encrypt"])}catch{o=await f.subtle.importKey("jwk",WY,{name:"AES-GCM"},!0,["encrypt"])}}else{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);o=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["encrypt"])}const s=await f.subtle.encrypt(i,o,e);return(0,Ls.z)([n,i.iv,new Uint8Array(s)])},decrypt:async function(e,t){const n=e.subarray(0,h),r=e.subarray(h,h+l),i=e.subarray(h+l),o={name:a,iv:r};let s;if("string"===typeof t&&(t=(0,mu.m)(t)),0===t.length)try{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);s=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["decrypt"])}catch{s=await f.subtle.importKey("jwk",WY,{name:"AES-GCM"},!0,["decrypt"])}else{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);s=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["decrypt"])}const p=await f.subtle.decrypt(o,s,i);return new Uint8Array(p)}}}(),r=await n.encrypt(e,t);return IH.encode(r)}var YY,JY,XY,$Y;!function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.Secp256k1="Secp256k1"}(YY||(YY={})),function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.Secp256k1=2]="Secp256k1"}(JY||(JY={})),function(e){e.codec=()=>bs(JY)}(YY||(YY={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),YY.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=YY.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(XY||(XY={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),YY.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=YY.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}($Y||($Y={}));class eJ{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=sJ(e,zY)}async verify(e,t){return async function(e,t,n){return Gl.verify(t,n,e)}(this._key,t,e)}marshal(){return this._key}get bytes(){return XY.encode({Type:YY.Ed25519,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await Uq.digest(this.bytes);return e}}class tJ{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=sJ(e,VY),this._publicKey=sJ(t,zY)}async sign(e){return async function(e,t){const n=e.subarray(0,HY);return Gl.sign(t,n)}(this._key,e)}get public(){return new eJ(this._publicKey)}marshal(){return this._key}get bytes(){return $Y.encode({Type:YY.Ed25519,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await Uq.digest(this.bytes);return e}async id(){const e=NY.digest(this.public.bytes);return SH.encode(e.bytes).substring(1)}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return QY(this.bytes,e);throw new Pq("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function nJ(e){if(e.length>VY){const t=(e=sJ(e,VY+zY)).subarray(0,VY),n=e.subarray(VY,e.length);return new tJ(t,n)}const t=(e=sJ(e,VY)).subarray(0,VY),n=e.subarray(zY);return new tJ(t,n)}function rJ(e){return e=sJ(e,zY),new eJ(e)}async function iJ(){const{privateKey:e,publicKey:t}=await async function(){const e=Gl.utils.randomPrivateKey(),t=Gl.getPublicKey(e);return{privateKey:qY(e,t),publicKey:t}}();return new tJ(e,t)}async function oJ(e){const{privateKey:t,publicKey:n}=await async function(e){if(e.length!==HY)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,n=Gl.getPublicKey(t);return{privateKey:qY(t,n),publicKey:n}}(e);return new tJ(t,n)}function sJ(e,t){var n;if((e=Uint8Array.from(null!==(n=e)&&void 0!==n?n:[])).length!==t)throw new Pq("Key must be a Uint8Array of length ".concat(t,", got ").concat(e.length),"ERR_INVALID_KEY_TYPE");return e}function aJ(e,t){let n=Uint8Array.from(e.abs().toByteArray());if(n=0===n[0]?n.subarray(1):n,null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return(0,Su.B)(n,"base64url")}function cJ(e){const t=function(e,t){let n=(0,mu.m)(e,"base64urlpad");if(null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return n}(e);return new(yu().jsbn.BigInteger)((0,Su.B)(t,"base16"),16)}const lJ={"P-256":256,"P-384":384,"P-521":521};Object.keys(lJ).join(" / ");function uJ(e){if(isNaN(e)||e<=0)throw new Pq("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return Ic(e)}function hJ(e,t){return t.map((t=>cJ(e[t])))}async function dJ(e){const t=[await GY.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await pJ(e)],n=await fJ({privateKey:t[0],publicKey:t[1]});return{privateKey:n[0],publicKey:n[1]}}async function fJ(e){if(null==e.privateKey||null==e.publicKey)throw new Pq("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([GY.get().subtle.exportKey("jwk",e.privateKey),GY.get().subtle.exportKey("jwk",e.publicKey)])}async function pJ(e){return GY.get().subtle.importKey("jwk",{kty:e.kty,n:e.n,e:e.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function gJ(e,t,n,r){const i=t?function(e){return yu().pki.setRsaPublicKey(...hJ(e,["n","e"]))}(e):function(e){return yu().pki.setRsaPrivateKey(...hJ(e,["n","e","d","p","q","dp","dq","qi"]))}(e),o=r((0,Su.B)(Uint8Array.from(n),"ascii"),i);return(0,mu.m)(o,"ascii")}function yJ(e){if("RSA"!==e.kty)throw new Pq("invalid key type","ERR_INVALID_KEY_TYPE");if(null==e.n)throw new Pq("invalid key modulus","ERR_INVALID_KEY_MODULUS");return 8*(0,mu.m)(e.n,"base64url").length}const mJ=8192;class vJ{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=e}async verify(e,t){return async function(e,t,n){const r=await GY.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return GY.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,t,n)}(this._key,t,e)}marshal(){return function(e){if(null==e.n||null==e.e)throw new Pq("JWK was missing components","ERR_INVALID_PARAMETERS");const t=yu().pki.publicKeyToAsn1({n:cJ(e.n),e:cJ(e.e)});return(0,mu.m)(yu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return XY.encode({Type:YY.RSA,Data:this.marshal()}).subarray()}encrypt(e){return gJ(this._key,!0,e,((e,t)=>t.encrypt(e)))}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await Uq.digest(this.bytes);return e}}class bJ{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=t}genSecret(){return uJ(16)}async sign(e){return async function(e,t){const n=await GY.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await GY.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,Uint8Array.from(t));return new Uint8Array(r,0,r.byteLength)}(this._key,e)}get public(){if(null==this._publicKey)throw new Pq("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new vJ(this._publicKey)}decrypt(e){return gJ(this._key,!1,e,((e,t)=>t.decrypt(e)))}marshal(){return function(e){if(null==e.n||null==e.e||null==e.d||null==e.p||null==e.q||null==e.dp||null==e.dq||null==e.qi)throw new Pq("JWK was missing components","ERR_INVALID_PARAMETERS");const t=yu().pki.privateKeyToAsn1({n:cJ(e.n),e:cJ(e.e),d:cJ(e.d),p:cJ(e.p),q:cJ(e.q),dP:cJ(e.dp),dQ:cJ(e.dq),qInv:cJ(e.qi)});return(0,mu.m)(yu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return $Y.encode({Type:YY.RSA,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await Uq.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Su.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"pkcs-8";if("pkcs-8"===t){const t=new(yu().util.ByteBuffer)(this.marshal()),n=yu().asn1.fromDer(t),r=yu().pki.privateKeyFromAsn1(n),i={algorithm:"aes256",count:1e4,saltSize:16,prfAlgorithm:"sha512"};return yu().pki.encryptRsaPrivateKey(r,e,i)}if("libp2p-key"===t)return QY(this.bytes,e);throw new Pq("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}async function wJ(e){const t=function(e){const t=yu().asn1.fromDer((0,Su.B)(e,"ascii")),n=yu().pki.privateKeyFromAsn1(t);return{kty:"RSA",n:aJ(n.n),e:aJ(n.e),d:aJ(n.d),p:aJ(n.p),q:aJ(n.q),dp:aJ(n.dP),dq:aJ(n.dQ),qi:aJ(n.qInv),alg:"RS256"}}(e);if(yJ(t)>mJ)throw new Pq("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const n=await dJ(t);return new bJ(n.privateKey,n.publicKey)}function EJ(e){const t=function(e){const t=yu().asn1.fromDer((0,Su.B)(e,"ascii")),n=yu().pki.publicKeyFromAsn1(t);return{kty:"RSA",n:aJ(n.n),e:aJ(n.e)}}(e);if(yJ(t)>mJ)throw new Pq("key size is too large","ERR_KEY_SIZE_TOO_LARGE");return new vJ(t)}async function AJ(e){if(yJ(e)>mJ)throw new Pq("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await dJ(e);return new bJ(t.privateKey,t.publicKey)}async function SJ(e){if(e>mJ)throw new Pq("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await async function(e){const t=await GY.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await fJ(t);return{privateKey:n[0],publicKey:n[1]}}(e);return new bJ(t.privateKey,t.publicKey)}function _J(e){try{Ah.ProjectivePoint.fromHex(e)}catch(t){throw new Pq(String(t),"ERR_INVALID_PUBLIC_KEY")}}class IJ{constructor(e){(0,Yo.Z)(this,"_key",void 0),_J(e),this._key=e}async verify(e,t){return async function(e,t,n){try{const{digest:r}=await Uq.digest(n);return Ah.verify(t,r,e)}catch(r){throw new Pq(String(r),"ERR_INVALID_INPUT")}}(this._key,t,e)}marshal(){return e=this._key,Ah.ProjectivePoint.fromHex(e).toRawBytes(!0);var e}get bytes(){return XY.encode({Type:YY.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await Uq.digest(this.bytes);return e}}class CJ{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=null!==t&&void 0!==t?t:function(e){try{return Ah.getPublicKey(e,!0)}catch(t){throw new Pq(String(t),"ERR_INVALID_PRIVATE_KEY")}}(e),function(e){try{Ah.getPublicKey(e,!0)}catch(t){throw new Pq(String(t),"ERR_INVALID_PRIVATE_KEY")}}(this._key),_J(this._publicKey)}async sign(e){return async function(e,t){const{digest:n}=await Uq.digest(t);try{return Ah.sign(n,e).toDERRawBytes()}catch(r){throw new Pq(String(r),"ERR_INVALID_INPUT")}}(this._key,e)}get public(){return new IJ(this._publicKey)}marshal(){return this._key}get bytes(){return $Y.encode({Type:YY.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await Uq.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Su.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return QY(this.bytes,e);throw new Pq("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function TJ(e){return new CJ(e)}function kJ(e){return new IJ(e)}async function RJ(){const e=Ah.utils.randomPrivateKey();return new CJ(e)}const xJ={rsa:Yt,ed25519:Qt,secp256k1:Jt};function PJ(e){const t=Object.keys(xJ).join(" / ");return new Pq("invalid or unsupported key type ".concat(e,". Must be ").concat(t),"ERR_UNSUPPORTED_KEY_TYPE")}function DJ(e){var t,n;const r=XY.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case YY.RSA:return xJ.rsa.unmarshalRsaPublicKey(i);case YY.Ed25519:return xJ.ed25519.unmarshalEd25519PublicKey(i);case YY.Secp256k1:return xJ.secp256k1.unmarshalSecp256k1PublicKey(i);default:throw PJ(null!==(n=r.Type)&&void 0!==n?n:"unknown")}}async function OJ(e){var t,n;const r=$Y.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case YY.RSA:return xJ.rsa.unmarshalRsaPrivateKey(i);case YY.Ed25519:return xJ.ed25519.unmarshalEd25519PrivateKey(i);case YY.Secp256k1:return xJ.secp256k1.unmarshalSecp256k1PrivateKey(i);default:throw PJ(null!==(n=r.Type)&&void 0!==n?n:"RSA")}}const NJ=Symbol.for("@libp2p/content-routing");var BJ,LJ=new WeakMap;class MJ extends EventTarget{constructor(){super(...arguments),(0,_x.Z)(this,LJ,{writable:!0,value:new Map})}listenerCount(e){const t=(0,Ix.Z)(this,LJ).get(e);return null==t?0:t.length}addEventListener(e,t,n){var r;super.addEventListener(e,t,n);let i=(0,Ix.Z)(this,LJ).get(e);null==i&&(i=[],(0,Ix.Z)(this,LJ).set(e,i)),i.push({callback:t,once:null!==(r=!0!==n&&!1!==n&&(null===n||void 0===n?void 0:n.once))&&void 0!==r&&r})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),null!==t&&void 0!==t?t:null,n);let r=(0,Ix.Z)(this,LJ).get(e);null!=r&&(r=r.filter((e=>{let{callback:n}=e;return n!==t})),(0,Ix.Z)(this,LJ).set(e,r))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=(0,Ix.Z)(this,LJ).get(e.type);return null==n||(n=n.filter((e=>{let{once:t}=e;return!t})),(0,Ix.Z)(this,LJ).set(e.type,n)),t}safeDispatchEvent(e,t){return this.dispatchEvent(new FJ(e,t))}}class UJ extends Event{constructor(e,t){super(e,t),(0,Yo.Z)(this,"detail",void 0),this.detail=null===t||void 0===t?void 0:t.detail}}const FJ=null!==(BJ=globalThis.CustomEvent)&&void 0!==BJ?BJ:UJ,KJ=function(e){try{for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r]}catch{}},jJ=Symbol.for("@libp2p/peer-discovery"),ZJ=Symbol.for("@libp2p/peer-routing");class zJ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"The operation was aborted"),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"type",void 0),this.code=zJ.code,this.type=zJ.type}}(0,Yo.Z)(zJ,"code","ABORT_ERR"),(0,Yo.Z)(zJ,"type","aborted");class VJ extends Error{constructor(e,t,n){var r;super(e),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"props",void 0),this.code=t,this.name=null!==(r=null===n||void 0===n?void 0:n.name)&&void 0!==r?r:"CodeError",this.props=null!==n&&void 0!==n?n:{}}}class HJ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected Peer"),(0,Yo.Z)(this,"code",void 0),this.code=HJ.code}}(0,Yo.Z)(HJ,"code","ERR_UNEXPECTED_PEER");class qJ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto exchange"),(0,Yo.Z)(this,"code",void 0),this.code=qJ.code}}(0,Yo.Z)(qJ,"code","ERR_INVALID_CRYPTO_EXCHANGE");class GJ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto transmission"),(0,Yo.Z)(this,"code",void 0),this.code=GJ.code}}(0,Yo.Z)(GJ,"code","ERR_INVALID_CRYPTO_TRANSMISSION");n(18605);const WJ={get(){const e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:globalThis).crypto;if(null==e||null==e.subtle)throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"),{code:"ERR_MISSING_WEB_CRYPTO"});return e}};var QJ=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=h,t++}if(" "!==e[t]){for(var f=o-i;f!==o&&0===s[f];)f++;for(var p=new Uint8Array(r+(o-f)),g=r;f!==o;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=0,o=t.length;i!==o&&0===t[i];)i++,n++;for(var s=(o-i)*u+1>>>0,l=new Uint8Array(s);i!==o;){for(var h=t[i],d=0,f=s-1;(0!==h||d<r)&&-1!==f;f--,d++)h+=256*l[f]>>>0,l[f]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");r=d,i++}for(var p=s-r;p!==s&&0===l[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:h,decode:function(e){var n=h(e);if(n)return n;throw new Error("Non-".concat(t," character"))}}};const YJ=QJ,JJ=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")});class XJ{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return"".concat(this.prefix).concat(this.baseEncode(e));throw Error("Unknown type, must be binary type")}}class $J{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"===typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error("Unable to decode multibase string ".concat(JSON.stringify(e),", ").concat(this.name," decoder only supports inputs prefixed with ").concat(this.prefix));return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return tX(this,e)}}class eX{constructor(e){this.decoders=e}or(e){return tX(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e),", only inputs prefixed with ").concat(Object.keys(this.decoders)," are supported"))}}const tX=(e,t)=>new eX({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class nX{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new XJ(e,t,n),this.decoder=new $J(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const rX=e=>{let{name:t,prefix:n,encode:r,decode:i}=e;return new nX(t,n,r,i)},iX=e=>{let{prefix:t,name:n,alphabet:r}=e;const{encode:i,decode:o}=YJ(r,n);return rX({prefix:t,name:n,encode:i,decode:e=>JJ(o(e))})},oX=e=>{let{name:t,prefix:n,bitsPerChar:r,alphabet:i}=e;return rX({prefix:n,name:t,encode:e=>((e,t,n)=>{const r="="===t[t.length-1],i=(1<<n)-1;let o="",s=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],s+=8;s>n;)s-=n,o+=t[i&a>>s];if(s&&(o+=t[i&a<<n-s]),r)for(;o.length*n&7;)o+="=";return o})(e,i,r),decode:e=>((e,t,n,r)=>{const i={};for(let u=0;u<t.length;++u)i[t[u]]=u;let o=e.length;for(;"="===e[o-1];)--o;const s=new Uint8Array(o*n/8|0);let a=0,c=0,l=0;for(let u=0;u<o;++u){const t=i[e[u]];if(void 0===t)throw new SyntaxError("Non-".concat(r," character"));c=c<<n|t,a+=n,a>=8&&(a-=8,s[l++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,i,r,t)})},sX=iX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),aX=iX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var cX=function e(t,n,r){n=n||[];var i=r=r||0;for(;t>=hX;)n[r++]=255&t|lX,t/=128;for(;t&uX;)n[r++]=255&t|lX,t>>>=7;return n[r]=0|t,e.bytes=r-i+1,n},lX=128,uX=-128,hX=Math.pow(2,31);var dX=function e(t,n){var r,i=0,o=0,s=n=n||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],i+=o<28?(r&pX)<<o:(r&pX)*Math.pow(2,o),o+=7}while(r>=fX);return e.bytes=s-n,i},fX=128,pX=127;var gX=Math.pow(2,7),yX=Math.pow(2,14),mX=Math.pow(2,21),vX=Math.pow(2,28),bX=Math.pow(2,35),wX=Math.pow(2,42),EX=Math.pow(2,49),AX=Math.pow(2,56),SX=Math.pow(2,63);const _X={encode:cX,decode:dX,encodingLength:function(e){return e<gX?1:e<yX?2:e<mX?3:e<vX?4:e<bX?5:e<wX?6:e<EX?7:e<AX?8:e<SX?9:10}},IX=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return[_X.decode(e,t),_X.decode.bytes]},CX=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return _X.encode(e,t,n),t},TX=e=>_X.encodingLength(e),kX=(e,t)=>{const n=t.byteLength,r=TX(e),i=r+TX(n),o=new Uint8Array(i+n);return CX(e,o,0),CX(n,o,r),o.set(t,i),new xX(e,n,t,o)},RX=e=>{const t=JJ(e),[n,r]=IX(t),[i,o]=IX(t.subarray(r)),s=t.subarray(r+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new xX(n,i,s,t)};class xX{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const PX=JJ,DX={code:0,name:"identity",encode:PX,digest:e=>kX(0,PX(e))},OX=e=>{let{name:t,code:n,encode:r}=e;return new NX(t,n,r)};class NX{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?kX(this.code,t):t.then((e=>kX(this.code,e)))}throw Error("Unknown type, must be binary type")}}const BX=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),LX=OX({name:"sha2-256",code:18,encode:BX("SHA-256")}),MX=OX({name:"sha2-512",code:19,encode:BX("SHA-512")}),UX=32,FX=64,KX=32;function jX(e,t){const n=new Uint8Array(FX);for(let r=0;r<KX;r++)n[r]=e[r],n[KX+r]=t[r];return n}const ZX=oX({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),zX=oX({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),VX=oX({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),HX=oX({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),qX={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};function GX(e){var t,n,r,i,o,s;const a=null!==(t=null===e||void 0===e?void 0:e.algorithm)&&void 0!==t?t:"AES-GCM";let c=null!==(n=null===e||void 0===e?void 0:e.keyLength)&&void 0!==n?n:16;const l=null!==(r=null===e||void 0===e?void 0:e.nonceLength)&&void 0!==r?r:12,u=null!==(i=null===e||void 0===e?void 0:e.digest)&&void 0!==i?i:"SHA-256",h=null!==(o=null===e||void 0===e?void 0:e.saltLength)&&void 0!==o?o:16,d=null!==(s=null===e||void 0===e?void 0:e.iterations)&&void 0!==s?s:32767,f=WJ.get();c*=8;return{encrypt:async function(e,t){const n=f.getRandomValues(new Uint8Array(h)),r=f.getRandomValues(new Uint8Array(l)),i={name:a,iv:r};let o;if("string"===typeof t&&(t=(0,mu.m)(t)),0===t.length){o=await f.subtle.importKey("jwk",qX,{name:"AES-GCM"},!0,["encrypt"]);try{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);o=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["encrypt"])}catch{o=await f.subtle.importKey("jwk",qX,{name:"AES-GCM"},!0,["encrypt"])}}else{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);o=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["encrypt"])}const s=await f.subtle.encrypt(i,o,e);return(0,Ls.z)([n,i.iv,new Uint8Array(s)])},decrypt:async function(e,t){const n=e.subarray(0,h),r=e.subarray(h,h+l),i=e.subarray(h+l),o={name:a,iv:r};let s;if("string"===typeof t&&(t=(0,mu.m)(t)),0===t.length)try{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);s=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["decrypt"])}catch{s=await f.subtle.importKey("jwk",qX,{name:"AES-GCM"},!0,["decrypt"])}else{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);s=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["decrypt"])}const p=await f.subtle.decrypt(o,s,i);return new Uint8Array(p)}}}async function WX(e,t){const n=GX(),r=await n.encrypt(e,t);return ZX.encode(r)}var QX,YX,JX,XX;!function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.Secp256k1="Secp256k1"}(QX||(QX={})),function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.Secp256k1=2]="Secp256k1"}(YX||(YX={})),function(e){e.codec=()=>bs(YX)}(QX||(QX={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),QX.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=QX.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(JX||(JX={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),QX.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=QX.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(XX||(XX={}));class $X{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=o$(e,UX)}async verify(e,t){return async function(e,t,n){return Gl.verify(t,n,e)}(this._key,t,e)}marshal(){return this._key}get bytes(){return JX.encode({Type:QX.Ed25519,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await LX.digest(this.bytes);return e}}class e${constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=o$(e,FX),this._publicKey=o$(t,UX)}async sign(e){return async function(e,t){const n=e.subarray(0,KX);return Gl.sign(t,n)}(this._key,e)}get public(){return new $X(this._publicKey)}marshal(){return this._key}get bytes(){return XX.encode({Type:QX.Ed25519,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await LX.digest(this.bytes);return e}async id(){const e=DX.digest(this.public.bytes);return sX.encode(e.bytes).substring(1)}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return WX(this.bytes,e);throw new VJ("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function t$(e){if(e.length>FX){const t=(e=o$(e,FX+UX)).subarray(0,FX),n=e.subarray(FX,e.length);return new e$(t,n)}const t=(e=o$(e,FX)).subarray(0,FX),n=e.subarray(UX);return new e$(t,n)}function n$(e){return e=o$(e,UX),new $X(e)}async function r$(){const{privateKey:e,publicKey:t}=await async function(){const e=Gl.utils.randomPrivateKey(),t=Gl.getPublicKey(e);return{privateKey:jX(e,t),publicKey:t}}();return new e$(e,t)}async function i$(e){const{privateKey:t,publicKey:n}=await async function(e){if(e.length!==KX)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,n=Gl.getPublicKey(t);return{privateKey:jX(t,n),publicKey:n}}(e);return new e$(t,n)}function o$(e,t){var n;if((e=Uint8Array.from(null!==(n=e)&&void 0!==n?n:[])).length!==t)throw new VJ("Key must be a Uint8Array of length ".concat(t,", got ").concat(e.length),"ERR_INVALID_KEY_TYPE");return e}function s$(e,t){let n=Uint8Array.from(e.abs().toByteArray());if(n=0===n[0]?n.subarray(1):n,null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return(0,Su.B)(n,"base64url")}function a$(e){const t=function(e,t){let n=(0,mu.m)(e,"base64urlpad");if(null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return n}(e);return new(yu().jsbn.BigInteger)((0,Su.B)(t,"base16"),16)}const c$={"P-256":256,"P-384":384,"P-521":521};Object.keys(c$).join(" / ");function l$(e){if(isNaN(e)||e<=0)throw new VJ("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return Ic(e)}function u$(e,t){return t.map((t=>a$(e[t])))}async function h$(e){const t=[await WJ.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await f$(e)],n=await d$({privateKey:t[0],publicKey:t[1]});return{privateKey:n[0],publicKey:n[1]}}async function d$(e){if(null==e.privateKey||null==e.publicKey)throw new VJ("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([WJ.get().subtle.exportKey("jwk",e.privateKey),WJ.get().subtle.exportKey("jwk",e.publicKey)])}async function f$(e){return WJ.get().subtle.importKey("jwk",{kty:e.kty,n:e.n,e:e.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function p$(e,t,n,r){const i=t?function(e){return yu().pki.setRsaPublicKey(...u$(e,["n","e"]))}(e):function(e){return yu().pki.setRsaPrivateKey(...u$(e,["n","e","d","p","q","dp","dq","qi"]))}(e),o=r((0,Su.B)(Uint8Array.from(n),"ascii"),i);return(0,mu.m)(o,"ascii")}function g$(e){if("RSA"!==e.kty)throw new VJ("invalid key type","ERR_INVALID_KEY_TYPE");if(null==e.n)throw new VJ("invalid key modulus","ERR_INVALID_KEY_MODULUS");return 8*(0,mu.m)(e.n,"base64url").length}const y$=8192;class m${constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=e}async verify(e,t){return async function(e,t,n){const r=await WJ.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return WJ.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,t,n)}(this._key,t,e)}marshal(){return function(e){if(null==e.n||null==e.e)throw new VJ("JWK was missing components","ERR_INVALID_PARAMETERS");const t=yu().pki.publicKeyToAsn1({n:a$(e.n),e:a$(e.e)});return(0,mu.m)(yu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return JX.encode({Type:QX.RSA,Data:this.marshal()}).subarray()}encrypt(e){return p$(this._key,!0,e,((e,t)=>t.encrypt(e)))}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await LX.digest(this.bytes);return e}}class v${constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=t}genSecret(){return l$(16)}async sign(e){return async function(e,t){const n=await WJ.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await WJ.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,Uint8Array.from(t));return new Uint8Array(r,0,r.byteLength)}(this._key,e)}get public(){if(null==this._publicKey)throw new VJ("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new m$(this._publicKey)}decrypt(e){return p$(this._key,!1,e,((e,t)=>t.decrypt(e)))}marshal(){return function(e){if(null==e.n||null==e.e||null==e.d||null==e.p||null==e.q||null==e.dp||null==e.dq||null==e.qi)throw new VJ("JWK was missing components","ERR_INVALID_PARAMETERS");const t=yu().pki.privateKeyToAsn1({n:a$(e.n),e:a$(e.e),d:a$(e.d),p:a$(e.p),q:a$(e.q),dP:a$(e.dp),dQ:a$(e.dq),qInv:a$(e.qi)});return(0,mu.m)(yu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return XX.encode({Type:QX.RSA,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await LX.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Su.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"pkcs-8";if("pkcs-8"===t){const t=new(yu().util.ByteBuffer)(this.marshal()),n=yu().asn1.fromDer(t),r=yu().pki.privateKeyFromAsn1(n),i={algorithm:"aes256",count:1e4,saltSize:16,prfAlgorithm:"sha512"};return yu().pki.encryptRsaPrivateKey(r,e,i)}if("libp2p-key"===t)return WX(this.bytes,e);throw new VJ("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}async function b$(e){const t=function(e){const t=yu().asn1.fromDer((0,Su.B)(e,"ascii")),n=yu().pki.privateKeyFromAsn1(t);return{kty:"RSA",n:s$(n.n),e:s$(n.e),d:s$(n.d),p:s$(n.p),q:s$(n.q),dp:s$(n.dP),dq:s$(n.dQ),qi:s$(n.qInv),alg:"RS256"}}(e);if(g$(t)>y$)throw new VJ("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const n=await h$(t);return new v$(n.privateKey,n.publicKey)}function w$(e){const t=function(e){const t=yu().asn1.fromDer((0,Su.B)(e,"ascii")),n=yu().pki.publicKeyFromAsn1(t);return{kty:"RSA",n:s$(n.n),e:s$(n.e)}}(e);if(g$(t)>y$)throw new VJ("key size is too large","ERR_KEY_SIZE_TOO_LARGE");return new m$(t)}async function E$(e){if(g$(e)>y$)throw new VJ("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await h$(e);return new v$(t.privateKey,t.publicKey)}async function A$(e){if(e>y$)throw new VJ("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await async function(e){const t=await WJ.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await d$(t);return{privateKey:n[0],publicKey:n[1]}}(e);return new v$(t.privateKey,t.publicKey)}function S$(e){try{Ah.ProjectivePoint.fromHex(e)}catch(t){throw new VJ(String(t),"ERR_INVALID_PUBLIC_KEY")}}class _${constructor(e){(0,Yo.Z)(this,"_key",void 0),S$(e),this._key=e}async verify(e,t){return async function(e,t,n){try{const{digest:r}=await LX.digest(n);return Ah.verify(t,r,e)}catch(r){throw new VJ(String(r),"ERR_INVALID_INPUT")}}(this._key,t,e)}marshal(){return e=this._key,Ah.ProjectivePoint.fromHex(e).toRawBytes(!0);var e}get bytes(){return JX.encode({Type:QX.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await LX.digest(this.bytes);return e}}class I${constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=null!==t&&void 0!==t?t:function(e){try{return Ah.getPublicKey(e,!0)}catch(t){throw new VJ(String(t),"ERR_INVALID_PRIVATE_KEY")}}(e),function(e){try{Ah.getPublicKey(e,!0)}catch(t){throw new VJ(String(t),"ERR_INVALID_PRIVATE_KEY")}}(this._key),S$(this._publicKey)}async sign(e){return async function(e,t){const{digest:n}=await LX.digest(t);try{return Ah.sign(n,e).toDERRawBytes()}catch(r){throw new VJ(String(r),"ERR_INVALID_INPUT")}}(this._key,e)}get public(){return new _$(this._publicKey)}marshal(){return this._key}get bytes(){return XX.encode({Type:QX.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await LX.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Su.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return WX(this.bytes,e);throw new VJ("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function C$(e){return new I$(e)}function T$(e){return new _$(e)}async function k$(){const e=Ah.utils.randomPrivateKey();return new I$(e)}const R$={rsa:rn,ed25519:nn,secp256k1:on};function x$(e){const t=Object.keys(R$).join(" / ");return new VJ("invalid or unsupported key type ".concat(e,". Must be ").concat(t),"ERR_UNSUPPORTED_KEY_TYPE")}function P$(e){if("rsa"===(e=e.toLowerCase())||"ed25519"===e||"secp256k1"===e)return R$[e];throw x$(e)}async function D$(e){var t,n;const r=XX.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case QX.RSA:return R$.rsa.unmarshalRsaPrivateKey(i);case QX.Ed25519:return R$.ed25519.unmarshalEd25519PrivateKey(i);case QX.Secp256k1:return R$.secp256k1.unmarshalSecp256k1PrivateKey(i);default:throw x$(null!==(n=r.Type)&&void 0!==n?n:"RSA")}}async function O$(e,t){try{const n=await async function(e,t){const n=ZX.decode(e);return GX().decrypt(n,t)}(e,t);return await D$(n)}catch(i){}const n=yu().pki.decryptRsaPrivateKey(e,t);if(null===n)throw new VJ("Cannot read the key, most likely the password is wrong or not a RSA key","ERR_CANNOT_DECRYPT_PEM");let r=yu().asn1.toDer(yu().pki.privateKeyToAsn1(n));return r=(0,mu.m)(r.getBytes(),"ascii"),R$.rsa.unmarshalRsaPrivateKey(r)}var N$=n(16019),B$=n.n(N$);const L$={sha1:"sha1","sha2-256":"sha256","sha2-512":"sha512"};function M$(e,t,n,r,i){if("sha1"!==i&&"sha2-256"!==i&&"sha2-512"!==i){const e=Object.keys(L$).join(" / ");throw new VJ("Hash '".concat(i,"' is unknown or not supported. Must be ").concat(e),"ERR_UNSUPPORTED_HASH_TYPE")}const o=L$[i],s=B$()(e,t,n,r,o);return Au().encode64(s,null)}const U$=oX({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),F$=oX({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),K$=oX({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),j$=oX({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Z$=oX({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),z$=oX({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),V$=oX({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),H$=oX({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),q$=oX({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});function G$(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return cf().enabled("".concat(e,":trace"))&&null!=cf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=cf()("".concat(e,":trace"))),Object.assign(cf()(e),{error:cf()("".concat(e,":error")),trace:t})}cf().formatters.b=e=>null==e?"undefined":sX.baseEncode(e),cf().formatters.t=e=>null==e?"undefined":U$.baseEncode(e),cf().formatters.m=e=>null==e?"undefined":ZX.baseEncode(e),cf().formatters.p=e=>null==e?"undefined":e.toString(),cf().formatters.c=e=>null==e?"undefined":e.toString(),cf().formatters.k=e=>null==e?"undefined":e.toString(),cf().formatters.a=e=>null==e?"undefined":e.toString();const W$=Symbol.for("@libp2p/peer-id");const Q$=iX({prefix:"9",name:"base10",alphabet:"0123456789"}),Y$=oX({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),J$=oX({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),X$=oX({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),$$=Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42"),e0=$$.reduce(((e,t,n)=>(e[n]=t,e)),[]),t0=$$.reduce(((e,t,n)=>(e[t.codePointAt(0)]=n,e)),[]);const n0=rX({prefix:"\ud83d\ude80",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=e0[t]),"")},decode:function(e){const t=[];for(const n of e){const e=t0[n.codePointAt(0)];if(void 0===e)throw new Error("Non-base256emoji character: ".concat(n));t.push(e)}return new Uint8Array(t)}}),r0=iX({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),i0=iX({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),o0=oX({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),s0=rX({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>(e=>(new TextEncoder).encode(e))(e)}),a0=new TextEncoder,c0=new TextDecoder,l0="json",u0=512,h0=e=>a0.encode(JSON.stringify(e)),d0=e=>JSON.parse(c0.decode(e)),f0="raw",p0=85,g0=e=>JJ(e),y0=e=>JJ(e),m0=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?A0(n,b0(e),t||sX.encoder):S0(n,b0(e),t||U$.encoder)},v0=new WeakMap,b0=e=>{const t=v0.get(e);if(null==t){const t=new Map;return v0.set(e,t),t}return t};class w0{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==_0)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==I0)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return w0.createV0(t)}default:throw Error("Can not convert CID version ".concat(this.version," to version 0. This is a bug please report"))}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=kX(e,t);return w0.createV1(this.code,n)}case 1:return this;default:throw Error("Can not convert CID version ".concat(this.version," to version 1. This is a bug please report"))}}equals(e){return w0.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&((e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}})(e.multihash,n.multihash)}toString(e){return m0(this,e)}toJSON(){return{"/":m0(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID(".concat(this.toString(),")")}static asCID(e){if(null==e)return null;const t=e;if(t instanceof w0)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new w0(e,n,r,i||C0(e,n,r.bytes))}if(!0===t[T0]){const{version:e,multihash:n,code:r}=t,i=RX(n);return w0.create(e,r,i)}return null}static create(e,t,n){if("number"!==typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==_0)throw new Error("Version 0 CID must use dag-pb (code: ".concat(_0,") block encoding"));return new w0(e,t,n,n.bytes);case 1:{const r=C0(e,t,n.bytes);return new w0(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return w0.create(0,_0,e)}static createV1(e,t){return w0.create(1,e,t)}static decode(e){const[t,n]=w0.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=w0.inspectBytes(e),n=t.size-t.multihashSize,r=JJ(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),o=new xX(t.multihashCode,t.digestSize,i,r);return[0===t.version?w0.createV0(o):w0.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=IX(e.subarray(t));return t+=r,n};let r=n(),i=_0;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version ".concat(r));const o=t,s=n(),a=n(),c=t+a;return{version:r,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[n,r]=E0(e,t),i=w0.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return b0(i).set(n,e),i}}const E0=(e,t)=>{switch(e[0]){case"Q":{const n=t||sX;return[sX.prefix,n.decode("".concat(sX.prefix).concat(e))]}case sX.prefix:{const n=t||sX;return[sX.prefix,n.decode(e)]}case U$.prefix:{const n=t||U$;return[U$.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},A0=(e,t,n)=>{const{prefix:r}=n;if(r!==sX.prefix)throw Error("Cannot string encode V0 in ".concat(n.name," encoding"));const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i},S0=(e,t,n)=>{const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i},_0=112,I0=18,C0=(e,t,n)=>{const r=TX(e),i=r+TX(t),o=new Uint8Array(i+n.byteLength);return CX(e,o,0),CX(t,o,r),o.set(n,i),o},T0=Symbol.for("@ipld/js-cid/CID"),k0={...fn,...ln,...dn,...an,...cn,...sn,...hn,...Xt,...tn,...un};let R0;const x0=Symbol.for("nodejs.util.inspect.custom"),P0=Object.values(k0).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)),k0.identity.decoder),D0=114,O0=36,N0=37;R0=Symbol.toStringTag;class B0{constructor(e){(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"multihash",void 0),(0,Yo.Z)(this,"privateKey",void 0),(0,Yo.Z)(this,"publicKey",void 0),(0,Yo.Z)(this,"string",void 0),(0,Yo.Z)(this,W$,!0),this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[R0](){return"PeerId(".concat(this.toString(),")")}toString(){return null==this.string&&(this.string=sX.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return w0.createV1(D0,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e instanceof Uint8Array)return(0,Ms.f)(this.multihash.bytes,e);if("string"===typeof e)return function(e,t){var n;if(t=null!==(n=t)&&void 0!==n?n:P0,"1"===e.charAt(0)||"Q"===e.charAt(0)){const t=RX(sX.decode("z".concat(e)));return e.startsWith("12D")?new M0({multihash:t}):e.startsWith("16U")?new U0({multihash:t}):new L0({multihash:t})}return function(e){try{const t=RX(e);if(t.code===DX.code){if(t.digest.length===O0)return new M0({multihash:t});if(t.digest.length===N0)return new U0({multihash:t})}if(t.code===LX.code)return new L0({multihash:t})}catch{return function(e){if(null==e||null==e.multihash||null==e.version||1===e.version&&e.code!==D0)throw new Error("Supplied PeerID CID is invalid");const t=e.multihash;if(t.code===LX.code)return new L0({multihash:e.multihash});if(t.code===DX.code){if(t.digest.length===O0)return new M0({multihash:e.multihash});if(t.digest.length===N0)return new U0({multihash:e.multihash})}throw new Error("Supplied PeerID CID is invalid")}(w0.decode(e))}throw new Error("Supplied PeerID CID is invalid")}(P0.decode(e))}(e).equals(this);if(null!=(null===e||void 0===e||null===(t=e.multihash)||void 0===t?void 0:t.bytes))return(0,Ms.f)(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[x0](){return"PeerId(".concat(this.toString(),")")}}class L0 extends B0{constructor(e){super({...e,type:"RSA"}),(0,Yo.Z)(this,"type","RSA"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.publicKey}}class M0 extends B0{constructor(e){super({...e,type:"Ed25519"}),(0,Yo.Z)(this,"type","Ed25519"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}class U0 extends B0{constructor(e){super({...e,type:"secp256k1"}),(0,Yo.Z)(this,"type","secp256k1"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}let F0;const K0="/",j0=(new TextEncoder).encode(K0),Z0=j0[0];F0=Symbol.toStringTag;class z0{constructor(e,t){if((0,Yo.Z)(this,"_buf",void 0),"string"===typeof e)this._buf=(0,mu.m)(e);else{if(!(e instanceof Uint8Array))throw new Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==Z0)throw new Error("Invalid key")}toString(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"utf8";return(0,Su.B)(this._buf,e)}uint8Array(){return this._buf}get[F0](){return"Key(".concat(this.toString(),")")}static withNamespaces(e){return new z0(e.join(K0))}static random(){return new z0(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;return crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+((t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_")),"")}().replace(/-/g,""))}static asKey(e){return e instanceof Uint8Array||"string"===typeof e?new z0(e):"function"===typeof e.uint8Array?new z0(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=j0),this._buf[0]!==Z0){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Z0,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Z0;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let r=0;r<t.length;r++){if(n.length<r+1)return!1;const e=t[r],i=n[r];if(e<i)return!0;if(e>i)return!1}return t.length<n.length}reverse(){return z0.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(K0).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new z0(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(K0)||(e+=K0),e+=this.type(),new z0(e)}parent(){const e=this.list();return 1===e.length?new z0(K0):new z0(e.slice(0,-1).join(K0))}child(e){return this.toString()===K0?e:e.toString()===K0?this:new z0(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return z0.withNamespaces([...this.namespaces(),...(r=t.map((e=>e.namespaces())),[].concat(...r))]);var r}}var V0,H0=n(94804),q0=n(6327),G0=n.n(q0);!function(e){e.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",e.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",e.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",e.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",e.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",e.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",e.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",e.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",e.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",e.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",e.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",e.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",e.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",e.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",e.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH"}(V0||(V0={}));const W0=G$("libp2p:keychain"),Q0="/info/",Y0=new WeakMap,J0=14,X0=16,$0=1e3,e1={dek:{keyLength:64,iterationCount:1e4,salt:"you should override this value with a crypto secure random number",hash:"sha2-512"}};function t1(e){return null!=e&&("string"===typeof e&&(e===G0()(e.trim())&&e.length>0))}async function n1(){const e=800*Math.random()+200;await new Promise((t=>setTimeout(t,e)))}function r1(e){return new z0("/pkcs8/"+e)}function i1(e){return new z0(Q0+e)}class o1{constructor(e,t){var n,r,i,o,s,a,c,l,u,h;if((0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"init",void 0),this.components=e,this.init=(0,H0.Z)(e1,t),null!=this.init.pass&&(null===(n=this.init.pass)||void 0===n?void 0:n.length)<20)throw new Error("pass must be least 20 characters");if(null!=(null===(r=this.init.dek)||void 0===r?void 0:r.keyLength)&&this.init.dek.keyLength<J0)throw new Error("dek.keyLength must be least ".concat(J0," bytes"));if(null!=(null===(i=this.init.dek)||void 0===i||null===(o=i.salt)||void 0===o?void 0:o.length)&&this.init.dek.salt.length<X0)throw new Error("dek.saltLength must be least ".concat(X0," bytes"));if(null!=(null===(s=this.init.dek)||void 0===s?void 0:s.iterationCount)&&this.init.dek.iterationCount<$0)throw new Error("dek.iterationCount must be least ".concat($0));const d=null!=this.init.pass&&null!=(null===(a=this.init.dek)||void 0===a?void 0:a.salt)?M$(this.init.pass,null===(c=this.init.dek)||void 0===c?void 0:c.salt,null===(l=this.init.dek)||void 0===l?void 0:l.iterationCount,null===(u=this.init.dek)||void 0===u?void 0:u.keyLength,null===(h=this.init.dek)||void 0===h?void 0:h.hash):"";Y0.set(this,{dek:d})}static generateOptions(){const e=Object.assign({},e1),t=3*Math.ceil(X0/3);return e.dek.salt=(0,Su.B)(l$(t),"base64"),e}static get options(){return e1}async createKey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2048;if(!t1(e)||"self"===e)throw await n1(),new VJ("Invalid key name",V0.ERR_INVALID_KEY_NAME);if("string"!==typeof t)throw await n1(),new VJ("Invalid key type",V0.ERR_INVALID_KEY_TYPE);const r=r1(e);if(await this.components.datastore.has(r))throw await n1(),new VJ("Key name already exists",V0.ERR_KEY_ALREADY_EXISTS);if("rsa"===t.toLowerCase())if(!Number.isSafeInteger(n)||n<2048)throw await n1(),new VJ("Invalid RSA key size",V0.ERR_INVALID_KEY_SIZE);let i;try{const o=await async function(e,t){return P$(e).generateKeyPair(null!==t&&void 0!==t?t:2048)}(t,n),s=await o.id(),a=Y0.get(this);if(null==a)throw new VJ("dek missing",V0.ERR_INVALID_PARAMETERS);const c=a.dek,l=await o.export(c);i={name:e,id:s};const u=this.components.datastore.batch();u.put(r,(0,mu.m)(l)),u.put(i1(e),(0,mu.m)(JSON.stringify(i))),await u.commit()}catch(o){throw await n1(),o}return i}async listKeys(){const e={prefix:Q0},t=[];for await(const n of this.components.datastore.query(e))t.push(JSON.parse((0,Su.B)(n.value)));return t}async findKeyById(e){try{const t=(await this.listKeys()).find((t=>t.id===e));if(null==t)throw new VJ("Key with id '".concat(e,"' does not exist."),V0.ERR_KEY_NOT_FOUND);return t}catch(t){throw await n1(),t}}async findKeyByName(e){if(!t1(e))throw await n1(),new VJ("Invalid key name '".concat(e,"'"),V0.ERR_INVALID_KEY_NAME);const t=i1(e);try{const e=await this.components.datastore.get(t);return JSON.parse((0,Su.B)(e))}catch(n){throw await n1(),W0.error(n),new VJ("Key '".concat(e,"' does not exist."),V0.ERR_KEY_NOT_FOUND)}}async removeKey(e){if(!t1(e)||"self"===e)throw await n1(),new VJ("Invalid key name '".concat(e,"'"),V0.ERR_INVALID_KEY_NAME);const t=r1(e),n=await this.findKeyByName(e),r=this.components.datastore.batch();return r.delete(t),r.delete(i1(e)),await r.commit(),n}async renameKey(e,t){if(!t1(e)||"self"===e)throw await n1(),new VJ("Invalid old key name '".concat(e,"'"),V0.ERR_OLD_KEY_NAME_INVALID);if(!t1(t)||"self"===t)throw await n1(),new VJ("Invalid new key name '".concat(t,"'"),V0.ERR_NEW_KEY_NAME_INVALID);const n=r1(e),r=r1(t),i=i1(e),o=i1(t);if(await this.components.datastore.has(r))throw await n1(),new VJ("Key '".concat(t,"' already exists"),V0.ERR_KEY_ALREADY_EXISTS);try{const e=await this.components.datastore.get(n),s=await this.components.datastore.get(i),a=JSON.parse((0,Su.B)(s));a.name=t;const c=this.components.datastore.batch();return c.put(r,e),c.put(o,(0,mu.m)(JSON.stringify(a))),c.delete(n),c.delete(i),await c.commit(),a}catch(s){throw await n1(),s}}async exportKey(e,t){if(!t1(e))throw await n1(),new VJ("Invalid key name '".concat(e,"'"),V0.ERR_INVALID_KEY_NAME);if(null==t)throw await n1(),new VJ("Password is required",V0.ERR_PASSWORD_REQUIRED);const n=r1(e);try{const e=await this.components.datastore.get(n),r=(0,Su.B)(e),i=Y0.get(this);if(null==i)throw new VJ("dek missing",V0.ERR_INVALID_PARAMETERS);const o=i.dek,s=await O$(r,o);return await s.export(t)}catch(r){throw await n1(),r}}async exportPeerId(e){const t="temporary-password",n=await this.exportKey(e,t),r=await O$(n,t);return async function(e,t){return e.length===O0?new M0({multihash:kX(DX.code,e),privateKey:t}):e.length===N0?new U0({multihash:kX(DX.code,e),privateKey:t}):new L0({multihash:await LX.digest(e),publicKey:e,privateKey:t})}(r.public.bytes,r.bytes)}async importKey(e,t,n){if(!t1(e)||"self"===e)throw await n1(),new VJ("Invalid key name '".concat(e,"'"),V0.ERR_INVALID_KEY_NAME);if(null==t)throw await n1(),new VJ("PEM encoded key is required",V0.ERR_PEM_REQUIRED);const r=r1(e);if(await this.components.datastore.has(r))throw await n1(),new VJ("Key '".concat(e,"' already exists"),V0.ERR_KEY_ALREADY_EXISTS);let i,o;try{i=await O$(t,n)}catch(c){throw await n1(),new VJ("Cannot read the key, most likely the password is wrong",V0.ERR_CANNOT_READ_KEY)}try{o=await i.id();const e=Y0.get(this);if(null==e)throw new VJ("dek missing",V0.ERR_INVALID_PARAMETERS);const n=e.dek;t=await i.export(n)}catch(c){throw await n1(),c}const s={name:e,id:o},a=this.components.datastore.batch();return a.put(r,(0,mu.m)(t)),a.put(i1(e),(0,mu.m)(JSON.stringify(s))),await a.commit(),s}async importPeer(e,t){try{if(!t1(e))throw new VJ("Invalid key name '".concat(e,"'"),V0.ERR_INVALID_KEY_NAME);if(null==t)throw new VJ("PeerId is required",V0.ERR_MISSING_PRIVATE_KEY);if(null==t.privateKey)throw new VJ("PeerId.privKey is required",V0.ERR_MISSING_PRIVATE_KEY);const n=await D$(t.privateKey),r=r1(e);if(await this.components.datastore.has(r))throw await n1(),new VJ("Key '".concat(e,"' already exists"),V0.ERR_KEY_ALREADY_EXISTS);const i=Y0.get(this);if(null==i)throw new VJ("dek missing",V0.ERR_INVALID_PARAMETERS);const o=i.dek,s=await n.export(o),a={name:e,id:t.toString()},c=this.components.datastore.batch();return c.put(r,(0,mu.m)(s)),c.put(i1(e),(0,mu.m)(JSON.stringify(a))),await c.commit(),a}catch(n){throw await n1(),n}}async getPrivateKey(e){if(!t1(e))throw await n1(),new VJ("Invalid key name '".concat(e,"'"),V0.ERR_INVALID_KEY_NAME);try{const t=r1(e),n=await this.components.datastore.get(t);return(0,Su.B)(n)}catch(t){throw await n1(),W0.error(t),new VJ("Key '".concat(e,"' does not exist."),V0.ERR_KEY_NOT_FOUND)}}async rotateKeychainPass(e,t){var n,r,i,o;if("string"!==typeof e)throw await n1(),new VJ("Invalid old pass type '".concat(typeof e,"'"),V0.ERR_INVALID_OLD_PASS_TYPE);if("string"!==typeof t)throw await n1(),new VJ("Invalid new pass type '".concat(typeof t,"'"),V0.ERR_INVALID_NEW_PASS_TYPE);if(t.length<20)throw await n1(),new VJ("Invalid pass length ".concat(t.length),V0.ERR_INVALID_PASS_LENGTH);W0("recreating keychain");const s=Y0.get(this);if(null==s)throw new VJ("dek missing",V0.ERR_INVALID_PARAMETERS);const a=s.dek;this.init.pass=t;const c=null!=t&&null!=(null===(n=this.init.dek)||void 0===n?void 0:n.salt)?M$(t,this.init.dek.salt,null===(r=this.init.dek)||void 0===r?void 0:r.iterationCount,null===(i=this.init.dek)||void 0===i?void 0:i.keyLength,null===(o=this.init.dek)||void 0===o?void 0:o.hash):"";Y0.set(this,{dek:c});const l=await this.listKeys();for(const u of l){const e=await this.components.datastore.get(r1(u.name)),t=(0,Su.B)(e),n=await O$(t,a),r=c.toString(),i=await n.export(r),o=this.components.datastore.batch(),s={name:u.name,id:u.id};o.put(r1(u.name),(0,mu.m)(i)),o.put(i1(u.name),(0,mu.m)(JSON.stringify(s))),await o.commit()}W0("keychain reconstructed")}}const s1=Symbol.for("@libp2p/peer-id");function a1(e){return null!=e&&Boolean(e[s1])}const c1=dH({prefix:"9",name:"base10",alphabet:"0123456789"}),l1=fH({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),u1=fH({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),h1=fH({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),d1=Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42"),f1=d1.reduce(((e,t,n)=>(e[n]=t,e)),[]),p1=d1.reduce(((e,t,n)=>(e[t.codePointAt(0)]=n,e)),[]);const g1=hH({prefix:"\ud83d\ude80",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=f1[t]),"")},decode:function(e){const t=[];for(const n of e){const e=p1[n.codePointAt(0)];if(void 0===e)throw new Error("Non-base256emoji character: ".concat(n));t.push(e)}return new Uint8Array(t)}}),y1=fH({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),m1=hH({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>(e=>(new TextEncoder).encode(e))(e)}),v1={...En,...vn,...wn,...yn,...mn,...jt,...Ht,...Zt,...zt,...bn};let b1;const w1=Symbol.for("nodejs.util.inspect.custom"),E1=Object.values(v1).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)),v1.identity.decoder),A1=114,S1=36,_1=37;b1=Symbol.toStringTag;class I1{constructor(e){(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"multihash",void 0),(0,Yo.Z)(this,"privateKey",void 0),(0,Yo.Z)(this,"publicKey",void 0),(0,Yo.Z)(this,"string",void 0),(0,Yo.Z)(this,s1,!0),this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[b1](){return"PeerId(".concat(this.toString(),")")}toString(){return null==this.string&&(this.string=SH.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return wq.createV1(A1,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e instanceof Uint8Array)return(0,Ms.f)(this.multihash.bytes,e);if("string"===typeof e)return R1(e).equals(this);if(null!=(null===e||void 0===e||null===(t=e.multihash)||void 0===t?void 0:t.bytes))return(0,Ms.f)(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[w1](){return"PeerId(".concat(this.toString(),")")}}class C1 extends I1{constructor(e){super({...e,type:"RSA"}),(0,Yo.Z)(this,"type","RSA"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.publicKey}}class T1 extends I1{constructor(e){super({...e,type:"Ed25519"}),(0,Yo.Z)(this,"type","Ed25519"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}class k1 extends I1{constructor(e){super({...e,type:"secp256k1"}),(0,Yo.Z)(this,"type","secp256k1"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}function R1(e,t){var n;if(t=null!==(n=t)&&void 0!==n?n:E1,"1"===e.charAt(0)||"Q"===e.charAt(0)){const t=gq(SH.decode("z".concat(e)));return e.startsWith("12D")?new T1({multihash:t}):e.startsWith("16U")?new k1({multihash:t}):new C1({multihash:t})}return x1(E1.decode(e))}function x1(e){try{const t=gq(e);if(t.code===NY.code){if(t.digest.length===S1)return new T1({multihash:t});if(t.digest.length===_1)return new k1({multihash:t})}if(t.code===Uq.code)return new C1({multihash:t})}catch{return function(e){if(null==e||null==e.multihash||null==e.version||1===e.version&&e.code!==A1)throw new Error("Supplied PeerID CID is invalid");const t=e.multihash;if(t.code===Uq.code)return new C1({multihash:e.multihash});if(t.code===NY.code){if(t.digest.length===S1)return new T1({multihash:e.multihash});if(t.digest.length===_1)return new k1({multihash:e.multihash})}throw new Error("Supplied PeerID CID is invalid")}(wq.decode(e))}throw new Error("Supplied PeerID CID is invalid")}async function P1(e,t){return e.length===S1?new T1({multihash:pq(NY.code,e),privateKey:t}):e.length===_1?new k1({multihash:pq(NY.code,e),privateKey:t}):new C1({multihash:await Uq.digest(e),publicKey:e,privateKey:t})}const D1=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{const t=[];for await(const n of e)t.push(n);return t})();const t=[];for(const n of e)t.push(n);return t};var O1=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=h,t++}if(" "!==e[t]){for(var f=o-i;f!==o&&0===s[f];)f++;for(var p=new Uint8Array(r+(o-f)),g=r;f!==o;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=